{"id": "Python/8", "code": "import sys\nsys.setrecursionlimit(100000)\n\n\ndef dfs(i):\n    for v, w in V.get(i, []):\n        if (w % 2) == 0:\n            if color[v] == -1:\n                color[v] = color[i]\n            elif color[v] == color[i]:\n                continue\n            elif color[v] != color[i]:\n                return False\n        else:\n            if color[v] == -1:\n                color[v] = 0 if color[i] else 1\n            elif color[v] == color[i]:\n                return False\n            elif color[v] != color[i]:\n                continue\n        dfs(v)\n    return True\n\n\nif __name__ == '__main__':\n    n = int(input())\n    V = {}\n    color = {}\n    for i in range(1, n):\n        u, v, w = map(int, input().split())\n        if not V.get(u, False):\n            V[u] = [[v, w]]\n        else:\n            V[u].append([v, w])\n\n        if not V.get(v, False):\n            V[v] = [[u, w]]\n        else:\n            V[v].append([u, w])\n\n    for i in range(1, n+1):\n        color[i] = -1\n\n    while True:\n        i = 0\n        for j in range(1, n+1):\n            if color[j] == -1:\n                i = j\n                color[i] = 0\n                break\n        if i == 0:\n            for j in range(1, n+1):\n                print(color[j])\n            break\n        else:\n            if not dfs(i):\n                print('No')\n                break\n", "test_IO": {"input": ["3\n1 2 2\n2 3 1\n"], "output": ["0\n0\n1\n"]}, "modified_context": "import sys\nsys.setrecursionlimit(100000)\n\n\ndef dfs(i):\n    for v, w in V.get(i, []):\n        if (w % 2) == 0:\n            if color[v] == -1:\n                color[v] = color[i]\n            elif color[v] == color[i]:\n                continue\n            elif color[v] != color[i]:\n                return False\n        else:\n            if color[v] == -1:\n                color[v] = 0 if color[i] else 1\n            elif color[v] == color[i]:\n                return False\n            elif color[v] != color[i]:\n                continue\n        dfs(v)\n    return True\n\n\nif __name__ == '__main__':\n    n = int(input())\n    V = {}\n    color = {}\n    for i in range(1, n):\n        u, v, w = map(int, input().split())\n        if not V.get(u, False):\n            V[u] = [ [v, w]]\n        else:\n            V[u].append( [v, w])\n\n        if not V.get(v, False):\n            V[v] = [ [u, w]]\n        else:\n            V[v].append( [u, w])\n\n    for i in range(1, n+1):\n        color[i] = -1\n\n    while True:\n        i = 0\n        for j in range(1, n+1):\n            if color[j] == -1:\n                i = j\n                color[i] = 0\n                break\n        if i == 0:\n            for j in range(1, n+1):\n                print(color[j])\n            break\n        else:\n            if not dfs(i):\n                print('No')\n                break\n", "token_boundary_changed": true}
{"id": "Python/18", "code": "x, y, a, b, c = map(int, input().split())\np = sorted([int(i) for i in input().split()], reverse=True)[:x]\nq = sorted([int(i) for i in input().split()], reverse=True)[:y]\nr = sorted([int(i) for i in input().split()], reverse=True)\npq = sorted(p+q)\nfor i in range(min(x+y, a+b, c)):\n    if pq[i] < r[i]:\n        pq[i] = r[i]\nprint(sum(pq))\n", "test_IO": {"input": ["1 2 2 2 1\n2 4\n5 1\n3\n"], "output": ["12\n"]}, "modified_context": "x, y, a, b, c = map(int, input().split())\np = sorted( [int(i) for i in input().split()], reverse=True) [:x]\nq = sorted( [int(i) for i in input().split()], reverse=True) [:y]\nr = sorted( [int(i) for i in input().split()], reverse=True)\npq = sorted(p+q)\nfor i in range(min(x+y, a+b, c)):\n    if pq[i] < r[i]:\n        pq[i] = r[i]\nprint(sum(pq))\n", "token_boundary_changed": true}
{"id": "Python/19", "code": "n = int(input())\na = list(map(int, input().split()))\n\nm1 = int(sum([a[i] * ((-1)**i) for i in range(n)]) / 2)\n\nresult = str(m1)\n\nm = [None] * n\nm[0] = m1\nfor i in range(1, n):\n    m[i] = a[i-1] - m[i-1]\n\nprint(' '.join([str(x*2) for x in m]))\n", "test_IO": {"input": ["3\n2 2 4\n"], "output": ["4 0 4\n"]}, "modified_context": "n = int(input())\na = list(map(int, input().split()))\n\nm1 = int(sum( [a[i] * ((-1)**i) for i in range(n)]) / 2)\n\nresult = str(m1)\n\nm = [None] * n\nm[0] = m1\nfor i in range(1, n):\n    m[i] = a[i-1] - m[i-1]\n\nprint(' '.join( [str(x*2) for x in m]))\n", "token_boundary_changed": true}
{"id": "Python/22", "code": "n = int(input())\nprint(len(set([input() for _ in range(n)])))\n", "test_IO": {"input": ["4\n10\n8\n8\n6\n"], "output": ["3\n"]}, "modified_context": "n = int(input())\nprint(len(set( [input() for _ in range(n)])))\n", "token_boundary_changed": true}
{"id": "Python/25", "code": "from itertools import combinations_with_replacement\nimport sys\n\n\ndef LI(): return map(int, sys.stdin.readline().rstrip().split())\n\n\nN, M, Q = LI()\n\nQ_groups = []\nfor _ in range(Q):\n    Q_groups.append([*LI()])\n\nmax_score = 0\nfor p in combinations_with_replacement(range(1, M + 1), r=N):\n    temp_score = 0\n    for q in Q_groups:\n        if p[q[1] - 1] - p[q[0] - 1] == q[2]:\n            temp_score += q[3]\n    max_score = max(max_score, temp_score)\n\nprint(max_score)\n", "test_IO": {"input": ["3 4 3\n1 3 3 100\n1 2 2 10\n2 3 2 10\n"], "output": ["110\n"]}, "modified_context": "from itertools import combinations_with_replacement\nimport sys\n\n\ndef LI(): return map(int, sys.stdin.readline().rstrip().split())\n\n\nN, M, Q = LI()\n\nQ_groups = []\nfor _ in range(Q):\n    Q_groups.append( [*LI()])\n\nmax_score = 0\nfor p in combinations_with_replacement(range(1, M + 1), r=N):\n    temp_score = 0\n    for q in Q_groups:\n        if p[q[1] - 1] - p[q[0] - 1] == q[2]:\n            temp_score += q[3]\n    max_score = max(max_score, temp_score)\n\nprint(max_score)\n", "token_boundary_changed": true}
{"id": "Python/26", "code": "strn = input()\nn = int(strn)\nshichigolist = [\"3\", \"5\", \"7\"]\nshichigo = [[] for _ in range(len(strn))]\nfor i in range(len(strn)):\n    if i == 0:\n        for j in shichigolist:\n            shichigo[i].append(j)\n    else:\n        for j in shichigo[i-1]:\n            for k in shichigolist:\n                shichigo[i].append(j+k)\ntarget = len(strn)-1\nfor i in range(len(strn)):\n    for j in shichigo[i][:]:\n        if i == target:\n            if int(j) > n:\n                shichigo[target].remove(j)\n            elif j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[target].remove(j)\n        else:\n            if j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[i].remove(j)\n\nprint(sum([len(shichigo[i]) for i in range(len(strn))]))\n", "test_IO": {"input": ["575\n"], "output": ["4\n"]}, "modified_context": "strn = input()\nn = int(strn)\nshichigolist = [\"3\", \"5\", \"7\"]\nshichigo = [ [] for _ in range(len(strn))]\nfor i in range(len(strn)):\n    if i == 0:\n        for j in shichigolist:\n            shichigo[i].append(j)\n    else:\n        for j in shichigo[i-1]:\n            for k in shichigolist:\n                shichigo[i].append(j+k)\ntarget = len(strn)-1\nfor i in range(len(strn)):\n    for j in shichigo[i] [:]:\n        if i == target:\n            if int(j) > n:\n                shichigo[target].remove(j)\n            elif j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[target].remove(j)\n        else:\n            if j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[i].remove(j)\n\nprint(sum( [len(shichigo[i]) for i in range(len(strn))]))\n", "token_boundary_changed": true}
{"id": "Python/28", "code": "N = int(input())\nA = list(map(int, input().split()))\nB = [0] * N\n\nfor i in range(N - 1, -1, -1):\n    tmp_sum = 0\n    for j in range((i + 1) * 2 - 1, N, i + 1):\n        tmp_sum += B[j]\n        tmp_sum %= 2\n    B[i] = tmp_sum ^ A[i]\n\nprint(sum(B))\nprint(*[i + 1 for i, b in enumerate(B) if b == 1])\n", "test_IO": {"input": ["3\n1 0 0\n"], "output": ["1\n1\n"]}, "modified_context": "N = int(input())\nA = list(map(int, input().split()))\nB = [0] * N\n\nfor i in range(N - 1, -1, -1):\n    tmp_sum = 0\n    for j in range((i + 1) * 2 - 1, N, i + 1):\n        tmp_sum += B[j]\n        tmp_sum %= 2\n    B[i] = tmp_sum ^ A[i]\n\nprint(sum(B))\nprint(* [i + 1 for i, b in enumerate(B) if b == 1])\n", "token_boundary_changed": false}
{"id": "Python/34", "code": "import math\nN, D = map(int, input().split())\nmat = []\nfor d in range(N):\n    mat.append([int(x) for x in input().split()])\n\nc = 0\nfor i in range(len(mat)-1):\n    for j in range(i+1, len(mat)):\n        dist = math.sqrt(sum([(x-y)**2 for x, y in zip(mat[i], mat[j])]))\n        if int(dist) == dist:\n            c += 1\nprint(c)\n", "test_IO": {"input": ["3 2\n1 2\n5 5\n-2 8\n"], "output": ["1\n"]}, "modified_context": "import math\nN, D = map(int, input().split())\nmat = []\nfor d in range(N):\n    mat.append( [int(x) for x in input().split()])\n\nc = 0\nfor i in range(len(mat)-1):\n    for j in range(i+1, len(mat)):\n        dist = math.sqrt(sum( [(x-y)**2 for x, y in zip(mat[i], mat[j])]))\n        if int(dist) == dist:\n            c += 1\nprint(c)\n", "token_boundary_changed": true}
{"id": "Python/39", "code": "h, w, ka = map(int, input().split())\nmat = [list(input()) for i in range(h)]\nans = 0\nfor i in range(2**(h+w)):\n    b = bin(i)[2:].zfill(h+w)\n    rs = b[:h]\n    cs = b[h:]\n    ct = 0\n    for l in range(h):\n        for k in range(w):\n            if mat[l][k] == '#' and rs[l] == '0' and cs[k] == '0':\n                ct += 1\n    if ct == ka:\n        ans += 1\nprint(ans)\n", "test_IO": {"input": ["2 3 2\n..#\n###\n"], "output": ["5\n"]}, "modified_context": "h, w, ka = map(int, input().split())\nmat = [list(input()) for i in range(h)]\nans = 0\nfor i in range(2**(h+w)):\n    b = bin(i) [2:].zfill(h+w)\n    rs = b[:h]\n    cs = b[h:]\n    ct = 0\n    for l in range(h):\n        for k in range(w):\n            if mat[l] [k] == '#' and rs[l] == '0' and cs[k] == '0':\n                ct += 1\n    if ct == ka:\n        ans += 1\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/41", "code": "def bubbleSort(cards):\n    n = len(cards)\n    for i in range(0, n):\n        for j in range(n-1, i, -1):\n            if int(cards[j][1]) < int(cards[j-1][1]):\n                cards[j], cards[j-1] = cards[j-1], cards[j]\n\n    print(\" \".join(map(str, cards)))\n\n\ndef selectionSort(cards):\n    n = len(cards)\n    for i in range(0, n):\n        mini = i\n        for j in range(i, n):\n            if int(cards[j][1]) < int(cards[mini][1]):\n                mini = j\n        if mini != i:\n            cards[i], cards[mini] = cards[mini], cards[i]\n\n    print(\" \".join(map(str, cards)))\n\n\nn = int(input())\ncards = input().split(\" \")\ncards2 = list(cards)\nbubbleSort(cards)\nprint(\"Stable\")\nselectionSort(cards2)\nif \" \".join(map(str, cards2)) == \" \".join(map(str, cards)):\n    print(\"Stable\")\nelse:\n    print(\"Not stable\")\n", "test_IO": {"input": ["5\nH4 C9 S4 D2 C3\n"], "output": ["D2 C3 H4 S4 C9\nStable\nD2 C3 S4 H4 C9\nNot stable\n"]}, "modified_context": "def bubbleSort(cards):\n    n = len(cards)\n    for i in range(0, n):\n        for j in range(n-1, i, -1):\n            if int(cards[j] [1]) < int(cards[j-1] [1]):\n                cards[j], cards[j-1] = cards[j-1], cards[j]\n\n    print(\" \".join(map(str, cards)))\n\n\ndef selectionSort(cards):\n    n = len(cards)\n    for i in range(0, n):\n        mini = i\n        for j in range(i, n):\n            if int(cards[j] [1]) < int(cards[mini] [1]):\n                mini = j\n        if mini != i:\n            cards[i], cards[mini] = cards[mini], cards[i]\n\n    print(\" \".join(map(str, cards)))\n\n\nn = int(input())\ncards = input().split(\" \")\ncards2 = list(cards)\nbubbleSort(cards)\nprint(\"Stable\")\nselectionSort(cards2)\nif \" \".join(map(str, cards2)) == \" \".join(map(str, cards)):\n    print(\"Stable\")\nelse:\n    print(\"Not stable\")\n", "token_boundary_changed": true}
{"id": "Python/44", "code": "import sys\nimport math\n\nfrom collections import defaultdict\nfrom collections import deque\n\n\ndef load(vtype=int):\n    return vtype(input().strip())\n\n\ndef load_list(seplator=\" \", vtype=int):\n    return [vtype(v) for v in input().strip().split(seplator)]\n\n\ndef exit():\n    import sys\n    sys.exit(0)\n\n\ndef perm_sub(li, used):\n    if len(li) == len(used):\n        return [deque()]\n    k = []\n    for i in range(len(li)):\n        if i in used:\n            continue\n        used.add(i)\n        sub_list = perm_sub(li, used)\n        for sub in sub_list:\n            sub.appendleft(li[i])\n        k.extend(sub_list)\n        used.discard(i)\n    return k\n\n\ndef perm_li(li):\n    return perm_sub(li, set())\n\n\ndef perm_n(n):\n    return perm_sub(list(range(n)), set())\n\n\ndef join_i(li, sep=\"\"):\n    return sep.join([str(e) for e in li])\n\n\ndef li2n(li):\n    n, base = 0, 1\n    for i in range(len(li)-1, -1, -1):\n        n += li[i] * base\n        base *= 10\n    return n\n\n\ndef sli2ili(li):\n    return [int(s) for s in li]\n\n\ndef prime_list(n):\n    li = [i for i in range(2, n+1)]\n    for i in range(len(li)):\n        if li[i] >= int(math.sqrt(n)):\n            break\n        if li[i] == -1:\n            continue\n        for j in range(i+1, len(li)):\n            if li[j] % li[i] == 0:\n                li[j] = -1\n    return [n for n in li if n != -1]\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while True:\n        r = a % b\n        if r == 0:\n            return b\n        a, b = b, r\n\n\ndef lcm(a, b):\n    return int(a * b / gcd(a, b))\n\n\ndef all_subset(li):\n    s = []\n    n = len(li)\n    for bit in range(0, (1 << (n+1))):\n        ss = set()\n        for i in range(0, n):\n            if (bit & (1 << i)):\n                ss.add(li[i])\n        s.append(ss)\n    return s\n\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\n\n\ndef mCn(m, n):\n    def factorial_ntimes(m, n):\n        r = 1\n        while n:\n            r *= m\n            m -= 1\n            n -= 1\n        return r\n    return int(factorial_ntimes(m, n) / factorial(n))\n\n\nn = load()\nA = load_list()\n\nif n == len(set(A)):\n    print('YES')\nelse:\n    print('NO')\n", "test_IO": {"input": ["5\n2 6 1 4 5\n"], "output": ["YES\n"]}, "modified_context": "import sys\nimport math\n\nfrom collections import defaultdict\nfrom collections import deque\n\n\ndef load(vtype=int):\n    return vtype(input().strip())\n\n\ndef load_list(seplator=\" \", vtype=int):\n    return [vtype(v) for v in input().strip().split(seplator)]\n\n\ndef exit():\n    import sys\n    sys.exit(0)\n\n\ndef perm_sub(li, used):\n    if len(li) == len(used):\n        return [deque()]\n    k = []\n    for i in range(len(li)):\n        if i in used:\n            continue\n        used.add(i)\n        sub_list = perm_sub(li, used)\n        for sub in sub_list:\n            sub.appendleft(li[i])\n        k.extend(sub_list)\n        used.discard(i)\n    return k\n\n\ndef perm_li(li):\n    return perm_sub(li, set())\n\n\ndef perm_n(n):\n    return perm_sub(list(range(n)), set())\n\n\ndef join_i(li, sep=\"\"):\n    return sep.join( [str(e) for e in li])\n\n\ndef li2n(li):\n    n, base = 0, 1\n    for i in range(len(li)-1, -1, -1):\n        n += li[i] * base\n        base *= 10\n    return n\n\n\ndef sli2ili(li):\n    return [int(s) for s in li]\n\n\ndef prime_list(n):\n    li = [i for i in range(2, n+1)]\n    for i in range(len(li)):\n        if li[i] >= int(math.sqrt(n)):\n            break\n        if li[i] == -1:\n            continue\n        for j in range(i+1, len(li)):\n            if li[j] % li[i] == 0:\n                li[j] = -1\n    return [n for n in li if n != -1]\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while True:\n        r = a % b\n        if r == 0:\n            return b\n        a, b = b, r\n\n\ndef lcm(a, b):\n    return int(a * b / gcd(a, b))\n\n\ndef all_subset(li):\n    s = []\n    n = len(li)\n    for bit in range(0, (1 << (n+1))):\n        ss = set()\n        for i in range(0, n):\n            if (bit & (1 << i)):\n                ss.add(li[i])\n        s.append(ss)\n    return s\n\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\n\n\ndef mCn(m, n):\n    def factorial_ntimes(m, n):\n        r = 1\n        while n:\n            r *= m\n            m -= 1\n            n -= 1\n        return r\n    return int(factorial_ntimes(m, n) / factorial(n))\n\n\nn = load()\nA = load_list()\n\nif n == len(set(A)):\n    print('YES')\nelse:\n    print('NO')\n", "token_boundary_changed": true}
{"id": "Python/51", "code": "n = int(input())\nlst = []\npair = 0\nfor i in range(n):\n    st = ''.join(sorted(list(input())))\n    lst.append(st)\nlst = sorted(lst)\nlst += ['end']\npre = ''\ntmp_cnt = 0\ncnt = 0\nfor i in lst:\n    if i == pre:\n        tmp_cnt += 1\n    else:\n        cnt += sum([j for j in range(tmp_cnt + 1)])\n        tmp_cnt = 0\n    pre = i\nprint(cnt)\n", "test_IO": {"input": ["3\nacornistnt\npeanutbomb\nconstraint\n"], "output": ["1\n"]}, "modified_context": "n = int(input())\nlst = []\npair = 0\nfor i in range(n):\n    st = ''.join(sorted(list(input())))\n    lst.append(st)\nlst = sorted(lst)\nlst += ['end']\npre = ''\ntmp_cnt = 0\ncnt = 0\nfor i in lst:\n    if i == pre:\n        tmp_cnt += 1\n    else:\n        cnt += sum( [j for j in range(tmp_cnt + 1)])\n        tmp_cnt = 0\n    pre = i\nprint(cnt)\n", "token_boundary_changed": true}
{"id": "Python/78", "code": "import collections\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    ve = []\n    vo = []\n    for i in range(n//2):\n        ve.append(v[2*i])\n        vo.append(v[2*i+1])\n    ce = collections.Counter(ve)\n    co = collections.Counter(vo)\n    ans = n\n    if ce.most_common()[0][0] != co.most_common()[0][0]:\n        ans = n-ce.most_common()[0][1]-co.most_common()[0][1]\n    elif len(ce) == 1 and len(co) == 1:\n        ans = n-ce.most_common()[0][1]\n    elif len(ce) == 1:\n        ans = n-ce.most_common()[0][1]-co.most_common()[1][1]\n    elif len(co) == 1:\n        ans = n-ce.most_common()[1][1]-co.most_common()[0][1]\n    else:\n        ans = min(n-ce.most_common()[0][1]-co.most_common()[1]\n                  [1], n-ce.most_common()[1][1]-co.most_common()[0][1])\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "test_IO": {"input": ["4\n3 1 3 2\n"], "output": ["1\n"]}, "modified_context": "import collections\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    ve = []\n    vo = []\n    for i in range(n//2):\n        ve.append(v[2*i])\n        vo.append(v[2*i+1])\n    ce = collections.Counter(ve)\n    co = collections.Counter(vo)\n    ans = n\n    if ce.most_common() [0] [0] != co.most_common() [0] [0]:\n        ans = n-ce.most_common() [0] [1]-co.most_common() [0] [1]\n    elif len(ce) == 1 and len(co) == 1:\n        ans = n-ce.most_common() [0] [1]\n    elif len(ce) == 1:\n        ans = n-ce.most_common() [0] [1]-co.most_common() [1] [1]\n    elif len(co) == 1:\n        ans = n-ce.most_common() [1] [1]-co.most_common() [0] [1]\n    else:\n        ans = min(n-ce.most_common() [0] [1]-co.most_common() [1]\n                  [1], n-ce.most_common() [1] [1]-co.most_common() [0] [1])\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "token_boundary_changed": true}
{"id": "Python/90", "code": "n, m = map(int, input().split())\n\ngate_cond = [[int(x) for x in input().split()] for _ in range(m)]\nmax_under_th = max([l[0] for l in gate_cond])\nmin_upper_th = min([l[1] for l in gate_cond])\nif min_upper_th - max_under_th >= 0:\n    print(min_upper_th - max_under_th + 1)\nelse:\n    print(0)\n", "test_IO": {"input": ["4 2\n1 3\n2 4\n"], "output": ["2\n"]}, "modified_context": "n, m = map(int, input().split())\n\ngate_cond = [ [int(x) for x in input().split()] for _ in range(m)]\nmax_under_th = max( [l[0] for l in gate_cond])\nmin_upper_th = min( [l[1] for l in gate_cond])\nif min_upper_th - max_under_th >= 0:\n    print(min_upper_th - max_under_th + 1)\nelse:\n    print(0)\n", "token_boundary_changed": true}
{"id": "Python/92", "code": "ABC = list(map(int, input().split()))\n\nA = ABC[0]\nB = ABC[1]\nC = ABC[2]\n\nprint(max([10*A+B+C, 10*B+C+A, 10*C+A+B]))\n", "test_IO": {"input": ["1 5 2\n"], "output": ["53\n"]}, "modified_context": "ABC = list(map(int, input().split()))\n\nA = ABC[0]\nB = ABC[1]\nC = ABC[2]\n\nprint(max( [10*A+B+C, 10*B+C+A, 10*C+A+B]))\n", "token_boundary_changed": true}
{"id": "Python/98", "code": "a = [int(input()) for i in range(5)]\n\ndic = {}\n\nfor i in range(5):\n    if str(a[i])[-1] == \"0\":\n        dic.update({i: 0})\n    else:\n        dic.update({i: int(str(a[i])[-1]) - 10})\n\n\nmin_num = [i for i in dic if dic[i] == min(dic.values())][0]\na_sum = sum(a)\ndic.pop(min_num)\nprint(abs(sum(dic.values())) + a_sum)\n", "test_IO": {"input": ["29\n20\n7\n35\n120\n"], "output": ["215\n"]}, "modified_context": "a = [int(input()) for i in range(5)]\n\ndic = {}\n\nfor i in range(5):\n    if str(a[i]) [-1] == \"0\":\n        dic.update({i: 0})\n    else:\n        dic.update({i: int(str(a[i]) [-1]) - 10})\n\n\nmin_num = [i for i in dic if dic[i] == min(dic.values())] [0]\na_sum = sum(a)\ndic.pop(min_num)\nprint(abs(sum(dic.values())) + a_sum)\n", "token_boundary_changed": true}
{"id": "Python/107", "code": "from collections import deque\nn = int(input())\na = list(map(str, input().split()))\nb = []\n\nb = a[1::2][::-1]+a[::2]\nif len(a) % 2 == 0:\n    print(' '.join(b))\nelse:\n    print(' '.join(b[::-1]))\n", "test_IO": {"input": ["4\n1 2 3 4\n"], "output": ["4 2 1 3\n"]}, "modified_context": "from collections import deque\nn = int(input())\na = list(map(str, input().split()))\nb = []\n\nb = a[1::2] [::-1]+a[::2]\nif len(a) % 2 == 0:\n    print(' '.join(b))\nelse:\n    print(' '.join(b[::-1]))\n", "token_boundary_changed": true}
{"id": "Python/112", "code": "N = int(input())\nm = []\nline = ''\nm = [[[0 for k in range(10)] for j in range(3)] for i in range(10)]\nfor i in range(N):\n    n = input().split()\n    b = int(n[0])\n    f = int(n[1])\n    r = int(n[2])\n    v = int(n[3])\n    m[b-1][f-1][r-1] += v\n\nfor i in range(4):\n    for j in range(3):\n        for k in range(10):\n            line += ' {0}'.format(m[i][j][k])\n        print(line)\n        line = ''\n    if i < 3:\n        print('#'*20)\n", "test_IO": {"input": ["3\n1 1 3 8\n3 2 2 7\n4 3 8 1\n"], "output": [" 0 0 8 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0\n####################\n 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0\n####################\n 0 0 0 0 0 0 0 0 0 0\n 0 7 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0\n####################\n 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 0 0 0\n 0 0 0 0 0 0 0 1 0 0\n"]}, "modified_context": "N = int(input())\nm = []\nline = ''\nm = [ [ [0 for k in range(10)] for j in range(3)] for i in range(10)]\nfor i in range(N):\n    n = input().split()\n    b = int(n[0])\n    f = int(n[1])\n    r = int(n[2])\n    v = int(n[3])\n    m[b-1] [f-1] [r-1] += v\n\nfor i in range(4):\n    for j in range(3):\n        for k in range(10):\n            line += ' {0}'.format(m[i] [j] [k])\n        print(line)\n        line = ''\n    if i < 3:\n        print('#'*20)\n", "token_boundary_changed": true}
{"id": "Python/115", "code": "def main():\n\n    N, M, Q = map(int, input().split())\n    train = [[0 for _ in range(N)] for _ in range(N)]\n    for _ in range(M):\n        l, r = map(int, input().split())\n        train[l-1][r-1] += 1\n\n    accum = [[0 for _ in range(N+1)]]\n    for i in range(N):\n        temp = [0]\n        v = 0\n        for j in range(N):\n            v += train[i][j]\n            temp.append(accum[-1][j+1]+v)\n        accum.append(temp)\n\n    for _ in range(Q):\n        p, q = map(int, input().split())\n        v = accum[q][q] - accum[p-1][q] - accum[q][p-1] + accum[p-1][p-1]\n        print(v)\n\n\nif __name__ == '__main__':\n    main()\n", "test_IO": {"input": ["2 3 1\n1 1\n1 2\n2 2\n1 2\n"], "output": ["3\n"]}, "modified_context": "def main():\n\n    N, M, Q = map(int, input().split())\n    train = [ [0 for _ in range(N)] for _ in range(N)]\n    for _ in range(M):\n        l, r = map(int, input().split())\n        train[l-1] [r-1] += 1\n\n    accum = [ [0 for _ in range(N+1)]]\n    for i in range(N):\n        temp = [0]\n        v = 0\n        for j in range(N):\n            v += train[i] [j]\n            temp.append(accum[-1] [j+1]+v)\n        accum.append(temp)\n\n    for _ in range(Q):\n        p, q = map(int, input().split())\n        v = accum[q] [q] - accum[p-1] [q] - accum[q] [p-1] + accum[p-1] [p-1]\n        print(v)\n\n\nif __name__ == '__main__':\n    main()\n", "token_boundary_changed": true}
{"id": "Python/125", "code": "import collections\n\nn = int(input())\nls = [input() for i in range(n)]\nc = collections.Counter(ls)\n\ncount = c.most_common()[0][1]\nans = []\np = c.most_common()\nfor i in range(len(c)):\n    if p[i][1] == count:\n        ans.append(p[i][0])\n    else:\n        break\nans = sorted(ans)\nfor i in ans:\n    print(i)\n", "test_IO": {"input": ["7\nbeat\nvet\nbeet\nbed\nvet\nbet\nbeet\n"], "output": ["beet\nvet\n"]}, "modified_context": "import collections\n\nn = int(input())\nls = [input() for i in range(n)]\nc = collections.Counter(ls)\n\ncount = c.most_common() [0] [1]\nans = []\np = c.most_common()\nfor i in range(len(c)):\n    if p[i] [1] == count:\n        ans.append(p[i] [0])\n    else:\n        break\nans = sorted(ans)\nfor i in ans:\n    print(i)\n", "token_boundary_changed": true}
{"id": "Python/127", "code": "from collections import deque\nH, W = map(int, input().split())\nG = []\nfor i in range(H+2):\n    if i == 0 or i == H+1:\n        G.append('#'*(W+2))\n    else:\n        G.append('#' + input() + '#')\n\nans = 0\nfor sx in range(W+2):\n    for sy in range(H+2):\n        if G[sy][sx] == '.':\n            dist = [[-float('inf') for i in range(W+2)] for i in range(H+2)]\n            visited = [[-1 for i in range(W+2)] for i in range(H+2)]\n            q = deque([])\n            q.append((sx, sy))\n            dist[sy][sx] = 0\n            visited[sy][sx] = 1\n            while q:\n                x, y = q.popleft()\n\n                if G[y][x+1] == '.' and visited[y][x+1] == -1:\n                    q.append((x+1, y))\n                    dist[y][x+1] = dist[y][x] + 1\n                    visited[y][x+1] = 1\n\n                if G[y][x-1] == '.' and visited[y][x-1] == -1:\n                    q.append((x-1, y))\n                    dist[y][x-1] = dist[y][x] + 1\n                    visited[y][x-1] = 1\n\n                if G[y+1][x] == '.' and visited[y+1][x] == -1:\n                    q.append((x, y+1))\n                    dist[y+1][x] = dist[y][x] + 1\n                    visited[y+1][x] = 1\n\n                if G[y-1][x] == '.' and visited[y-1][x] == -1:\n                    q.append((x, y-1))\n                    dist[y-1][x] = dist[y][x] + 1\n                    visited[y-1][x] = 1\n            for i in range(W+2):\n                for j in range(H+2):\n                    ans = max(ans, dist[j][i])\nprint(ans)\n", "test_IO": {"input": ["3 3\n...\n...\n...\n"], "output": ["4\n"]}, "modified_context": "from collections import deque\nH, W = map(int, input().split())\nG = []\nfor i in range(H+2):\n    if i == 0 or i == H+1:\n        G.append('#'*(W+2))\n    else:\n        G.append('#' + input() + '#')\n\nans = 0\nfor sx in range(W+2):\n    for sy in range(H+2):\n        if G[sy] [sx] == '.':\n            dist = [ [-float('inf') for i in range(W+2)] for i in range(H+2)]\n            visited = [ [-1 for i in range(W+2)] for i in range(H+2)]\n            q = deque( [])\n            q.append((sx, sy))\n            dist[sy] [sx] = 0\n            visited[sy] [sx] = 1\n            while q:\n                x, y = q.popleft()\n\n                if G[y] [x+1] == '.' and visited[y] [x+1] == -1:\n                    q.append((x+1, y))\n                    dist[y] [x+1] = dist[y] [x] + 1\n                    visited[y] [x+1] = 1\n\n                if G[y] [x-1] == '.' and visited[y] [x-1] == -1:\n                    q.append((x-1, y))\n                    dist[y] [x-1] = dist[y] [x] + 1\n                    visited[y] [x-1] = 1\n\n                if G[y+1] [x] == '.' and visited[y+1] [x] == -1:\n                    q.append((x, y+1))\n                    dist[y+1] [x] = dist[y] [x] + 1\n                    visited[y+1] [x] = 1\n\n                if G[y-1] [x] == '.' and visited[y-1] [x] == -1:\n                    q.append((x, y-1))\n                    dist[y-1] [x] = dist[y] [x] + 1\n                    visited[y-1] [x] = 1\n            for i in range(W+2):\n                for j in range(H+2):\n                    ans = max(ans, dist[j] [i])\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/129", "code": "N = int(input())\nmo = []\nfor _ in range(N):\n    x, u = input().split()\n    x = float(x)\n    mo.append([x, u])\nokz = 0\nfor i in mo:\n    if i[1] == \"JPY\":\n        okz += i[0]\n    else:\n        okz += i[0]*380000\n\nprint(okz)\n", "test_IO": {"input": ["2\n10000 JPY\n0.10000000 BTC\n"], "output": ["48000.0\n"]}, "modified_context": "N = int(input())\nmo = []\nfor _ in range(N):\n    x, u = input().split()\n    x = float(x)\n    mo.append( [x, u])\nokz = 0\nfor i in mo:\n    if i[1] == \"JPY\":\n        okz += i[0]\n    else:\n        okz += i[0]*380000\n\nprint(okz)\n", "token_boundary_changed": true}
{"id": "Python/130", "code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\ns = sorted(readline().rstrip())\nt = sorted(readline().rstrip())[::-1]\nprint(\"Yes\" if s < t else \"No\")\n", "test_IO": {"input": ["yx\naxy\n"], "output": ["Yes\n"]}, "modified_context": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\ns = sorted(readline().rstrip())\nt = sorted(readline().rstrip()) [::-1]\nprint(\"Yes\" if s < t else \"No\")\n", "token_boundary_changed": true}
{"id": "Python/133", "code": "from collections import deque\nN, M = map(int, input().split())\nG = {i: [] for i in range(1, N+1)}\nfor _ in range(M):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\ncol = [-1 for _ in range(N+1)]\ncnt = 0\nfor i in range(1, N+1):\n    if col[i] < 0:\n        col[i] = cnt\n        que = deque([i])\n        while que:\n            x = que.popleft()\n            for y in G[x]:\n                if col[y] < 0:\n                    col[y] = cnt\n                    que.append(y)\n        cnt += 1\ncmax = max(col)\nprint(cmax)\n", "test_IO": {"input": ["3 1\n1 2\n"], "output": ["1\n"]}, "modified_context": "from collections import deque\nN, M = map(int, input().split())\nG = {i: [] for i in range(1, N+1)}\nfor _ in range(M):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\ncol = [-1 for _ in range(N+1)]\ncnt = 0\nfor i in range(1, N+1):\n    if col[i] < 0:\n        col[i] = cnt\n        que = deque( [i])\n        while que:\n            x = que.popleft()\n            for y in G[x]:\n                if col[y] < 0:\n                    col[y] = cnt\n                    que.append(y)\n        cnt += 1\ncmax = max(col)\nprint(cmax)\n", "token_boundary_changed": true}
{"id": "Python/142", "code": "I = input\ns = I()*2\nprint(['No', 'Yes'][I() in s])\n", "test_IO": {"input": ["vanceknowledgetoad\nadvance\n"], "output": ["Yes\n"]}, "modified_context": "I = input\ns = I()*2\nprint( ['No', 'Yes'] [I() in s])\n", "token_boundary_changed": true}
{"id": "Python/154", "code": "from collections import deque\nfrom itertools import product, permutations, combinations\nimport sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef read_col(H):\n\n    ret = []\n    for _ in range(H):\n        ret.append(list(map(int, readline().split())))\n    return tuple(map(list, zip(*ret)))\n\n\ndef read_map_as(H, replace={'#': 1, '.': 0}, pad=None):\n\n    if pad is None:\n        ret = []\n        for _ in range(H):\n            ret.append([replace[s] for s in read()[:-1]])\n\n    else:\n        ret = [[pad] * (W + 2)]\n        for _ in range(H):\n            ret.append([pad] + [replace[s] for s in read()[:-1]] + [pad])\n        ret.append([pad] * (W + 2))\n\n    return ret\n\n\ndef grid_dijkstra(grid, si: int, sj: int):\n\n    from heapq import heappop, heappush\n    H = len(grid)\n    W = len(grid[0])\n    D = [[-1] * W for _ in [0] * H]\n    que = [(0, si, sj)]\n    while que:\n        c, i, j = heappop(que)\n        if D[i][j] != -1:\n            continue\n        D[i][j] = c\n        for di, dj in product([-2, -1, 0, 1, 2], repeat=2):\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or grid[ni][nj] == 1:\n                continue\n            if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n                nc = c\n            else:\n                nc = c + 1\n            heappush(que, (nc, ni, nj))\n    return D\n\n\nMOD = 10**9 + 7\nINF = 2**31\n\n\nH, W = ints()\nsi, sj = mina(*ints())\nti, tj = mina(*ints())\n\nS = read_map_as(H)\nD = [[-1] * W for _ in [0] * H]\nque = deque([(0, si, sj)])\nwhile que:\n    c, i, j = que.popleft()\n    if D[i][j] != -1:\n        continue\n    D[i][j] = c\n    for di, dj in product([-2, -1, 0, 1, 2], repeat=2):\n        ni, nj = i + di, j + dj\n        if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or S[ni][nj] == 1:\n            continue\n        if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n            que.appendleft((c, ni, nj))\n        else:\n            que.append((c + 1, ni, nj))\n\nprint(D[ti][tj])\n", "test_IO": {"input": ["4 4\n1 1\n4 4\n..#.\n..#.\n.#..\n.#..\n"], "output": ["1\n"]}, "modified_context": "from collections import deque\nfrom itertools import product, permutations, combinations\nimport sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef read_col(H):\n\n    ret = []\n    for _ in range(H):\n        ret.append(list(map(int, readline().split())))\n    return tuple(map(list, zip(*ret)))\n\n\ndef read_map_as(H, replace={'#': 1, '.': 0}, pad=None):\n\n    if pad is None:\n        ret = []\n        for _ in range(H):\n            ret.append( [replace[s] for s in read() [:-1]])\n\n    else:\n        ret = [ [pad] * (W + 2)]\n        for _ in range(H):\n            ret.append( [pad] + [replace[s] for s in read() [:-1]] + [pad])\n        ret.append( [pad] * (W + 2))\n\n    return ret\n\n\ndef grid_dijkstra(grid, si: int, sj: int):\n\n    from heapq import heappop, heappush\n    H = len(grid)\n    W = len(grid[0])\n    D = [ [-1] * W for _ in [0] * H]\n    que = [(0, si, sj)]\n    while que:\n        c, i, j = heappop(que)\n        if D[i] [j] != -1:\n            continue\n        D[i] [j] = c\n        for di, dj in product( [-2, -1, 0, 1, 2], repeat=2):\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W) or D[ni] [nj] != -1 or ni == nj == 0 or grid[ni] [nj] == 1:\n                continue\n            if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n                nc = c\n            else:\n                nc = c + 1\n            heappush(que, (nc, ni, nj))\n    return D\n\n\nMOD = 10**9 + 7\nINF = 2**31\n\n\nH, W = ints()\nsi, sj = mina(*ints())\nti, tj = mina(*ints())\n\nS = read_map_as(H)\nD = [ [-1] * W for _ in [0] * H]\nque = deque( [(0, si, sj)])\nwhile que:\n    c, i, j = que.popleft()\n    if D[i] [j] != -1:\n        continue\n    D[i] [j] = c\n    for di, dj in product( [-2, -1, 0, 1, 2], repeat=2):\n        ni, nj = i + di, j + dj\n        if not (0 <= ni < H and 0 <= nj < W) or D[ni] [nj] != -1 or ni == nj == 0 or S[ni] [nj] == 1:\n            continue\n        if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n            que.appendleft((c, ni, nj))\n        else:\n            que.append((c + 1, ni, nj))\n\nprint(D[ti] [tj])\n", "token_boundary_changed": true}
{"id": "Python/159", "code": "n = int(input())\nls = [list(map(int, input().split())) for i in range(n)]\nls = sorted(ls, key=lambda x: sum(x), reverse=True)\ntaka = sum([ls[i][0] for i in range(0, len(ls), 2)])\naoki = sum([ls[i][1] for i in range(1, len(ls), 2)])\n\nprint(taka-aoki)\n", "test_IO": {"input": ["3\n10 10\n20 20\n30 30\n"], "output": ["20\n"]}, "modified_context": "n = int(input())\nls = [list(map(int, input().split())) for i in range(n)]\nls = sorted(ls, key=lambda x: sum(x), reverse=True)\ntaka = sum( [ls[i] [0] for i in range(0, len(ls), 2)])\naoki = sum( [ls[i] [1] for i in range(1, len(ls), 2)])\n\nprint(taka-aoki)\n", "token_boundary_changed": true}
{"id": "Python/160", "code": "n = int(input())\nF = [tuple(map(int, input().split())) for _ in range(n)]\nP = [tuple(map(int, input().split())) for _ in range(n)]\nans = -10 ** 18\n\nfor i in range(1, 2**10):\n    tmp = 0\n    lst = [0]*n\n    for j in range(10):\n        if (i >> j) & 1:\n            for k in range(n):\n                lst[k] += F[k][j]\n    for k in range(n):\n        tmp += P[k][lst[k]]\n    ans = max(ans, tmp)\n\n\nprint(ans)\n", "test_IO": {"input": ["1\n1 1 0 1 0 0 0 1 0 1\n3 4 5 6 7 8 9 -2 -3 4 -2\n"], "output": ["8\n"]}, "modified_context": "n = int(input())\nF = [tuple(map(int, input().split())) for _ in range(n)]\nP = [tuple(map(int, input().split())) for _ in range(n)]\nans = -10 ** 18\n\nfor i in range(1, 2**10):\n    tmp = 0\n    lst = [0]*n\n    for j in range(10):\n        if (i >> j) & 1:\n            for k in range(n):\n                lst[k] += F[k] [j]\n    for k in range(n):\n        tmp += P[k] [lst[k]]\n    ans = max(ans, tmp)\n\n\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/162", "code": "from math import factorial as f\n\nN = int(input())\n\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\ndivs = []\nfor i in range(1, 101):\n    tmp = [0 for _ in range(len(primes))]\n    for j in range(len(primes)):\n        p = primes[j]\n        tmp[j] = 0\n        while (i//p == i/p):\n            i = i//p\n            tmp[j] += 1\n    divs.append(tmp)\n\n\ndivsum = [0 for _ in range(len(primes))]\nfor i in range(1, N+1):\n    for j in range(len(primes)):\n        divsum[j] += divs[i-1][j]\n\n\ndef num(n):\n    return len(list(filter(lambda x: x >= n-1, divsum)))\n\n\nans = 0\n\n\nans += num(75)\n\n\nans += num(15)*(num(5)-1)\n\n\nans += num(25)*(num(3)-1)\n\n\nans += num(5) * (num(5)-1) * (num(3)-2) // 2\nprint(int(ans))\n", "test_IO": {"input": ["9\n"], "output": ["0\n"]}, "modified_context": "from math import factorial as f\n\nN = int(input())\n\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\ndivs = []\nfor i in range(1, 101):\n    tmp = [0 for _ in range(len(primes))]\n    for j in range(len(primes)):\n        p = primes[j]\n        tmp[j] = 0\n        while (i//p == i/p):\n            i = i//p\n            tmp[j] += 1\n    divs.append(tmp)\n\n\ndivsum = [0 for _ in range(len(primes))]\nfor i in range(1, N+1):\n    for j in range(len(primes)):\n        divsum[j] += divs[i-1] [j]\n\n\ndef num(n):\n    return len(list(filter(lambda x: x >= n-1, divsum)))\n\n\nans = 0\n\n\nans += num(75)\n\n\nans += num(15)*(num(5)-1)\n\n\nans += num(25)*(num(3)-1)\n\n\nans += num(5) * (num(5)-1) * (num(3)-2) // 2\nprint(int(ans))\n", "token_boundary_changed": true}
{"id": "Python/166", "code": "import math\n\nN = input()\nXS = [int(i) for i in input().split()]\n\nm = 9999999999\nfor i in range(1, 101):\n    c = sum([(x - i) ** 2 for x in XS])\n    if m > c:\n        m = c\n\nprint(m)\n", "test_IO": {"input": ["2\n1 4\n"], "output": ["5\n"]}, "modified_context": "import math\n\nN = input()\nXS = [int(i) for i in input().split()]\n\nm = 9999999999\nfor i in range(1, 101):\n    c = sum( [(x - i) ** 2 for x in XS])\n    if m > c:\n        m = c\n\nprint(m)\n", "token_boundary_changed": true}
{"id": "Python/169", "code": "d, g = list(map(int, input().split()))\npc = [list(map(int, input().split())) for _ in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use-1][0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\nprint(ans)\n", "test_IO": {"input": ["2 700\n3 500\n5 800\n"], "output": ["3\n"]}, "modified_context": "d, g = list(map(int, input().split()))\npc = [list(map(int, input().split())) for _ in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i] [0] * (i + 1) * 100 + pc[i] [1]\n            count += pc[i] [0]\n            nokori.discard(i + 1)\n\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use-1] [0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/175", "code": "import numpy\nn = int(input())\na = []\nfor i in range(2):\n    a.append(list(map(int, input().split())))\na[1] = a[1][::-1]\nres_0 = numpy.cumsum(a[0])\nres_1 = numpy.cumsum(a[1])\nans = 0\nfor i in range(n):\n    check = res_0[i] + res_1[n-1-i]\n    ans = max(ans, check)\nprint(ans)\n", "test_IO": {"input": ["5\n3 2 2 4 1\n1 2 2 2 1\n"], "output": ["14\n"]}, "modified_context": "import numpy\nn = int(input())\na = []\nfor i in range(2):\n    a.append(list(map(int, input().split())))\na[1] = a[1] [::-1]\nres_0 = numpy.cumsum(a[0])\nres_1 = numpy.cumsum(a[1])\nans = 0\nfor i in range(n):\n    check = res_0[i] + res_1[n-1-i]\n    ans = max(ans, check)\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/178", "code": "N, T = map(int, input().split())\nL = [[int(l) for l in input().split()] for _ in range(N)]\n\ndp = [[0]*T for _ in range(N+1)]\n\nfor i in range(N):\n    for j in range(T):\n        if j < L[i][0]:\n            dp[i+1][j] = dp[i][j]\n        else:\n            dp[i+1][j] = max(dp[i][j], dp[i][j-L[i][0]]+L[i][1])\n\nused = []\nB = dp[N][T-1]\nj = T-1\nfor i in range(N-1, -1, -1):\n    if B == dp[i][j]:\n        continue\n    B -= L[i][1]\n    used.append(i)\n    j -= L[i][0]\n\nans = dp[N][T-1]\nc = 0\nfor i in range(N):\n    if i in used:\n        continue\n    c = max(c, L[i][1])\n\nprint(ans+c)\n", "test_IO": {"input": ["2 60\n10 10\n100 100\n"], "output": ["110\n"]}, "modified_context": "N, T = map(int, input().split())\nL = [ [int(l) for l in input().split()] for _ in range(N)]\n\ndp = [ [0]*T for _ in range(N+1)]\n\nfor i in range(N):\n    for j in range(T):\n        if j < L[i] [0]:\n            dp[i+1] [j] = dp[i] [j]\n        else:\n            dp[i+1] [j] = max(dp[i] [j], dp[i] [j-L[i] [0]]+L[i] [1])\n\nused = []\nB = dp[N] [T-1]\nj = T-1\nfor i in range(N-1, -1, -1):\n    if B == dp[i] [j]:\n        continue\n    B -= L[i] [1]\n    used.append(i)\n    j -= L[i] [0]\n\nans = dp[N] [T-1]\nc = 0\nfor i in range(N):\n    if i in used:\n        continue\n    c = max(c, L[i] [1])\n\nprint(ans+c)\n", "token_boundary_changed": true}
{"id": "Python/186", "code": "N = int(input())\nA = [int(x) for x in input().split()]\nans = abs(A[-1])\nA = [0]+A+[0]\ndiff = [0 for x in range(N)]\nfor i in range(1, N+1):\n    dif = abs(A[i]-A[i-1])+abs(A[i]-A[i+1])-abs(A[i-1]-A[i+1])\n    ans += abs(A[i]-A[i-1])\n    diff[i-1] = dif\n\nfor i in range(N):\n    print(ans-diff[i])\n", "test_IO": {"input": ["3\n3 5 -1\n"], "output": ["12\n8\n10\n"]}, "modified_context": "N = int(input())\nA = [int(x) for x in input().split()]\nans = abs(A[-1])\nA = [0]+A+ [0]\ndiff = [0 for x in range(N)]\nfor i in range(1, N+1):\n    dif = abs(A[i]-A[i-1])+abs(A[i]-A[i+1])-abs(A[i-1]-A[i+1])\n    ans += abs(A[i]-A[i-1])\n    diff[i-1] = dif\n\nfor i in range(N):\n    print(ans-diff[i])\n", "token_boundary_changed": true}
{"id": "Python/190", "code": "h, w = map(int, input().split())\nl = []\nfor _ in range(h):\n    a = list(map(str, input()))\n    l.append(a)\n\ntmp = 0\n\nfor i in range(h):\n    for j in range(w):\n        if l[i][j] == \"#\":\n            if j < tmp:\n                print(\"Impossible\")\n                exit()\n            else:\n                tmp = j\n\n\nprint(\"Possible\")\n", "test_IO": {"input": ["4 5\n##...\n.##..\n..##.\n...##\n"], "output": ["Possible\n"]}, "modified_context": "h, w = map(int, input().split())\nl = []\nfor _ in range(h):\n    a = list(map(str, input()))\n    l.append(a)\n\ntmp = 0\n\nfor i in range(h):\n    for j in range(w):\n        if l[i] [j] == \"#\":\n            if j < tmp:\n                print(\"Impossible\")\n                exit()\n            else:\n                tmp = j\n\n\nprint(\"Possible\")\n", "token_boundary_changed": true}
{"id": "Python/192", "code": "def solver():\n    N = int(input())\n    action = []\n    for i in range(N):\n        action.append(list(map(int, input().split())))\n\n    dp = [[0 for _ in range(3)] for _ in range(N)]\n\n    for i in range(3):\n        dp[0][i] = action[0][i]\n\n    for i in range(1, N):\n        dp[i][0] = max(dp[i-1][1] + action[i][0], dp[i-1][2] + action[i][0])\n        dp[i][1] = max(dp[i-1][0] + action[i][1], dp[i-1][2] + action[i][1])\n        dp[i][2] = max(dp[i-1][0] + action[i][2], dp[i-1][1] + action[i][2])\n    print(max(dp[N-1]))\n\n\nsolver()\n", "test_IO": {"input": ["3\n10 40 70\n20 50 80\n30 60 90\n"], "output": ["210\n"]}, "modified_context": "def solver():\n    N = int(input())\n    action = []\n    for i in range(N):\n        action.append(list(map(int, input().split())))\n\n    dp = [ [0 for _ in range(3)] for _ in range(N)]\n\n    for i in range(3):\n        dp[0] [i] = action[0] [i]\n\n    for i in range(1, N):\n        dp[i] [0] = max(dp[i-1] [1] + action[i] [0], dp[i-1] [2] + action[i] [0])\n        dp[i] [1] = max(dp[i-1] [0] + action[i] [1], dp[i-1] [2] + action[i] [1])\n        dp[i] [2] = max(dp[i-1] [0] + action[i] [2], dp[i-1] [1] + action[i] [2])\n    print(max(dp[N-1]))\n\n\nsolver()\n", "token_boundary_changed": true}
{"id": "Python/193", "code": "n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nope = [list(map(int, input().split())) for _ in range(m)]\nope = sorted(ope, key=lambda x: x[1], reverse=True)\nj = 0\nfor i in range(n):\n    if a[i] < ope[j][1]:\n        a[i] = ope[j][1]\n        ope[j][0] -= 1\n        if ope[j][0] == 0:\n            j += 1\n            if j == len(ope):\n                break\n    else:\n        break\nprint(sum(a))\n", "test_IO": {"input": ["3 2\n5 1 4\n2 3\n1 5\n"], "output": ["14\n"]}, "modified_context": "n, m = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\nope = [list(map(int, input().split())) for _ in range(m)]\nope = sorted(ope, key=lambda x: x[1], reverse=True)\nj = 0\nfor i in range(n):\n    if a[i] < ope[j] [1]:\n        a[i] = ope[j] [1]\n        ope[j] [0] -= 1\n        if ope[j] [0] == 0:\n            j += 1\n            if j == len(ope):\n                break\n    else:\n        break\nprint(sum(a))\n", "token_boundary_changed": true}
