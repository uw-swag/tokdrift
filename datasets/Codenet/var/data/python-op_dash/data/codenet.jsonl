{"id": "Python/7", "code": "N, M = map(int, input().split())\n*A, = map(int, input().split())\nA = sorted(A)\n\nwhile M:\n    A[-1] //= 2\n    M -= 1\n    i = -2\n    while M and (-N <= i and A[i] >= A[-1]):\n        A[i] //= 2\n        M -= 1\n        i -= 1\n    A.sort()\n\nprint(sum(A))\n", "test_IO": {"input": ["3 3\n2 13 8\n"], "output": ["9\n"]}, "modified_context": "N, M = map(int, input().split())\n*A, = map(int, input().split())\nA = sorted(A)\n\nwhile M:\n    A[ -1] //= 2\n    M -= 1\n    i = -2\n    while M and ( -N <= i and A[i] >= A[ -1]):\n        A[i] //= 2\n        M -= 1\n        i -= 1\n    A.sort()\n\nprint(sum(A))\n", "token_boundary_changed": true}
{"id": "Python/10", "code": "s = input()\nif len(s) < 26:\n    for i in range(26):\n        c = chr(ord(\"a\")+i)\n        if c not in s:\n            print(s+c)\n            exit()\nelse:\n    for i in reversed(range(1, 26)):\n        if s[i-1] < s[i]:\n            s1 = s[0:i-1]\n            for j in range(26):\n                c = chr(ord(\"a\")+j)\n                if c > s[i-1] and c not in s1:\n                    print(s1+c)\n                    exit()\n    print(-1)\n", "test_IO": {"input": ["atcoder\n"], "output": ["atcoderb\n"]}, "modified_context": "s = input()\nif len(s) < 26:\n    for i in range(26):\n        c = chr(ord(\"a\")+i)\n        if c not in s:\n            print(s+c)\n            exit()\nelse:\n    for i in reversed(range(1, 26)):\n        if s[i-1] < s[i]:\n            s1 = s[0:i-1]\n            for j in range(26):\n                c = chr(ord(\"a\")+j)\n                if c > s[i-1] and c not in s1:\n                    print(s1+c)\n                    exit()\n    print( -1)\n", "token_boundary_changed": true}
{"id": "Python/19", "code": "n = int(input())\na = list(map(int, input().split()))\n\nm1 = int(sum([a[i] * ((-1)**i) for i in range(n)]) / 2)\n\nresult = str(m1)\n\nm = [None] * n\nm[0] = m1\nfor i in range(1, n):\n    m[i] = a[i-1] - m[i-1]\n\nprint(' '.join([str(x*2) for x in m]))\n", "test_IO": {"input": ["3\n2 2 4\n"], "output": ["4 0 4\n"]}, "modified_context": "n = int(input())\na = list(map(int, input().split()))\n\nm1 = int(sum([a[i] * (( -1)**i) for i in range(n)]) / 2)\n\nresult = str(m1)\n\nm = [None] * n\nm[0] = m1\nfor i in range(1, n):\n    m[i] = a[i-1] - m[i-1]\n\nprint(' '.join([str(x*2) for x in m]))\n", "token_boundary_changed": false}
{"id": "Python/26", "code": "strn = input()\nn = int(strn)\nshichigolist = [\"3\", \"5\", \"7\"]\nshichigo = [[] for _ in range(len(strn))]\nfor i in range(len(strn)):\n    if i == 0:\n        for j in shichigolist:\n            shichigo[i].append(j)\n    else:\n        for j in shichigo[i-1]:\n            for k in shichigolist:\n                shichigo[i].append(j+k)\ntarget = len(strn)-1\nfor i in range(len(strn)):\n    for j in shichigo[i][:]:\n        if i == target:\n            if int(j) > n:\n                shichigo[target].remove(j)\n            elif j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[target].remove(j)\n        else:\n            if j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[i].remove(j)\n\nprint(sum([len(shichigo[i]) for i in range(len(strn))]))\n", "test_IO": {"input": ["575\n"], "output": ["4\n"]}, "modified_context": "strn = input()\nn = int(strn)\nshichigolist = [\"3\", \"5\", \"7\"]\nshichigo = [[] for _ in range(len(strn))]\nfor i in range(len(strn)):\n    if i == 0:\n        for j in shichigolist:\n            shichigo[i].append(j)\n    else:\n        for j in shichigo[i-1]:\n            for k in shichigolist:\n                shichigo[i].append(j+k)\ntarget = len(strn) -1\nfor i in range(len(strn)):\n    for j in shichigo[i][:]:\n        if i == target:\n            if int(j) > n:\n                shichigo[target].remove(j)\n            elif j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[target].remove(j)\n        else:\n            if j.count(\"3\") == 0 or j.count(\"5\") == 0 or j.count(\"7\") == 0:\n                shichigo[i].remove(j)\n\nprint(sum([len(shichigo[i]) for i in range(len(strn))]))\n", "token_boundary_changed": true}
{"id": "Python/34", "code": "import math\nN, D = map(int, input().split())\nmat = []\nfor d in range(N):\n    mat.append([int(x) for x in input().split()])\n\nc = 0\nfor i in range(len(mat)-1):\n    for j in range(i+1, len(mat)):\n        dist = math.sqrt(sum([(x-y)**2 for x, y in zip(mat[i], mat[j])]))\n        if int(dist) == dist:\n            c += 1\nprint(c)\n", "test_IO": {"input": ["3 2\n1 2\n5 5\n-2 8\n"], "output": ["1\n"]}, "modified_context": "import math\nN, D = map(int, input().split())\nmat = []\nfor d in range(N):\n    mat.append([int(x) for x in input().split()])\n\nc = 0\nfor i in range(len(mat) -1):\n    for j in range(i+1, len(mat)):\n        dist = math.sqrt(sum([(x-y)**2 for x, y in zip(mat[i], mat[j])]))\n        if int(dist) == dist:\n            c += 1\nprint(c)\n", "token_boundary_changed": true}
{"id": "Python/40", "code": "s = input()\nq = int(input())\nqs = [input().split() for i in range(q)]\nn = False\nleft = right = \"\"\nfor operation in qs:\n    if operation[0] == '1':\n        n = not n\n    if operation[0] == '2':\n        t, f, c = operation\n        f = int(f)\n        if n:\n            f = 1 if f != 1 else 2\n        if f == 1:\n            left = c+left\n        elif f == 2:\n            right += c\ns = left+s+right\nprint(s[::-1] if n else s)\n", "test_IO": {"input": ["a\n4\n2 1 p\n1\n2 2 c\n1\n"], "output": ["cpa\n"]}, "modified_context": "s = input()\nq = int(input())\nqs = [input().split() for i in range(q)]\nn = False\nleft = right = \"\"\nfor operation in qs:\n    if operation[0] == '1':\n        n = not n\n    if operation[0] == '2':\n        t, f, c = operation\n        f = int(f)\n        if n:\n            f = 1 if f != 1 else 2\n        if f == 1:\n            left = c+left\n        elif f == 2:\n            right += c\ns = left+s+right\nprint(s[:: -1] if n else s)\n", "token_boundary_changed": true}
{"id": "Python/43", "code": "N = int(input())\nA = list(map(int, input().split()))\n\n\ndef main():\n    A.sort()\n    ans = A[-1] - A[0]\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "test_IO": {"input": ["4\n1 4 6 3\n"], "output": ["5\n"]}, "modified_context": "N = int(input())\nA = list(map(int, input().split()))\n\n\ndef main():\n    A.sort()\n    ans = A[ -1] - A[0]\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "token_boundary_changed": true}
{"id": "Python/44", "code": "import sys\nimport math\n\nfrom collections import defaultdict\nfrom collections import deque\n\n\ndef load(vtype=int):\n    return vtype(input().strip())\n\n\ndef load_list(seplator=\" \", vtype=int):\n    return [vtype(v) for v in input().strip().split(seplator)]\n\n\ndef exit():\n    import sys\n    sys.exit(0)\n\n\ndef perm_sub(li, used):\n    if len(li) == len(used):\n        return [deque()]\n    k = []\n    for i in range(len(li)):\n        if i in used:\n            continue\n        used.add(i)\n        sub_list = perm_sub(li, used)\n        for sub in sub_list:\n            sub.appendleft(li[i])\n        k.extend(sub_list)\n        used.discard(i)\n    return k\n\n\ndef perm_li(li):\n    return perm_sub(li, set())\n\n\ndef perm_n(n):\n    return perm_sub(list(range(n)), set())\n\n\ndef join_i(li, sep=\"\"):\n    return sep.join([str(e) for e in li])\n\n\ndef li2n(li):\n    n, base = 0, 1\n    for i in range(len(li)-1, -1, -1):\n        n += li[i] * base\n        base *= 10\n    return n\n\n\ndef sli2ili(li):\n    return [int(s) for s in li]\n\n\ndef prime_list(n):\n    li = [i for i in range(2, n+1)]\n    for i in range(len(li)):\n        if li[i] >= int(math.sqrt(n)):\n            break\n        if li[i] == -1:\n            continue\n        for j in range(i+1, len(li)):\n            if li[j] % li[i] == 0:\n                li[j] = -1\n    return [n for n in li if n != -1]\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while True:\n        r = a % b\n        if r == 0:\n            return b\n        a, b = b, r\n\n\ndef lcm(a, b):\n    return int(a * b / gcd(a, b))\n\n\ndef all_subset(li):\n    s = []\n    n = len(li)\n    for bit in range(0, (1 << (n+1))):\n        ss = set()\n        for i in range(0, n):\n            if (bit & (1 << i)):\n                ss.add(li[i])\n        s.append(ss)\n    return s\n\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\n\n\ndef mCn(m, n):\n    def factorial_ntimes(m, n):\n        r = 1\n        while n:\n            r *= m\n            m -= 1\n            n -= 1\n        return r\n    return int(factorial_ntimes(m, n) / factorial(n))\n\n\nn = load()\nA = load_list()\n\nif n == len(set(A)):\n    print('YES')\nelse:\n    print('NO')\n", "test_IO": {"input": ["5\n2 6 1 4 5\n"], "output": ["YES\n"]}, "modified_context": "import sys\nimport math\n\nfrom collections import defaultdict\nfrom collections import deque\n\n\ndef load(vtype=int):\n    return vtype(input().strip())\n\n\ndef load_list(seplator=\" \", vtype=int):\n    return [vtype(v) for v in input().strip().split(seplator)]\n\n\ndef exit():\n    import sys\n    sys.exit(0)\n\n\ndef perm_sub(li, used):\n    if len(li) == len(used):\n        return [deque()]\n    k = []\n    for i in range(len(li)):\n        if i in used:\n            continue\n        used.add(i)\n        sub_list = perm_sub(li, used)\n        for sub in sub_list:\n            sub.appendleft(li[i])\n        k.extend(sub_list)\n        used.discard(i)\n    return k\n\n\ndef perm_li(li):\n    return perm_sub(li, set())\n\n\ndef perm_n(n):\n    return perm_sub(list(range(n)), set())\n\n\ndef join_i(li, sep=\"\"):\n    return sep.join([str(e) for e in li])\n\n\ndef li2n(li):\n    n, base = 0, 1\n    for i in range(len(li) -1, -1, -1):\n        n += li[i] * base\n        base *= 10\n    return n\n\n\ndef sli2ili(li):\n    return [int(s) for s in li]\n\n\ndef prime_list(n):\n    li = [i for i in range(2, n+1)]\n    for i in range(len(li)):\n        if li[i] >= int(math.sqrt(n)):\n            break\n        if li[i] == -1:\n            continue\n        for j in range(i+1, len(li)):\n            if li[j] % li[i] == 0:\n                li[j] = -1\n    return [n for n in li if n != -1]\n\n\ndef gcd(a, b):\n    a, b = max(a, b), min(a, b)\n    while True:\n        r = a % b\n        if r == 0:\n            return b\n        a, b = b, r\n\n\ndef lcm(a, b):\n    return int(a * b / gcd(a, b))\n\n\ndef all_subset(li):\n    s = []\n    n = len(li)\n    for bit in range(0, (1 << (n+1))):\n        ss = set()\n        for i in range(0, n):\n            if (bit & (1 << i)):\n                ss.add(li[i])\n        s.append(ss)\n    return s\n\n\ndef factorial(n):\n    if n == 1:\n        return 1\n    return n * factorial(n-1)\n\n\ndef mCn(m, n):\n    def factorial_ntimes(m, n):\n        r = 1\n        while n:\n            r *= m\n            m -= 1\n            n -= 1\n        return r\n    return int(factorial_ntimes(m, n) / factorial(n))\n\n\nn = load()\nA = load_list()\n\nif n == len(set(A)):\n    print('YES')\nelse:\n    print('NO')\n", "token_boundary_changed": true}
{"id": "Python/53", "code": "print('Christmas'+' Eve'*abs(int(input())-25))\n", "test_IO": {"input": ["25\n"], "output": ["Christmas\n"]}, "modified_context": "print('Christmas'+' Eve'*abs(int(input()) -25))\n", "token_boundary_changed": false}
{"id": "Python/55", "code": "from sys import stdin\ndef il(func=int): return list(map(func, stdin.readline().rstrip().split()))\n\n\nils = lambda n, s=\"int(input())\": [eval(s) for _ in range(n)]\n\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn, m = il()\ns = input()\nt = input()\naa = gcd(n, m)\nbb = lcm(n, m)\ncc = aa // bb\nfor i in range(aa):\n    if s[n//aa*i] != t[m//aa*i]:\n        print(-1)\n        exit()\nprint(bb)\n", "test_IO": {"input": ["3 2\nacp\nae\n"], "output": ["6\n"]}, "modified_context": "from sys import stdin\ndef il(func=int): return list(map(func, stdin.readline().rstrip().split()))\n\n\nils = lambda n, s=\"int(input())\": [eval(s) for _ in range(n)]\n\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\n\nn, m = il()\ns = input()\nt = input()\naa = gcd(n, m)\nbb = lcm(n, m)\ncc = aa // bb\nfor i in range(aa):\n    if s[n//aa*i] != t[m//aa*i]:\n        print( -1)\n        exit()\nprint(bb)\n", "token_boundary_changed": true}
{"id": "Python/62", "code": "import sys\ninput = sys.stdin.buffer.readline\n\n\ndef main():\n\n    class SegmentTree:\n\n        def __init__(self, size, default):\n            self.size = 2**(size-1).bit_length()\n            self.default = default\n            self.seg = [default]*(2*self.size-1)\n\n        def segfunc(self, x, y):\n            return max(x, y)\n\n        def update(self, k, x):\n            k += self.size-1\n            self.seg[k] = x\n            while k:\n                k = (k-1)//2\n                self.seg[k] = self.segfunc(self.seg[2*k+1], self.seg[2*k+2])\n\n        def query(self, p, q):\n            if q <= p:\n                return self.default\n            p += self.size-1\n            q += self.size-2\n            ret = self.default\n            while q-p > 1:\n                if p & 1 == 0:\n                    ret = self.segfunc(ret, self.seg[p])\n                if q & 1 == 1:\n                    ret = self.segfunc(ret, self.seg[q])\n                    q -= 1\n                p = p//2\n                q = (q-1)//2\n            ret = self.segfunc(self.segfunc(ret, self.seg[p]), self.seg[q])\n            return ret\n\n        def seg_print(self):\n            print(self.seg)\n\n    N = int(input())\n    a = list(map(int, input().split()))\n    ans = [i+1 for i in range(N)]\n    left_seg = SegmentTree(N, 0)\n    for i, num in enumerate(a):\n        ans[num-1] *= i + 1 - left_seg.query(0, num)\n        left_seg.update(num-1, i+1)\n    right_seg = SegmentTree(N, 0)\n    for i, num in enumerate(a[::-1]):\n        ans[num-1] *= i + 1 - right_seg.query(0, num)\n        right_seg.update(num-1, i+1)\n\n    print(sum(ans))\n\n\nif __name__ == \"__main__\":\n    main()\n", "test_IO": {"input": ["3\n2 1 3\n"], "output": ["9\n"]}, "modified_context": "import sys\ninput = sys.stdin.buffer.readline\n\n\ndef main():\n\n    class SegmentTree:\n\n        def __init__(self, size, default):\n            self.size = 2**(size-1).bit_length()\n            self.default = default\n            self.seg = [default]*(2*self.size-1)\n\n        def segfunc(self, x, y):\n            return max(x, y)\n\n        def update(self, k, x):\n            k += self.size-1\n            self.seg[k] = x\n            while k:\n                k = (k-1)//2\n                self.seg[k] = self.segfunc(self.seg[2*k+1], self.seg[2*k+2])\n\n        def query(self, p, q):\n            if q <= p:\n                return self.default\n            p += self.size-1\n            q += self.size-2\n            ret = self.default\n            while q-p > 1:\n                if p & 1 == 0:\n                    ret = self.segfunc(ret, self.seg[p])\n                if q & 1 == 1:\n                    ret = self.segfunc(ret, self.seg[q])\n                    q -= 1\n                p = p//2\n                q = (q-1)//2\n            ret = self.segfunc(self.segfunc(ret, self.seg[p]), self.seg[q])\n            return ret\n\n        def seg_print(self):\n            print(self.seg)\n\n    N = int(input())\n    a = list(map(int, input().split()))\n    ans = [i+1 for i in range(N)]\n    left_seg = SegmentTree(N, 0)\n    for i, num in enumerate(a):\n        ans[num-1] *= i + 1 - left_seg.query(0, num)\n        left_seg.update(num-1, i+1)\n    right_seg = SegmentTree(N, 0)\n    for i, num in enumerate(a[:: -1]):\n        ans[num-1] *= i + 1 - right_seg.query(0, num)\n        right_seg.update(num-1, i+1)\n\n    print(sum(ans))\n\n\nif __name__ == \"__main__\":\n    main()\n", "token_boundary_changed": true}
{"id": "Python/65", "code": "n = int(input())\nS = list(map(int, input().split()))\nq = int(input())\nT = list(map(int, input().split()))\n\nans = 0\nfor i in T:\n    if i == S[-1] or i == S[0]:\n        ans += 1\n    else:\n        left = 0\n        right = n-1\n        while right-left > 1:\n            mid = (left+right)//2\n            if S[mid] == i:\n                ans += 1\n                break\n            elif S[mid] < i:\n                left = mid\n            else:\n                right = mid\n\nprint(ans)\n", "test_IO": {"input": ["5\n1 2 3 4 5\n3\n3 4 1\n"], "output": ["3\n"]}, "modified_context": "n = int(input())\nS = list(map(int, input().split()))\nq = int(input())\nT = list(map(int, input().split()))\n\nans = 0\nfor i in T:\n    if i == S[ -1] or i == S[0]:\n        ans += 1\n    else:\n        left = 0\n        right = n-1\n        while right-left > 1:\n            mid = (left+right)//2\n            if S[mid] == i:\n                ans += 1\n                break\n            elif S[mid] < i:\n                left = mid\n            else:\n                right = mid\n\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/72", "code": "import sys\nsys.setrecursionlimit(10**7)\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline().strip()\n\n\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    N = II()\n    a_li = LI()\n\n    a_li.sort()\n\n    n = a_li[-1]\n\n    dif = INF\n    prev_dif = dif\n    for a in a_li[:-1]:\n        dif = min(abs(n/2 - a), dif)\n        if dif != prev_dif:\n            r = a\n            prev_dif = dif\n\n    print(n, r)\n\n\nmain()\n", "test_IO": {"input": ["5\n6 9 4 2 11\n"], "output": ["11 6\n"]}, "modified_context": "import sys\nsys.setrecursionlimit(10**7)\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline().strip()\n\n\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\ndef main():\n    N = II()\n    a_li = LI()\n\n    a_li.sort()\n\n    n = a_li[ -1]\n\n    dif = INF\n    prev_dif = dif\n    for a in a_li[: -1]:\n        dif = min(abs(n/2 - a), dif)\n        if dif != prev_dif:\n            r = a\n            prev_dif = dif\n\n    print(n, r)\n\n\nmain()\n", "token_boundary_changed": true}
{"id": "Python/78", "code": "import collections\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    ve = []\n    vo = []\n    for i in range(n//2):\n        ve.append(v[2*i])\n        vo.append(v[2*i+1])\n    ce = collections.Counter(ve)\n    co = collections.Counter(vo)\n    ans = n\n    if ce.most_common()[0][0] != co.most_common()[0][0]:\n        ans = n-ce.most_common()[0][1]-co.most_common()[0][1]\n    elif len(ce) == 1 and len(co) == 1:\n        ans = n-ce.most_common()[0][1]\n    elif len(ce) == 1:\n        ans = n-ce.most_common()[0][1]-co.most_common()[1][1]\n    elif len(co) == 1:\n        ans = n-ce.most_common()[1][1]-co.most_common()[0][1]\n    else:\n        ans = min(n-ce.most_common()[0][1]-co.most_common()[1]\n                  [1], n-ce.most_common()[1][1]-co.most_common()[0][1])\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "test_IO": {"input": ["4\n3 1 3 2\n"], "output": ["1\n"]}, "modified_context": "import collections\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    ve = []\n    vo = []\n    for i in range(n//2):\n        ve.append(v[2*i])\n        vo.append(v[2*i+1])\n    ce = collections.Counter(ve)\n    co = collections.Counter(vo)\n    ans = n\n    if ce.most_common()[0][0] != co.most_common()[0][0]:\n        ans = n-ce.most_common()[0][1] -co.most_common()[0][1]\n    elif len(ce) == 1 and len(co) == 1:\n        ans = n-ce.most_common()[0][1]\n    elif len(ce) == 1:\n        ans = n-ce.most_common()[0][1] -co.most_common()[1][1]\n    elif len(co) == 1:\n        ans = n-ce.most_common()[1][1] -co.most_common()[0][1]\n    else:\n        ans = min(n-ce.most_common()[0][1] -co.most_common()[1]\n                  [1], n-ce.most_common()[1][1] -co.most_common()[0][1])\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "token_boundary_changed": true}
{"id": "Python/93", "code": "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef input_nums(): return list(map(int, input().split()))\n\n\ndef main():\n    K, N = input_nums()\n    A = input_nums()\n    dist = []\n    for i in range(len(A)-1):\n        dist.append(A[i+1]-A[i])\n    dist.append(K+A[0]-A[-1])\n    maxv = max(dist)\n    print(sum(dist) - maxv)\n\n\nif __name__ == '__main__':\n    main()\n", "test_IO": {"input": ["20 3\n5 10 15\n"], "output": ["10\n"]}, "modified_context": "import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef input_nums(): return list(map(int, input().split()))\n\n\ndef main():\n    K, N = input_nums()\n    A = input_nums()\n    dist = []\n    for i in range(len(A) -1):\n        dist.append(A[i+1] -A[i])\n    dist.append(K+A[0] -A[ -1])\n    maxv = max(dist)\n    print(sum(dist) - maxv)\n\n\nif __name__ == '__main__':\n    main()\n", "token_boundary_changed": true}
{"id": "Python/98", "code": "a = [int(input()) for i in range(5)]\n\ndic = {}\n\nfor i in range(5):\n    if str(a[i])[-1] == \"0\":\n        dic.update({i: 0})\n    else:\n        dic.update({i: int(str(a[i])[-1]) - 10})\n\n\nmin_num = [i for i in dic if dic[i] == min(dic.values())][0]\na_sum = sum(a)\ndic.pop(min_num)\nprint(abs(sum(dic.values())) + a_sum)\n", "test_IO": {"input": ["29\n20\n7\n35\n120\n"], "output": ["215\n"]}, "modified_context": "a = [int(input()) for i in range(5)]\n\ndic = {}\n\nfor i in range(5):\n    if str(a[i])[ -1] == \"0\":\n        dic.update({i: 0})\n    else:\n        dic.update({i: int(str(a[i])[ -1]) - 10})\n\n\nmin_num = [i for i in dic if dic[i] == min(dic.values())][0]\na_sum = sum(a)\ndic.pop(min_num)\nprint(abs(sum(dic.values())) + a_sum)\n", "token_boundary_changed": true}
{"id": "Python/107", "code": "from collections import deque\nn = int(input())\na = list(map(str, input().split()))\nb = []\n\nb = a[1::2][::-1]+a[::2]\nif len(a) % 2 == 0:\n    print(' '.join(b))\nelse:\n    print(' '.join(b[::-1]))\n", "test_IO": {"input": ["4\n1 2 3 4\n"], "output": ["4 2 1 3\n"]}, "modified_context": "from collections import deque\nn = int(input())\na = list(map(str, input().split()))\nb = []\n\nb = a[1::2][:: -1]+a[::2]\nif len(a) % 2 == 0:\n    print(' '.join(b))\nelse:\n    print(' '.join(b[:: -1]))\n", "token_boundary_changed": true}
{"id": "Python/110", "code": "s = input()\n\nif len(s) == 2:\n    print(s)\nelse:\n    print(s[::-1])\n", "test_IO": {"input": ["abc\n"], "output": ["cba\n"]}, "modified_context": "s = input()\n\nif len(s) == 2:\n    print(s)\nelse:\n    print(s[:: -1])\n", "token_boundary_changed": true}
{"id": "Python/115", "code": "def main():\n\n    N, M, Q = map(int, input().split())\n    train = [[0 for _ in range(N)] for _ in range(N)]\n    for _ in range(M):\n        l, r = map(int, input().split())\n        train[l-1][r-1] += 1\n\n    accum = [[0 for _ in range(N+1)]]\n    for i in range(N):\n        temp = [0]\n        v = 0\n        for j in range(N):\n            v += train[i][j]\n            temp.append(accum[-1][j+1]+v)\n        accum.append(temp)\n\n    for _ in range(Q):\n        p, q = map(int, input().split())\n        v = accum[q][q] - accum[p-1][q] - accum[q][p-1] + accum[p-1][p-1]\n        print(v)\n\n\nif __name__ == '__main__':\n    main()\n", "test_IO": {"input": ["2 3 1\n1 1\n1 2\n2 2\n1 2\n"], "output": ["3\n"]}, "modified_context": "def main():\n\n    N, M, Q = map(int, input().split())\n    train = [[0 for _ in range(N)] for _ in range(N)]\n    for _ in range(M):\n        l, r = map(int, input().split())\n        train[l-1][r-1] += 1\n\n    accum = [[0 for _ in range(N+1)]]\n    for i in range(N):\n        temp = [0]\n        v = 0\n        for j in range(N):\n            v += train[i][j]\n            temp.append(accum[ -1][j+1]+v)\n        accum.append(temp)\n\n    for _ in range(Q):\n        p, q = map(int, input().split())\n        v = accum[q][q] - accum[p-1][q] - accum[q][p-1] + accum[p-1][p-1]\n        print(v)\n\n\nif __name__ == '__main__':\n    main()\n", "token_boundary_changed": true}
{"id": "Python/119", "code": "import re\nimport math\nfrom collections import defaultdict\nimport itertools\nfrom copy import deepcopy\nimport random\nfrom heapq import heappop, heappush\nimport time\nimport os\nimport queue\nimport sys\nimport datetime\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\nsys.setrecursionlimit(2000000)\n\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\nmod = int(10**9+7)\ninf = int(10**20)\n\n\ndef yn(b):\n    if b:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\n\ndef Yn(b):\n    if b:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef YN(b):\n    if b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nclass union_find():\n    def __init__(self, n):\n        self.n = n\n        self.P = [a for a in range(N)]\n        self.rank = [0]*n\n\n    def find(self, x):\n        if (x != self.P[x]):\n            self.P[x] = self.find(self.P[x])\n        return self.P[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def link(self, x, y):\n        if self.rank[x] < self.rank[y]:\n            self.P[x] = y\n        elif self.rank[y] < self.rank[x]:\n            self.P[y] = x\n        else:\n            self.P[x] = y\n            self.rank[y] += 1\n\n    def unite(self, x, y):\n        self.link(self.find(x), self.find(y))\n\n    def size(self):\n        S = set()\n        for a in range(self.n):\n            S.add(self.find(a))\n        return len(S)\n\n\ndef is_power(a, b):\n    now = b\n    while now < a:\n        now *= b\n    if now == a:\n        return True\n    else:\n        return False\n\n\ndef bin_(num, size):\n    A = [0]*size\n    for a in range(size):\n        if (num >> (size-a-1)) & 1 == 1:\n            A[a] = 1\n        else:\n            A[a] = 0\n    return A\n\n\ndef get_facs(n, mod_=0):\n    A = [1]*(n+1)\n    for a in range(2, len(A)):\n        A[a] = A[a-1]*a\n        if (mod > 0):\n            A[a] %= mod_\n    return A\n\n\ndef comb(n, r, mod, fac):\n    if (n-r < 0):\n        return 0\n    return (fac[n]*pow(fac[n-r], mod-2, mod)*pow(fac[r], mod-2, mod)) % mod\n\n\ndef next_comb(num, size):\n    x = num & (-num)\n    y = num+x\n    z = num & (~y)\n    z //= x\n    z = z >> 1\n    num = (y | z)\n    if (num >= (1 << size)):\n        return False\n    else:\n        return num\n\n\ndef get_primes(n, type=\"int\"):\n    A = [True]*(n+1)\n    A[0] = False\n    A[1] = False\n    for a in range(2, n+1):\n        if A[a]:\n            for b in range(a*2, n+1, a):\n                A[b] = False\n    if (type == \"bool\"):\n        return A\n    B = []\n    for a in range(n+1):\n        if (A[a]):\n            B.append(a)\n    return B\n\n\ndef is_prime(num):\n    if (num <= 2):\n        return False\n    i = 2\n    while i*i <= num:\n        if (num % i == 0):\n            return False\n        i += 1\n    return True\n\n\ndef ifelse(a, b, c):\n    if a:\n        return b\n    else:\n        return c\n\n\ndef join(A, c=\" \"):\n    n = len(A)\n    A = list(map(str, A))\n    s = \"\"\n    for a in range(n):\n        s += A[a]\n        if (a < n-1):\n            s += c\n    return s\n\n\ndef factorize(n, type_=\"dict\"):\n    b = 2\n    list_ = []\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            list_.append(b)\n        b += 1\n    if n > 1:\n        list_.append(n)\n    if type_ == \"dict\":\n        dic = {}\n        for a in list_:\n            if a in dic:\n                dic[a] += 1\n            else:\n                dic[a] = 1\n        return dic\n    elif type_ == \"list\":\n        return list_\n    else:\n        return None\n\n\ndef floor_(n, x=1):\n    return x*(n//x)\n\n\ndef ceil_(n, x=1):\n    return x*((n+x-1)//x)\n\n\ndef hani(x, min_, max_):\n    ret = x\n    if x < min_:\n        ret = min_\n    if x > max_:\n        ret = max_\n    return ret\n\n\ndef seifu(x):\n    return x//abs(x)\n\n\ndef main():\n    n, l = map(int, input().split())\n    S = []\n    for a in range(n):\n        S.append(input())\n    S.sort()\n    print(\"\".join(S))\n\n\nmain()\n", "test_IO": {"input": ["3 3\ndxx\naxx\ncxx\n"], "output": ["axxcxxdxx\n"]}, "modified_context": "import re\nimport math\nfrom collections import defaultdict\nimport itertools\nfrom copy import deepcopy\nimport random\nfrom heapq import heappop, heappush\nimport time\nimport os\nimport queue\nimport sys\nimport datetime\nfrom functools import lru_cache\n\nreadline = sys.stdin.readline\nsys.setrecursionlimit(2000000)\n\nalphabet = \"abcdefghijklmnopqrstuvwxyz\"\nmod = int(10**9+7)\ninf = int(10**20)\n\n\ndef yn(b):\n    if b:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\n\ndef Yn(b):\n    if b:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\ndef YN(b):\n    if b:\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n\nclass union_find():\n    def __init__(self, n):\n        self.n = n\n        self.P = [a for a in range(N)]\n        self.rank = [0]*n\n\n    def find(self, x):\n        if (x != self.P[x]):\n            self.P[x] = self.find(self.P[x])\n        return self.P[x]\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n    def link(self, x, y):\n        if self.rank[x] < self.rank[y]:\n            self.P[x] = y\n        elif self.rank[y] < self.rank[x]:\n            self.P[y] = x\n        else:\n            self.P[x] = y\n            self.rank[y] += 1\n\n    def unite(self, x, y):\n        self.link(self.find(x), self.find(y))\n\n    def size(self):\n        S = set()\n        for a in range(self.n):\n            S.add(self.find(a))\n        return len(S)\n\n\ndef is_power(a, b):\n    now = b\n    while now < a:\n        now *= b\n    if now == a:\n        return True\n    else:\n        return False\n\n\ndef bin_(num, size):\n    A = [0]*size\n    for a in range(size):\n        if (num >> (size-a-1)) & 1 == 1:\n            A[a] = 1\n        else:\n            A[a] = 0\n    return A\n\n\ndef get_facs(n, mod_=0):\n    A = [1]*(n+1)\n    for a in range(2, len(A)):\n        A[a] = A[a-1]*a\n        if (mod > 0):\n            A[a] %= mod_\n    return A\n\n\ndef comb(n, r, mod, fac):\n    if (n-r < 0):\n        return 0\n    return (fac[n]*pow(fac[n-r], mod-2, mod)*pow(fac[r], mod-2, mod)) % mod\n\n\ndef next_comb(num, size):\n    x = num & ( -num)\n    y = num+x\n    z = num & (~y)\n    z //= x\n    z = z >> 1\n    num = (y | z)\n    if (num >= (1 << size)):\n        return False\n    else:\n        return num\n\n\ndef get_primes(n, type=\"int\"):\n    A = [True]*(n+1)\n    A[0] = False\n    A[1] = False\n    for a in range(2, n+1):\n        if A[a]:\n            for b in range(a*2, n+1, a):\n                A[b] = False\n    if (type == \"bool\"):\n        return A\n    B = []\n    for a in range(n+1):\n        if (A[a]):\n            B.append(a)\n    return B\n\n\ndef is_prime(num):\n    if (num <= 2):\n        return False\n    i = 2\n    while i*i <= num:\n        if (num % i == 0):\n            return False\n        i += 1\n    return True\n\n\ndef ifelse(a, b, c):\n    if a:\n        return b\n    else:\n        return c\n\n\ndef join(A, c=\" \"):\n    n = len(A)\n    A = list(map(str, A))\n    s = \"\"\n    for a in range(n):\n        s += A[a]\n        if (a < n-1):\n            s += c\n    return s\n\n\ndef factorize(n, type_=\"dict\"):\n    b = 2\n    list_ = []\n    while b * b <= n:\n        while n % b == 0:\n            n //= b\n            list_.append(b)\n        b += 1\n    if n > 1:\n        list_.append(n)\n    if type_ == \"dict\":\n        dic = {}\n        for a in list_:\n            if a in dic:\n                dic[a] += 1\n            else:\n                dic[a] = 1\n        return dic\n    elif type_ == \"list\":\n        return list_\n    else:\n        return None\n\n\ndef floor_(n, x=1):\n    return x*(n//x)\n\n\ndef ceil_(n, x=1):\n    return x*((n+x-1)//x)\n\n\ndef hani(x, min_, max_):\n    ret = x\n    if x < min_:\n        ret = min_\n    if x > max_:\n        ret = max_\n    return ret\n\n\ndef seifu(x):\n    return x//abs(x)\n\n\ndef main():\n    n, l = map(int, input().split())\n    S = []\n    for a in range(n):\n        S.append(input())\n    S.sort()\n    print(\"\".join(S))\n\n\nmain()\n", "token_boundary_changed": true}
{"id": "Python/127", "code": "from collections import deque\nH, W = map(int, input().split())\nG = []\nfor i in range(H+2):\n    if i == 0 or i == H+1:\n        G.append('#'*(W+2))\n    else:\n        G.append('#' + input() + '#')\n\nans = 0\nfor sx in range(W+2):\n    for sy in range(H+2):\n        if G[sy][sx] == '.':\n            dist = [[-float('inf') for i in range(W+2)] for i in range(H+2)]\n            visited = [[-1 for i in range(W+2)] for i in range(H+2)]\n            q = deque([])\n            q.append((sx, sy))\n            dist[sy][sx] = 0\n            visited[sy][sx] = 1\n            while q:\n                x, y = q.popleft()\n\n                if G[y][x+1] == '.' and visited[y][x+1] == -1:\n                    q.append((x+1, y))\n                    dist[y][x+1] = dist[y][x] + 1\n                    visited[y][x+1] = 1\n\n                if G[y][x-1] == '.' and visited[y][x-1] == -1:\n                    q.append((x-1, y))\n                    dist[y][x-1] = dist[y][x] + 1\n                    visited[y][x-1] = 1\n\n                if G[y+1][x] == '.' and visited[y+1][x] == -1:\n                    q.append((x, y+1))\n                    dist[y+1][x] = dist[y][x] + 1\n                    visited[y+1][x] = 1\n\n                if G[y-1][x] == '.' and visited[y-1][x] == -1:\n                    q.append((x, y-1))\n                    dist[y-1][x] = dist[y][x] + 1\n                    visited[y-1][x] = 1\n            for i in range(W+2):\n                for j in range(H+2):\n                    ans = max(ans, dist[j][i])\nprint(ans)\n", "test_IO": {"input": ["3 3\n...\n...\n...\n"], "output": ["4\n"]}, "modified_context": "from collections import deque\nH, W = map(int, input().split())\nG = []\nfor i in range(H+2):\n    if i == 0 or i == H+1:\n        G.append('#'*(W+2))\n    else:\n        G.append('#' + input() + '#')\n\nans = 0\nfor sx in range(W+2):\n    for sy in range(H+2):\n        if G[sy][sx] == '.':\n            dist = [[ -float('inf') for i in range(W+2)] for i in range(H+2)]\n            visited = [[ -1 for i in range(W+2)] for i in range(H+2)]\n            q = deque([])\n            q.append((sx, sy))\n            dist[sy][sx] = 0\n            visited[sy][sx] = 1\n            while q:\n                x, y = q.popleft()\n\n                if G[y][x+1] == '.' and visited[y][x+1] == -1:\n                    q.append((x+1, y))\n                    dist[y][x+1] = dist[y][x] + 1\n                    visited[y][x+1] = 1\n\n                if G[y][x-1] == '.' and visited[y][x-1] == -1:\n                    q.append((x-1, y))\n                    dist[y][x-1] = dist[y][x] + 1\n                    visited[y][x-1] = 1\n\n                if G[y+1][x] == '.' and visited[y+1][x] == -1:\n                    q.append((x, y+1))\n                    dist[y+1][x] = dist[y][x] + 1\n                    visited[y+1][x] = 1\n\n                if G[y-1][x] == '.' and visited[y-1][x] == -1:\n                    q.append((x, y-1))\n                    dist[y-1][x] = dist[y][x] + 1\n                    visited[y-1][x] = 1\n            for i in range(W+2):\n                for j in range(H+2):\n                    ans = max(ans, dist[j][i])\nprint(ans)\n", "token_boundary_changed": false}
{"id": "Python/128", "code": "s = input()\nt = input()\n\nif t[:-1] == s:\n    print('Yes')\nelse:\n    print('No')\n", "test_IO": {"input": ["chokudai\nchokudaiz\n"], "output": ["Yes\n"]}, "modified_context": "s = input()\nt = input()\n\nif t[: -1] == s:\n    print('Yes')\nelse:\n    print('No')\n", "token_boundary_changed": true}
{"id": "Python/130", "code": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\ns = sorted(readline().rstrip())\nt = sorted(readline().rstrip())[::-1]\nprint(\"Yes\" if s < t else \"No\")\n", "test_IO": {"input": ["yx\naxy\n"], "output": ["Yes\n"]}, "modified_context": "import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\ns = sorted(readline().rstrip())\nt = sorted(readline().rstrip())[:: -1]\nprint(\"Yes\" if s < t else \"No\")\n", "token_boundary_changed": true}
{"id": "Python/132", "code": "import sys\n\n\nfrom bisect import bisect_left, bisect_right\n\n\ninput = sys.stdin.readline\n\n\ndef getS(): return input().strip()\ndef getN(): return int(input())\ndef getList(): return list(map(int, input().split()))\ndef getZList(): return [int(x) - 1 for x in input().split()]\n\n\nINF = 10 ** 20\nMOD = 1000000007\n\n\ndef solve():\n    n = getN()\n    dp = [-INF]\n    for i in range(n):\n        num = getN()\n        num = -num\n        if num >= dp[-1]:\n            dp.append(num)\n        else:\n            idx = bisect_right(dp, num)\n            dp[idx] = num\n\n    print(len(dp) - 1)\n    return\n\n\ndef main():\n    n = getN()\n    for _ in range(n):\n        solve()\n\n\nif __name__ == \"__main__\":\n\n    solve()\n", "test_IO": {"input": ["5\n2\n1\n4\n5\n3\n"], "output": ["2\n"]}, "modified_context": "import sys\n\n\nfrom bisect import bisect_left, bisect_right\n\n\ninput = sys.stdin.readline\n\n\ndef getS(): return input().strip()\ndef getN(): return int(input())\ndef getList(): return list(map(int, input().split()))\ndef getZList(): return [int(x) - 1 for x in input().split()]\n\n\nINF = 10 ** 20\nMOD = 1000000007\n\n\ndef solve():\n    n = getN()\n    dp = [ -INF]\n    for i in range(n):\n        num = getN()\n        num = -num\n        if num >= dp[ -1]:\n            dp.append(num)\n        else:\n            idx = bisect_right(dp, num)\n            dp[idx] = num\n\n    print(len(dp) - 1)\n    return\n\n\ndef main():\n    n = getN()\n    for _ in range(n):\n        solve()\n\n\nif __name__ == \"__main__\":\n\n    solve()\n", "token_boundary_changed": true}
{"id": "Python/133", "code": "from collections import deque\nN, M = map(int, input().split())\nG = {i: [] for i in range(1, N+1)}\nfor _ in range(M):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\ncol = [-1 for _ in range(N+1)]\ncnt = 0\nfor i in range(1, N+1):\n    if col[i] < 0:\n        col[i] = cnt\n        que = deque([i])\n        while que:\n            x = que.popleft()\n            for y in G[x]:\n                if col[y] < 0:\n                    col[y] = cnt\n                    que.append(y)\n        cnt += 1\ncmax = max(col)\nprint(cmax)\n", "test_IO": {"input": ["3 1\n1 2\n"], "output": ["1\n"]}, "modified_context": "from collections import deque\nN, M = map(int, input().split())\nG = {i: [] for i in range(1, N+1)}\nfor _ in range(M):\n    a, b = map(int, input().split())\n    G[a].append(b)\n    G[b].append(a)\ncol = [ -1 for _ in range(N+1)]\ncnt = 0\nfor i in range(1, N+1):\n    if col[i] < 0:\n        col[i] = cnt\n        que = deque([i])\n        while que:\n            x = que.popleft()\n            for y in G[x]:\n                if col[y] < 0:\n                    col[y] = cnt\n                    que.append(y)\n        cnt += 1\ncmax = max(col)\nprint(cmax)\n", "token_boundary_changed": true}
{"id": "Python/138", "code": "n = input()\nn = int(n[-1])\n\nif n == 2 or n == 4 or n == 5 or n == 7 or n == 9:\n    print(\"hon\")\nelif n == 0 or n == 1 or n == 6 or n == 8:\n    print(\"pon\")\nelse:\n    print(\"bon\")\n", "test_IO": {"input": ["16\n"], "output": ["pon\n"]}, "modified_context": "n = input()\nn = int(n[ -1])\n\nif n == 2 or n == 4 or n == 5 or n == 7 or n == 9:\n    print(\"hon\")\nelif n == 0 or n == 1 or n == 6 or n == 8:\n    print(\"pon\")\nelse:\n    print(\"bon\")\n", "token_boundary_changed": true}
{"id": "Python/148", "code": "from heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, Counter\nimport itertools\nfrom itertools import permutations, combinations, accumulate\nimport sys\nimport bisect\nimport string\nimport math\nimport time\n\n\ndef I(): return int(input())\n\n\ndef MI(): return map(int, input().split())\n\n\ndef LI(): return [int(i) for i in input().split()]\n\n\ndef LI_(): return [int(i)-1 for i in input().split()]\n\n\ndef StoI(): return [ord(i)-97 for i in input()]\n\n\ndef ItoS(nn): return chr(nn+97)\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef show(*inp, end='\\n'):\n    if show_flg:\n        print(*inp, end=end)\n\n\nYN = ['No', 'Yes']\nMOD = 10**9+7\ninf = float('inf')\nIINF = 10**10\nl_alp = string.ascii_lowercase\nu_alp = string.ascii_uppercase\nts = time.time()\nsys.setrecursionlimit(10**6)\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n\nshow_flg = False\n\n\ndef main():\n    N = I()\n    s = [0] * N\n    t = [0] * N\n\n    for i in range(N):\n        s[i], t[i] = map(str, input().split())\n        t[i] = int(t[i])\n\n    X = input()\n    xi = 0\n\n    for i in range(N):\n        if s[i] == X:\n            xi = i\n            break\n\n    ans = 0\n\n    for i in range(N):\n        if xi < i:\n            ans += t[i]\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "test_IO": {"input": ["3\ndwango 2\nsixth 5\nprelims 25\ndwango\n"], "output": ["30\n"]}, "modified_context": "from heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, Counter\nimport itertools\nfrom itertools import permutations, combinations, accumulate\nimport sys\nimport bisect\nimport string\nimport math\nimport time\n\n\ndef I(): return int(input())\n\n\ndef MI(): return map(int, input().split())\n\n\ndef LI(): return [int(i) for i in input().split()]\n\n\ndef LI_(): return [int(i) -1 for i in input().split()]\n\n\ndef StoI(): return [ord(i) -97 for i in input()]\n\n\ndef ItoS(nn): return chr(nn+97)\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef show(*inp, end='\\n'):\n    if show_flg:\n        print(*inp, end=end)\n\n\nYN = ['No', 'Yes']\nMOD = 10**9+7\ninf = float('inf')\nIINF = 10**10\nl_alp = string.ascii_lowercase\nu_alp = string.ascii_uppercase\nts = time.time()\nsys.setrecursionlimit(10**6)\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n\nshow_flg = False\n\n\ndef main():\n    N = I()\n    s = [0] * N\n    t = [0] * N\n\n    for i in range(N):\n        s[i], t[i] = map(str, input().split())\n        t[i] = int(t[i])\n\n    X = input()\n    xi = 0\n\n    for i in range(N):\n        if s[i] == X:\n            xi = i\n            break\n\n    ans = 0\n\n    for i in range(N):\n        if xi < i:\n            ans += t[i]\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "token_boundary_changed": true}
{"id": "Python/153", "code": "n, k = map(int, input().split())\na = [i for i in input()]\nc = [0]*n\nfor i in range(1, n):\n    if a[i] == \"C\" and a[i-1] == \"A\":\n        c[i] = c[i-1]+1\n    else:\n        c[i] = c[i-1]\nfor w in range(k):\n    l, r = map(int, input().split())\n    print(c[r-1]-c[l-1])\n", "test_IO": {"input": ["8 3\nACACTACG\n3 7\n2 3\n1 8\n"], "output": ["2\n0\n3\n"]}, "modified_context": "n, k = map(int, input().split())\na = [i for i in input()]\nc = [0]*n\nfor i in range(1, n):\n    if a[i] == \"C\" and a[i-1] == \"A\":\n        c[i] = c[i-1]+1\n    else:\n        c[i] = c[i-1]\nfor w in range(k):\n    l, r = map(int, input().split())\n    print(c[r-1] -c[l-1])\n", "token_boundary_changed": true}
{"id": "Python/154", "code": "from collections import deque\nfrom itertools import product, permutations, combinations\nimport sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef read_col(H):\n\n    ret = []\n    for _ in range(H):\n        ret.append(list(map(int, readline().split())))\n    return tuple(map(list, zip(*ret)))\n\n\ndef read_map_as(H, replace={'#': 1, '.': 0}, pad=None):\n\n    if pad is None:\n        ret = []\n        for _ in range(H):\n            ret.append([replace[s] for s in read()[:-1]])\n\n    else:\n        ret = [[pad] * (W + 2)]\n        for _ in range(H):\n            ret.append([pad] + [replace[s] for s in read()[:-1]] + [pad])\n        ret.append([pad] * (W + 2))\n\n    return ret\n\n\ndef grid_dijkstra(grid, si: int, sj: int):\n\n    from heapq import heappop, heappush\n    H = len(grid)\n    W = len(grid[0])\n    D = [[-1] * W for _ in [0] * H]\n    que = [(0, si, sj)]\n    while que:\n        c, i, j = heappop(que)\n        if D[i][j] != -1:\n            continue\n        D[i][j] = c\n        for di, dj in product([-2, -1, 0, 1, 2], repeat=2):\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or grid[ni][nj] == 1:\n                continue\n            if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n                nc = c\n            else:\n                nc = c + 1\n            heappush(que, (nc, ni, nj))\n    return D\n\n\nMOD = 10**9 + 7\nINF = 2**31\n\n\nH, W = ints()\nsi, sj = mina(*ints())\nti, tj = mina(*ints())\n\nS = read_map_as(H)\nD = [[-1] * W for _ in [0] * H]\nque = deque([(0, si, sj)])\nwhile que:\n    c, i, j = que.popleft()\n    if D[i][j] != -1:\n        continue\n    D[i][j] = c\n    for di, dj in product([-2, -1, 0, 1, 2], repeat=2):\n        ni, nj = i + di, j + dj\n        if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or S[ni][nj] == 1:\n            continue\n        if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n            que.appendleft((c, ni, nj))\n        else:\n            que.append((c + 1, ni, nj))\n\nprint(D[ti][tj])\n", "test_IO": {"input": ["4 4\n1 1\n4 4\n..#.\n..#.\n.#..\n.#..\n"], "output": ["1\n"]}, "modified_context": "from collections import deque\nfrom itertools import product, permutations, combinations\nimport sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef read_col(H):\n\n    ret = []\n    for _ in range(H):\n        ret.append(list(map(int, readline().split())))\n    return tuple(map(list, zip(*ret)))\n\n\ndef read_map_as(H, replace={'#': 1, '.': 0}, pad=None):\n\n    if pad is None:\n        ret = []\n        for _ in range(H):\n            ret.append([replace[s] for s in read()[: -1]])\n\n    else:\n        ret = [[pad] * (W + 2)]\n        for _ in range(H):\n            ret.append([pad] + [replace[s] for s in read()[: -1]] + [pad])\n        ret.append([pad] * (W + 2))\n\n    return ret\n\n\ndef grid_dijkstra(grid, si: int, sj: int):\n\n    from heapq import heappop, heappush\n    H = len(grid)\n    W = len(grid[0])\n    D = [[ -1] * W for _ in [0] * H]\n    que = [(0, si, sj)]\n    while que:\n        c, i, j = heappop(que)\n        if D[i][j] != -1:\n            continue\n        D[i][j] = c\n        for di, dj in product([ -2, -1, 0, 1, 2], repeat=2):\n            ni, nj = i + di, j + dj\n            if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or grid[ni][nj] == 1:\n                continue\n            if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n                nc = c\n            else:\n                nc = c + 1\n            heappush(que, (nc, ni, nj))\n    return D\n\n\nMOD = 10**9 + 7\nINF = 2**31\n\n\nH, W = ints()\nsi, sj = mina(*ints())\nti, tj = mina(*ints())\n\nS = read_map_as(H)\nD = [[ -1] * W for _ in [0] * H]\nque = deque([(0, si, sj)])\nwhile que:\n    c, i, j = que.popleft()\n    if D[i][j] != -1:\n        continue\n    D[i][j] = c\n    for di, dj in product([ -2, -1, 0, 1, 2], repeat=2):\n        ni, nj = i + di, j + dj\n        if not (0 <= ni < H and 0 <= nj < W) or D[ni][nj] != -1 or ni == nj == 0 or S[ni][nj] == 1:\n            continue\n        if (di == 0 and abs(dj) == 1) or (dj == 0 and abs(di) == 1):\n            que.appendleft((c, ni, nj))\n        else:\n            que.append((c + 1, ni, nj))\n\nprint(D[ti][tj])\n", "token_boundary_changed": true}
{"id": "Python/161", "code": "X, N = list(map(int, input().split()))\np = list(map(int, input().split()))\n\np.sort()\n\ncandidates = {}\nfor i in range(-1, 102):\n\n    if i in p:\n        continue\n\n    if not (abs(X-i) in candidates.keys()):\n        candidates[abs(X-i)] = [i]\n    else:\n        candidates[abs(X-i)].append(i)\n\nsmallest = min(candidates.keys())\n\nminNum = min(candidates[smallest])\n\nprint(minNum)\n", "test_IO": {"input": ["6 5\n4 7 10 6 5\n"], "output": ["8\n"]}, "modified_context": "X, N = list(map(int, input().split()))\np = list(map(int, input().split()))\n\np.sort()\n\ncandidates = {}\nfor i in range( -1, 102):\n\n    if i in p:\n        continue\n\n    if not (abs(X-i) in candidates.keys()):\n        candidates[abs(X-i)] = [i]\n    else:\n        candidates[abs(X-i)].append(i)\n\nsmallest = min(candidates.keys())\n\nminNum = min(candidates[smallest])\n\nprint(minNum)\n", "token_boundary_changed": true}
{"id": "Python/162", "code": "from math import factorial as f\n\nN = int(input())\n\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\ndivs = []\nfor i in range(1, 101):\n    tmp = [0 for _ in range(len(primes))]\n    for j in range(len(primes)):\n        p = primes[j]\n        tmp[j] = 0\n        while (i//p == i/p):\n            i = i//p\n            tmp[j] += 1\n    divs.append(tmp)\n\n\ndivsum = [0 for _ in range(len(primes))]\nfor i in range(1, N+1):\n    for j in range(len(primes)):\n        divsum[j] += divs[i-1][j]\n\n\ndef num(n):\n    return len(list(filter(lambda x: x >= n-1, divsum)))\n\n\nans = 0\n\n\nans += num(75)\n\n\nans += num(15)*(num(5)-1)\n\n\nans += num(25)*(num(3)-1)\n\n\nans += num(5) * (num(5)-1) * (num(3)-2) // 2\nprint(int(ans))\n", "test_IO": {"input": ["9\n"], "output": ["0\n"]}, "modified_context": "from math import factorial as f\n\nN = int(input())\n\nprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]\ndivs = []\nfor i in range(1, 101):\n    tmp = [0 for _ in range(len(primes))]\n    for j in range(len(primes)):\n        p = primes[j]\n        tmp[j] = 0\n        while (i//p == i/p):\n            i = i//p\n            tmp[j] += 1\n    divs.append(tmp)\n\n\ndivsum = [0 for _ in range(len(primes))]\nfor i in range(1, N+1):\n    for j in range(len(primes)):\n        divsum[j] += divs[i-1][j]\n\n\ndef num(n):\n    return len(list(filter(lambda x: x >= n-1, divsum)))\n\n\nans = 0\n\n\nans += num(75)\n\n\nans += num(15)*(num(5) -1)\n\n\nans += num(25)*(num(3) -1)\n\n\nans += num(5) * (num(5) -1) * (num(3) -2) // 2\nprint(int(ans))\n", "token_boundary_changed": true}
{"id": "Python/165", "code": "from math import floor\nfrom heapq import heappush, heappop\nn, m = map(int, input().split())\na = []\nfor i in map(int, input().split()):\n    heappush(a, -i)\n\n\ndef dis(x, y): return x // 2**y\n\n\nfor _ in range(m):\n    heappush(a, -dis(-heappop(a), 1))\nprint(-sum(a))\n", "test_IO": {"input": ["3 3\n2 13 8\n"], "output": ["9\n"]}, "modified_context": "from math import floor\nfrom heapq import heappush, heappop\nn, m = map(int, input().split())\na = []\nfor i in map(int, input().split()):\n    heappush(a, -i)\n\n\ndef dis(x, y): return x // 2**y\n\n\nfor _ in range(m):\n    heappush(a, -dis( -heappop(a), 1))\nprint( -sum(a))\n", "token_boundary_changed": true}
{"id": "Python/169", "code": "d, g = list(map(int, input().split()))\npc = [list(map(int, input().split())) for _ in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use-1][0], -(-(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\nprint(ans)\n", "test_IO": {"input": ["2 700\n3 500\n5 800\n"], "output": ["3\n"]}, "modified_context": "d, g = list(map(int, input().split()))\npc = [list(map(int, input().split())) for _ in range(d)]\n\nans = float(\"inf\")\n\nfor bit in range(1 << d):\n    count = 0\n    sum = 0\n    nokori = set(range(1, d + 1))\n\n    for i in range(d):\n        if bit & (1 << i):\n            sum += pc[i][0] * (i + 1) * 100 + pc[i][1]\n            count += pc[i][0]\n            nokori.discard(i + 1)\n\n    if sum < g:\n        use = max(nokori)\n        n = min(pc[use-1][0], -( -(g - sum) // (use * 100)))\n        count += n\n        sum += n * use * 100\n\n    if sum >= g:\n        ans = min(ans, count)\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/175", "code": "import numpy\nn = int(input())\na = []\nfor i in range(2):\n    a.append(list(map(int, input().split())))\na[1] = a[1][::-1]\nres_0 = numpy.cumsum(a[0])\nres_1 = numpy.cumsum(a[1])\nans = 0\nfor i in range(n):\n    check = res_0[i] + res_1[n-1-i]\n    ans = max(ans, check)\nprint(ans)\n", "test_IO": {"input": ["5\n3 2 2 4 1\n1 2 2 2 1\n"], "output": ["14\n"]}, "modified_context": "import numpy\nn = int(input())\na = []\nfor i in range(2):\n    a.append(list(map(int, input().split())))\na[1] = a[1][:: -1]\nres_0 = numpy.cumsum(a[0])\nres_1 = numpy.cumsum(a[1])\nans = 0\nfor i in range(n):\n    check = res_0[i] + res_1[n-1-i]\n    ans = max(ans, check)\nprint(ans)\n", "token_boundary_changed": true}
{"id": "Python/184", "code": "import math\nN = int(input())\nsqN = int(math.sqrt(N))\nfor i in range(sqN):\n    if N % (sqN-i) == 0:\n        print(int(N/(sqN-i)+sqN-i)-2)\n        break\n", "test_IO": {"input": ["10\n"], "output": ["5\n"]}, "modified_context": "import math\nN = int(input())\nsqN = int(math.sqrt(N))\nfor i in range(sqN):\n    if N % (sqN-i) == 0:\n        print(int(N/(sqN-i)+sqN-i) -2)\n        break\n", "token_boundary_changed": true}
{"id": "Python/186", "code": "N = int(input())\nA = [int(x) for x in input().split()]\nans = abs(A[-1])\nA = [0]+A+[0]\ndiff = [0 for x in range(N)]\nfor i in range(1, N+1):\n    dif = abs(A[i]-A[i-1])+abs(A[i]-A[i+1])-abs(A[i-1]-A[i+1])\n    ans += abs(A[i]-A[i-1])\n    diff[i-1] = dif\n\nfor i in range(N):\n    print(ans-diff[i])\n", "test_IO": {"input": ["3\n3 5 -1\n"], "output": ["12\n8\n10\n"]}, "modified_context": "N = int(input())\nA = [int(x) for x in input().split()]\nans = abs(A[ -1])\nA = [0]+A+[0]\ndiff = [0 for x in range(N)]\nfor i in range(1, N+1):\n    dif = abs(A[i] -A[i-1])+abs(A[i] -A[i+1]) -abs(A[i-1] -A[i+1])\n    ans += abs(A[i] -A[i-1])\n    diff[i-1] = dif\n\nfor i in range(N):\n    print(ans-diff[i])\n", "token_boundary_changed": true}
{"id": "Python/195", "code": "A, B = [int(x) for x in input().split()]\nif A < 10 and B < 10:\n    print(A*B)\nelse:\n    print(-1)\n", "test_IO": {"input": ["2 5\n"], "output": ["10\n"]}, "modified_context": "A, B = [int(x) for x in input().split()]\nif A < 10 and B < 10:\n    print(A*B)\nelse:\n    print( -1)\n", "token_boundary_changed": true}
{"id": "Python/196", "code": "from operator import itemgetter\n\n\nn, k = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\ninfo = sorted(info, key=itemgetter(1), reverse=True)\n\nselected = info[0:k]\nselected_only = []\nselected_chohuku = []\nunselected_only = []\nmemo = {}\nfor t, d in selected:\n    if t not in memo:\n        memo[t] = 1\n        selected_only.append(d)\n    else:\n        selected_chohuku.append(d)\n\ncnt_type = len(memo)\nfor t, d in info[k:]:\n    if t not in memo:\n        memo[t] = 1\n        unselected_only.append(d)\n\n\nsum_select = sum(selected_chohuku) + sum(selected_only)\nans = cnt_type*cnt_type + sum_select\n\nunselected_only = unselected_only[::-1]\nfor i in range(min(len(selected_chohuku), len(unselected_only))):\n    cnt_type += 1\n    sum_select += unselected_only[-1]\n    sum_select -= selected_chohuku[-1]\n    del unselected_only[-1]\n    del selected_chohuku[-1]\n    tmp = cnt_type*cnt_type + sum_select\n    ans = max(ans, tmp)\nprint(ans)\n", "test_IO": {"input": ["5 3\n1 9\n1 7\n2 6\n2 5\n3 1\n"], "output": ["26\n"]}, "modified_context": "from operator import itemgetter\n\n\nn, k = map(int, input().split())\ninfo = [list(map(int, input().split())) for i in range(n)]\n\ninfo = sorted(info, key=itemgetter(1), reverse=True)\n\nselected = info[0:k]\nselected_only = []\nselected_chohuku = []\nunselected_only = []\nmemo = {}\nfor t, d in selected:\n    if t not in memo:\n        memo[t] = 1\n        selected_only.append(d)\n    else:\n        selected_chohuku.append(d)\n\ncnt_type = len(memo)\nfor t, d in info[k:]:\n    if t not in memo:\n        memo[t] = 1\n        unselected_only.append(d)\n\n\nsum_select = sum(selected_chohuku) + sum(selected_only)\nans = cnt_type*cnt_type + sum_select\n\nunselected_only = unselected_only[:: -1]\nfor i in range(min(len(selected_chohuku), len(unselected_only))):\n    cnt_type += 1\n    sum_select += unselected_only[ -1]\n    sum_select -= selected_chohuku[ -1]\n    del unselected_only[ -1]\n    del selected_chohuku[ -1]\n    tmp = cnt_type*cnt_type + sum_select\n    ans = max(ans, tmp)\nprint(ans)\n", "token_boundary_changed": true}
