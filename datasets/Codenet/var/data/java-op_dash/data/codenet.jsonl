{"id": "Java/32", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(final String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int a = scanner.nextInt(), b = scanner.nextInt();\n        boolean flag = false;\n        for (int i = 1; i <= 100000; i++) {\n            if (Math.floor(1. * i * .08) == a && b == Math.floor(.1 * i)) {\n                System.out.println(i);\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            System.out.println(-1);\n        }\n    }\n}\n", "test_IO": {"input": ["2 2\n"], "output": ["25\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(final String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int a = scanner.nextInt(), b = scanner.nextInt();\n        boolean flag = false;\n        for (int i = 1; i <= 100000; i++) {\n            if (Math.floor(1. * i * .08) == a && b == Math.floor(.1 * i)) {\n                System.out.println(i);\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            System.out.println( -1);\n        }\n    }\n}\n", "token_boundary_changed": true}
{"id": "Java/74", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int n, a[];\n    static double dp[][][];\n\n    static void solve() {\n        n = ni();\n        a = na(n);\n        dp = new double[n + 1][n + 1][n + 1];\n        for (int i = 0; i < n + 1; i++) fill(dp[i], -1);\n        dp[0][0][0] = 0;\n        int cnt[] = new int[3];\n        for (int i = 0; i < n; i++) {\n            cnt[a[i] - 1]++;\n        }\n        double ans = rec(cnt[0], cnt[1], cnt[2]);\n        out.println(ans);\n    }\n\n    static double rec(int i, int j, int k) {\n        if (dp[i][j][k] != -1) return dp[i][j][k];\n        double ret = 0;\n        double p = ((double) i + j + k) / n;\n        double pi = (double) i / n;\n        double pj = (double) j / n;\n        double pk = (double) k / n;\n        ret += 1 / p;\n        if (i > 0) ret += pi / p * rec(i - 1, j, k);\n        if (j > 0) ret += pj / p * rec(i + 1, j - 1, k);\n        if (k > 0) ret += pk / p * rec(i, j + 1, k - 1);\n        return dp[i][j][k] = ret;\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "test_IO": {"input": ["3\n1 1 1\n"], "output": ["5.5\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int n, a[];\n    static double dp[][][];\n\n    static void solve() {\n        n = ni();\n        a = na(n);\n        dp = new double[n + 1][n + 1][n + 1];\n        for (int i = 0; i < n + 1; i++) fill(dp[i], -1);\n        dp[0][0][0] = 0;\n        int cnt[] = new int[3];\n        for (int i = 0; i < n; i++) {\n            cnt[a[i] - 1]++;\n        }\n        double ans = rec(cnt[0], cnt[1], cnt[2]);\n        out.println(ans);\n    }\n\n    static double rec(int i, int j, int k) {\n        if (dp[i][j][k] != -1) return dp[i][j][k];\n        double ret = 0;\n        double p = ((double) i + j + k) / n;\n        double pi = (double) i / n;\n        double pj = (double) j / n;\n        double pk = (double) k / n;\n        ret += 1 / p;\n        if (i > 0) ret += pi / p * rec(i - 1, j, k);\n        if (j > 0) ret += pj / p * rec(i + 1, j - 1, k);\n        if (k > 0) ret += pk / p * rec(i, j + 1, k - 1);\n        return dp[i][j][k] = ret;\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = { -1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1}, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "token_boundary_changed": true}
{"id": "Java/136", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static void solve() {\n        String tmp = ns();\n        char s[] = tmp.toCharArray();\n        int n = s.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'S') {\n                cnt++;\n            } else {\n                if (cnt == 0) continue;\n                ans++;\n                cnt--;\n            }\n        }\n        out.println(n - 2 * ans);\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "test_IO": {"input": ["TSTTSS\n"], "output": ["4\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static void solve() {\n        String tmp = ns();\n        char s[] = tmp.toCharArray();\n        int n = s.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'S') {\n                cnt++;\n            } else {\n                if (cnt == 0) continue;\n                ans++;\n                cnt--;\n            }\n        }\n        out.println(n - 2 * ans);\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = { -1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = { -1, -1, -1, 0, 0, 1, 1, 1}, dy8 = { -1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "token_boundary_changed": true}
{"id": "Java/172", "code": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static final long INF = Long.MAX_VALUE / 2;\n    static final int MOD = 1_000_000_007;\n    static final int SIZE = 1_000_000;\n    long[] fac = new long[SIZE];\n    long[] inv = new long[SIZE];\n    long[] finv = new long[SIZE];\n    FastScanner sc = new FastScanner();\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    void solve() {\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            int s = sc.nextInt();\n            int c = sc.nextInt();\n            if (map.get(s) != null && map.get(s) != c) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n            map.put(s, c);\n        }\n\n        for (int i = 0; i < 1000; i++) {\n            String s = \"\" + i;\n            boolean flag = true;\n            if (s.length() < n) continue;\n            for (int j = 0; j < n; j++) {\n                if ((map.get(j + 1) != null\n                                && map.get(j + 1) != Character.getNumericValue(s.charAt(j)))\n                        || (map.get(j + 1) == null\n                                && Character.getNumericValue(s.charAt(j)) != 0)) {\n                    if (map.get(j + 1) == null\n                            && j == 0\n                            && Character.getNumericValue(s.charAt(j)) == 1) {\n                        continue;\n                    }\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag && s.length() == n) {\n                System.out.println(s);\n                System.exit(0);\n            }\n        }\n\n        System.out.println(-1);\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    long inv(long a) {\n        return pow(a, MOD - 2);\n    }\n\n    long pow(long a, long r) {\n        long sum = 1;\n        while (r > 0) {\n            if ((r & 1) == 1) {\n                sum *= a;\n                sum %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            r >>= 1;\n        }\n        return sum;\n    }\n\n    long modFact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * modFact(n - 1) % MOD;\n    }\n\n    long fact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * fact(n - 1);\n    }\n\n    void initCOMB() {\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for (int i = 2; i < SIZE; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    long modComb(int n, int r) {\n        if (n < r || n < 0 || r < 0) return 0;\n        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;\n    }\n\n    long comb(long n, long r) {\n        long num = 1;\n        for (long i = 1; i <= r; i++) {\n            num = num * (n - i + 1) / i;\n        }\n        return num;\n    }\n\n    boolean isPrime(long a) {\n        if (a <= 1) return false;\n        for (int i = 2; i * i <= a; i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    String nextPermutation(String s) {\n        ArrayList<Character> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) list.add(s.charAt(i));\n\n        int pivotPos = -1;\n        char pivot = 0;\n        for (int i = list.size() - 2; i >= 0; i--) {\n            if (list.get(i) < list.get(i + 1)) {\n                pivotPos = i;\n                pivot = list.get(i);\n                break;\n            }\n        }\n\n        if (pivotPos == -1 && pivot == 0) return null;\n\n        int L = pivotPos + 1;\n        int R = list.size() - 1;\n        int minPos = -1;\n        char min = Character.MAX_VALUE;\n        for (int i = R; i >= L; i--) {\n            if (pivot < list.get(i)) {\n                if (list.get(i) < min) {\n                    min = list.get(i);\n                    minPos = i;\n                }\n            }\n        }\n\n        Collections.swap(list, pivotPos, minPos);\n        Collections.sort(list.subList(L, R + 1));\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i));\n\n        return sb.toString();\n    }\n\n    boolean nextPermutation(long[] a) {\n        for (int i = a.length - 1; i > 0; i--) {\n            if (a[i - 1] < a[i]) {\n                int swapIndex = find(a[i - 1], a, i, a.length - 1);\n                long temp = a[swapIndex];\n                a[swapIndex] = a[i - 1];\n                a[i - 1] = temp;\n                Arrays.sort(a, i, a.length);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int find(long dest, long[] a, int s, int e) {\n        if (s == e) {\n            return s;\n        }\n        int m = (s + e + 1) / 2;\n        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n    }\n\n    void elimination(int[][] a, int[] b) {\n        int n = a.length;\n        double f;\n        for (int k = 0; k < n - 1; k++) {\n            for (int i = k + 1; i < n; i++) {\n                f = -a[i][k] / a[k][k];\n                for (int j = k + 1; j < n; j++) {\n                    a[i][j] += f * a[k][j];\n                }\n                b[i] += f * b[k];\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i + 1; j < n; j++) {\n                    b[i] -= a[i][j] * b[j];\n                }\n                b[i] = b[i] / a[i][i];\n            }\n        }\n    }\n}\n\nclass Pair implements Comparable<Pair> {\n    long a, b;\n\n    public Pair(long i, long j) {\n        a = i;\n        b = j;\n    }\n\n    @Override\n    public int compareTo(Pair p) {\n        if (this.b < p.b) return -1;\n        else if (this.b > p.b) return 1;\n        else return 0;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "test_IO": {"input": ["3 3\n1 7\n3 2\n1 7\n"], "output": ["702\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static final long INF = Long.MAX_VALUE / 2;\n    static final int MOD = 1_000_000_007;\n    static final int SIZE = 1_000_000;\n    long[] fac = new long[SIZE];\n    long[] inv = new long[SIZE];\n    long[] finv = new long[SIZE];\n    FastScanner sc = new FastScanner();\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    void solve() {\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            int s = sc.nextInt();\n            int c = sc.nextInt();\n            if (map.get(s) != null && map.get(s) != c) {\n                System.out.println( -1);\n                System.exit(0);\n            }\n            map.put(s, c);\n        }\n\n        for (int i = 0; i < 1000; i++) {\n            String s = \"\" + i;\n            boolean flag = true;\n            if (s.length() < n) continue;\n            for (int j = 0; j < n; j++) {\n                if ((map.get(j + 1) != null\n                                && map.get(j + 1) != Character.getNumericValue(s.charAt(j)))\n                        || (map.get(j + 1) == null\n                                && Character.getNumericValue(s.charAt(j)) != 0)) {\n                    if (map.get(j + 1) == null\n                            && j == 0\n                            && Character.getNumericValue(s.charAt(j)) == 1) {\n                        continue;\n                    }\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag && s.length() == n) {\n                System.out.println(s);\n                System.exit(0);\n            }\n        }\n\n        System.out.println( -1);\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    long inv(long a) {\n        return pow(a, MOD - 2);\n    }\n\n    long pow(long a, long r) {\n        long sum = 1;\n        while (r > 0) {\n            if ((r & 1) == 1) {\n                sum *= a;\n                sum %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            r >>= 1;\n        }\n        return sum;\n    }\n\n    long modFact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * modFact(n - 1) % MOD;\n    }\n\n    long fact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * fact(n - 1);\n    }\n\n    void initCOMB() {\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for (int i = 2; i < SIZE; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    long modComb(int n, int r) {\n        if (n < r || n < 0 || r < 0) return 0;\n        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;\n    }\n\n    long comb(long n, long r) {\n        long num = 1;\n        for (long i = 1; i <= r; i++) {\n            num = num * (n - i + 1) / i;\n        }\n        return num;\n    }\n\n    boolean isPrime(long a) {\n        if (a <= 1) return false;\n        for (int i = 2; i * i <= a; i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    String nextPermutation(String s) {\n        ArrayList<Character> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) list.add(s.charAt(i));\n\n        int pivotPos = -1;\n        char pivot = 0;\n        for (int i = list.size() - 2; i >= 0; i--) {\n            if (list.get(i) < list.get(i + 1)) {\n                pivotPos = i;\n                pivot = list.get(i);\n                break;\n            }\n        }\n\n        if (pivotPos == -1 && pivot == 0) return null;\n\n        int L = pivotPos + 1;\n        int R = list.size() - 1;\n        int minPos = -1;\n        char min = Character.MAX_VALUE;\n        for (int i = R; i >= L; i--) {\n            if (pivot < list.get(i)) {\n                if (list.get(i) < min) {\n                    min = list.get(i);\n                    minPos = i;\n                }\n            }\n        }\n\n        Collections.swap(list, pivotPos, minPos);\n        Collections.sort(list.subList(L, R + 1));\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i));\n\n        return sb.toString();\n    }\n\n    boolean nextPermutation(long[] a) {\n        for (int i = a.length - 1; i > 0; i--) {\n            if (a[i - 1] < a[i]) {\n                int swapIndex = find(a[i - 1], a, i, a.length - 1);\n                long temp = a[swapIndex];\n                a[swapIndex] = a[i - 1];\n                a[i - 1] = temp;\n                Arrays.sort(a, i, a.length);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int find(long dest, long[] a, int s, int e) {\n        if (s == e) {\n            return s;\n        }\n        int m = (s + e + 1) / 2;\n        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n    }\n\n    void elimination(int[][] a, int[] b) {\n        int n = a.length;\n        double f;\n        for (int k = 0; k < n - 1; k++) {\n            for (int i = k + 1; i < n; i++) {\n                f = -a[i][k] / a[k][k];\n                for (int j = k + 1; j < n; j++) {\n                    a[i][j] += f * a[k][j];\n                }\n                b[i] += f * b[k];\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i + 1; j < n; j++) {\n                    b[i] -= a[i][j] * b[j];\n                }\n                b[i] = b[i] / a[i][i];\n            }\n        }\n    }\n}\n\nclass Pair implements Comparable<Pair> {\n    long a, b;\n\n    public Pair(long i, long j) {\n        a = i;\n        b = j;\n    }\n\n    @Override\n    public int compareTo(Pair p) {\n        if (this.b < p.b) return -1;\n        else if (this.b > p.b) return 1;\n        else return 0;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "token_boundary_changed": true}
