{"task_id": "Java/0", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n    >>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\n    false\n    >>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\n    true\n     */\n    public boolean hasCloseElements(List<Double> numbers, double threshold) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean hasCloseElements(List<Double> numbers, double threshold) {\n", "canonical_solution": "        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double distance = Math.abs(numbers.get(i) - numbers.get(j));\n                if (distance < threshold) return true;\n            }\n        }\n        return false;\n    }\n}", "buggy_solution": "        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                double distance = numbers.get(i) - numbers.get(j);\n                if (distance < threshold) return true;\n            }\n        }\n        return false;\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "hasCloseElements", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(11.0, 2.0, 3.9, 4.0, 5.0, 2.2)), 0.3),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.9, 4.0, 5.0, 2.2)), 0.05),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0)), 0.95),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0)), 0.8),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0)), 0.1),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1)), 1.0),\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1)), 0.5)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0)), 0.5),\n                s.hasCloseElements(new ArrayList<>(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0)), 0.3)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean hasCloseElements(List<Double> numbers, double threshold)", "docstring": "Check if in given list of numbers, are any two numbers closer to each other than given threshold.\n>>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\nfalse\n>>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\ntrue", "instruction": "Write a Java function `public boolean hasCloseElements(List<Double> numbers, double threshold)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than given threshold.\n>>> hasCloseElements(Arrays.asList(1.0, 2.0, 3.0), 0.5)\nfalse\n>>> hasCloseElements(Arrays.asList(1.0, 2.8, 3.0, 4.0, 5.0, 2.0), 0.3)\ntrue", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean hasCloseElements(List<Double> numbers, double threshold) {\n        for (int i = 0; i < numbers.size(); i++ ) {\n            for (int j = i + 1; j < numbers.size(); j++ ) {\n                double distance = Math.abs(numbers.get(i) - numbers.get(j));\n                if (distance < threshold) return true;\n            }\n        }\n        return false;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/5", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse(List.of(), 4)\n    []\n    >>> intersperse(Arrays.asList(1, 2, 3), 4)\n    [1, 4, 2, 4, 3]\n     */\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n", "canonical_solution": "        if (numbers.size() == 0) {\n            return List.of();\n        }\n        List<Integer> result = new ArrayList<>(List.of());\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            result.add(numbers.get(i));\n            result.add(delimiter);\n        }\n\n        result.add(numbers.get(numbers.size() - 1));\n\n        return result;\n    }\n}", "buggy_solution": "        if (numbers.size() == 0) {\n            return List.of();\n        }\n        List<Integer> result = new ArrayList<>(List.of());\n        for (int i = 0; i < numbers.size() - 1; i++) {\n            result.add(numbers.get(i));\n            result.add(delimiter);\n        }\n\n        return result;\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "intersperse", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.intersperse(new ArrayList<>(List.of()), 7).equals(List.of()),\n                s.intersperse(new ArrayList<>(Arrays.asList(5, 6, 3, 2)), 8).equals(Arrays.asList(5, 8, 6, 8, 3, 8, 2)),\n                s.intersperse(new ArrayList<>(Arrays.asList(2, 2, 2)), 2).equals(Arrays.asList(2, 2, 2, 2, 2))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.intersperse(new ArrayList<>(List.of()), 4).equals(List.of()),\n                s.intersperse(new ArrayList<>(Arrays.asList(1,2,3)), 4).equals(Arrays.asList(1,4,2,4,3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> intersperse(List<Integer> numbers, int delimiter)", "docstring": "Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n>>> intersperse(List.of(), 4)\n[]\n>>> intersperse(Arrays.asList(1, 2, 3), 4)\n[1, 4, 2, 4, 3]", "instruction": "Write a Java function `public List<Integer> intersperse(List<Integer> numbers, int delimiter)` to solve the following problem:\nInsert a number 'delimeter' between every two consecutive elements of input list `numbers'\n>>> intersperse(List.of(), 4)\n[]\n>>> intersperse(Arrays.asList(1, 2, 3), 4)\n[1, 4, 2, 4, 3]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> intersperse(List<Integer> numbers, int delimiter) {\n        if (numbers.size() == 0) {\n            return List.of();\n        }\n        List<Integer> result = new ArrayList<>(List.of());\n        for (int i = 0; i < numbers.size() - 1; i++ ) {\n            result.add(numbers.get(i));\n            result.add(delimiter);\n        }\n\n        result.add(numbers.get(numbers.size() - 1));\n\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/9", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n    [1, 2, 3, 3, 3, 4, 4]\n     */\n    public List<Integer> rollingMax(List<Integer> numbers) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> rollingMax(List<Integer> numbers) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        if (numbers.size() == 0) {\n            return result;\n        }\n        int rollingMax = numbers.get(0);\n        result.add(rollingMax);\n\n        for (int i = 1; i < numbers.size(); i++) {\n            if (numbers.get(i) > rollingMax) {\n                rollingMax = numbers.get(i);\n            }\n            result.add(rollingMax);\n        }\n\n        return result;\n    }\n}", "buggy_solution": "        List<Integer> result = new ArrayList<>();\n        if (numbers.size() == 0) {\n            return result;\n        }\n        int rollingMax = 1;\n        result.add(rollingMax);\n\n        for (int i = 1; i < numbers.size(); i++) {\n            if (numbers.get(i) > rollingMax) {\n                rollingMax = numbers.get(i);\n            }\n            result.add(rollingMax);\n        }\n\n        return result;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "rollingMax", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.rollingMax(new ArrayList<>(List.of())).equals(List.of()),\n                s.rollingMax(new ArrayList<>(Arrays.asList(1, 2, 3, 4))).equals(Arrays.asList(1, 2, 3, 4)),\n                s.rollingMax(new ArrayList<>(Arrays.asList(4, 3, 2, 1))).equals(Arrays.asList(4, 4, 4, 4)),\n                s.rollingMax(new ArrayList<>(Arrays.asList(3, 2, 3, 100, 3))).equals(Arrays.asList(3, 3, 3, 100, 100))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.rollingMax(new ArrayList<>(List.of(1, 2, 3, 2, 3, 4, 2))).equals(List.of(1, 2, 3, 3, 3, 4, 4))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> rollingMax(List<Integer> numbers)", "docstring": "From a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.\n>>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n[1, 2, 3, 3, 3, 4, 4]", "instruction": "Write a Java function `public List<Integer> rollingMax(List<Integer> numbers)` to solve the following problem:\nFrom a given list of integers, generate a list of rolling maximum element found until given moment\nin the sequence.\n>>> rollingMax(Arrays.asList(1, 2, 3, 2, 3, 4, 2))\n[1, 2, 3, 3, 3, 4, 4]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> rollingMax(List<Integer> numbers) {\n        List<Integer> result = new ArrayList<>();\n        if (numbers.size() == 0) {\n            return result;\n        }\n        int rollingMax = numbers.get(0);\n        result.add(rollingMax);\n\n        for (int i = 1; i < numbers.size(); i++ ) {\n            if (numbers.get(i) > rollingMax) {\n                rollingMax = numbers.get(i);\n            }\n            result.add(rollingMax);\n        }\n\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/11", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> stringXor(\"010\", \"110\")\n    \"100\"\n     */\n    public String stringXor(String a, String b) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String stringXor(String a, String b) {\n", "canonical_solution": "        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < a.length(); i++) {\n            if (a.charAt(i) == b.charAt(i)) {\n                result.append(\"0\");\n            } else {\n                result.append(\"1\");\n            }\n        }\n        return result.toString();\n    }\n}", "buggy_solution": "        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < a.length(); i++) {\n            if (a.charAt(i) == b.charAt(i)) {\n                result.append(\"1\");\n            } else {\n                result.append(\"0\");\n            }\n        }\n        return result.toString();\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "stringXor", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.stringXor(\"111000\", \"101010\"), \"010010\"),\n                Objects.equals(s.stringXor(\"1\", \"1\"), \"0\"),\n                Objects.equals(s.stringXor(\"0101\", \"0000\"), \"0101\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.stringXor(\"010\", \"110\"), \"100\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public String stringXor(String a, String b)", "docstring": "Input are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> stringXor(\"010\", \"110\")\n\"100\"", "instruction": "Write a Java function `public String stringXor(String a, String b)` to solve the following problem:\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n>>> stringXor(\"010\", \"110\")\n\"100\"", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String stringXor(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < a.length(); i++ ) {\n            if (a.charAt(i) == b.charAt(i)) {\n                result.append(\"0\");\n            } else {\n                result.append(\"1\");\n            }\n        }\n        return result.toString();\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/14", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return list of all prefixes from shortest to longest of the input string\n    >>> allPrefixes(\"abc\")\n    [\"a\", \"ab\", \"abc\"]\n     */\n    public List<String> allPrefixes(String string) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> allPrefixes(String string) {\n", "canonical_solution": "        List<String> result = new ArrayList<>();\n\n        for (int i = 1; i <= string.length(); i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n}", "buggy_solution": "        List<String> result = new ArrayList<>();\n\n        for (int i = 1; i <= string.length()-1; i++) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "allPrefixes", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.allPrefixes(\"\").equals(List.of()),\n                s.allPrefixes(\"asdfgh\").equals(Arrays.asList(\"a\", \"as\", \"asd\", \"asdf\", \"asdfg\", \"asdfgh\")),\n                s.allPrefixes(\"WWW\").equals(Arrays.asList(\"W\", \"WW\", \"WWW\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.allPrefixes(\"abc\").equals(Arrays.asList(\"a\", \"ab\", \"abc\"))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<String> allPrefixes(String string)", "docstring": "Return list of all prefixes from shortest to longest of the input string\n>>> allPrefixes(\"abc\")\n[\"a\", \"ab\", \"abc\"]", "instruction": "Write a Java function `public List<String> allPrefixes(String string)` to solve the following problem:\nReturn list of all prefixes from shortest to longest of the input string\n>>> allPrefixes(\"abc\")\n[\"a\", \"ab\", \"abc\"]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<String> allPrefixes(String string) {\n        List<String> result = new ArrayList<>();\n\n        for (int i = 1; i <= string.length(); i++ ) {\n            result.add(string.substring(0, i));\n        }\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/15", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> stringSequence(0)\n    \"0\"\n    >>> stringSequence(5)\n    \"0 1 2 3 4 5\"\n     */\n    public String stringSequence(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String stringSequence(int n) {\n", "canonical_solution": "        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++) {\n            sb.append(i);\n            sb.append(\" \");\n        }\n        sb.append(n);\n        return sb.toString();\n    }\n}", "buggy_solution": "        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n-1; i++) {\n            sb.append(i);\n            sb.append(\" \");\n        }\n        sb.append(n);\n        return sb.toString();\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "stringSequence", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.stringSequence(0).equals(\"0\"),\n                s.stringSequence(3).equals(\"0 1 2 3\"),\n                s.stringSequence(10).equals(\"0 1 2 3 4 5 6 7 8 9 10\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.stringSequence(0).equals(\"0\"),\n                s.stringSequence(5).equals(\"0 1 2 3 4 5\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public String stringSequence(int n)", "docstring": "Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n>>> stringSequence(0)\n\"0\"\n>>> stringSequence(5)\n\"0 1 2 3 4 5\"", "instruction": "Write a Java function `public String stringSequence(int n)` to solve the following problem:\nReturn a string containing space-delimited numbers starting from 0 upto n inclusive.\n>>> stringSequence(0)\n\"0\"\n>>> stringSequence(5)\n\"0 1 2 3 4 5\"", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String stringSequence(int n) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++ ) {\n            sb.append(i);\n            sb.append(\" \");\n        }\n        sb.append(n);\n        return sb.toString();\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/18", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> howManyTimes(\"\", \"a\")\n    0\n    >>> howManyTimes(\"aaa\", \"a\")\n    3\n    >>> howManyTimes(\"aaaa\", \"aa\")\n    3\n     */\n    public int howManyTimes(String string, String substring) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int howManyTimes(String string, String substring) {\n", "canonical_solution": "        int times = 0;\n\n        for (int i = 0; i < string.length() - substring.length() + 1; i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                times += 1;\n            }\n        }\n\n        return times;\n    }\n}", "buggy_solution": "        int times = 0;\n\n        for (int i = 0; i < string.length() - substring.length(); i++) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                times += 1;\n            }\n        }\n\n        return times;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "howManyTimes", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.howManyTimes(\"\", \"x\") == 0,\n                s.howManyTimes(\"xyxyxyx\", \"x\") == 4,\n                s.howManyTimes(\"cacacacac\", \"cac\") == 4,\n                s.howManyTimes(\"john doe\", \"john\") == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.howManyTimes(\"\", \"a\") == 0,\n                s.howManyTimes(\"aaa\", \"a\") == 3,\n                s.howManyTimes(\"aaaa\", \"aa\") == 3\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int howManyTimes(String string, String substring)", "docstring": "Find how many times a given substring can be found in the original string. Count overlaping cases.\n>>> howManyTimes(\"\", \"a\")\n0\n>>> howManyTimes(\"aaa\", \"a\")\n3\n>>> howManyTimes(\"aaaa\", \"aa\")\n3", "instruction": "Write a Java function `public int howManyTimes(String string, String substring)` to solve the following problem:\nFind how many times a given substring can be found in the original string. Count overlaping cases.\n>>> howManyTimes(\"\", \"a\")\n0\n>>> howManyTimes(\"aaa\", \"a\")\n3\n>>> howManyTimes(\"aaaa\", \"aa\")\n3", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int howManyTimes(String string, String substring) {\n        int times = 0;\n\n        for (int i = 0; i < string.length() - substring.length() + 1; i++ ) {\n            if (string.substring(i, i + substring.length()).equals(substring)) {\n                times += 1;\n            }\n        }\n\n        return times;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/20", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n    [2.0, 2.2]\n    >>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n    [2.0, 2.0]\n     */\n    public List<Double> findClosestElements(List<Double> numbers) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> findClosestElements(List<Double> numbers) {\n", "canonical_solution": "        List<Double> closestPair = new ArrayList<>();\n        closestPair.add(numbers.get(0));\n        closestPair.add(numbers.get(1));\n        double distance = Math.abs(numbers.get(1) - numbers.get(0));\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                if (Math.abs(numbers.get(i) - numbers.get(j)) < distance) {\n                    closestPair.clear();\n                    closestPair.add(numbers.get(i));\n                    closestPair.add(numbers.get(j));\n                    distance = Math.abs(numbers.get(i) - numbers.get(j));\n                }\n            }\n        }\n        Collections.sort(closestPair);\n        return closestPair;\n    }\n}", "buggy_solution": "        List<Double> closestPair = new ArrayList<>();\n        closestPair.add(numbers.get(0));\n        closestPair.add(numbers.get(1));\n        double distance = Math.abs(numbers.get(1) - numbers.get(0));\n        for (int i = 0; i < numbers.size(); i++) {\n            for (int j = i + 1; j < numbers.size(); j++) {\n                if (Math.abs(numbers.get(i) - numbers.get(j)) > distance) {\n                    closestPair.clear();\n                    closestPair.add(numbers.get(i));\n                    closestPair.add(numbers.get(j));\n                    distance = Math.abs(numbers.get(i) - numbers.get(j));\n                }\n            }\n        }\n        Collections.sort(closestPair);\n        return closestPair;\n    }\n}", "bug_type": "operator misuse", "failure_symptoms": "incorrect output", "entry_point": "findClosestElements", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.9, 4.0, 5.0, 2.2))).equals(Arrays.asList(3.9, 4.0)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 5.9, 4.0, 5.0))).equals(Arrays.asList(5.0, 5.9)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))).equals(Arrays.asList(2.0, 2.2)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))).equals(Arrays.asList(2.0, 2.0)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.1, 2.2, 3.1, 4.1, 5.1))).equals(Arrays.asList(2.2, 3.1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))).equals(Arrays.asList(2.0, 2.2)),\n                s.findClosestElements(new ArrayList<>(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))).equals(Arrays.asList(2.0, 2.0))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Double> findClosestElements(List<Double> numbers)", "docstring": "From a supplied list of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n[2.0, 2.2]\n>>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n[2.0, 2.0]", "instruction": "Write a Java function `public List<Double> findClosestElements(List<Double> numbers)` to solve the following problem:\nFrom a supplied list of numbers (of length at least two) select and return two that are the closest to each\nother and return them in order (smaller number, larger number).\n>>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.2))\n[2.0, 2.2]\n>>> findClosestElements(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 2.0))\n[2.0, 2.0]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Double> findClosestElements(List<Double> numbers) {\n        List<Double> closestPair = new ArrayList<>();\n        closestPair.add(numbers.get(0));\n        closestPair.add(numbers.get(1));\n        double distance = Math.abs(numbers.get(1) - numbers.get(0));\n        for (int i = 0; i < numbers.size(); i++ ) {\n            for (int j = i + 1; j < numbers.size(); j++ ) {\n                if (Math.abs(numbers.get(i) - numbers.get(j)) < distance) {\n                    closestPair.clear();\n                    closestPair.add(numbers.get(i));\n                    closestPair.add(numbers.get(j));\n                    distance = Math.abs(numbers.get(i) - numbers.get(j));\n                }\n            }\n        }\n        Collections.sort(closestPair);\n        return closestPair;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/27", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flipCase(\"Hello\")\n    \"hELLO\"\n     */\n    public String flipCase(String string) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String flipCase(String string) {\n", "canonical_solution": "        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < string.length(); i++) {\n            if (Character.isLowerCase(string.charAt(i))) {\n                sb.append(Character.toUpperCase(string.charAt(i)));\n            } else {\n                sb.append(Character.toLowerCase(string.charAt(i)));\n            }\n        }\n        return sb.toString();\n    }\n}", "buggy_solution": "        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < string.length(); i++) {\n            if (Character.isUpperCase(string.charAt(i))) {\n                sb.append(Character.toUpperCase(string.charAt(i)));\n            } else {\n                sb.append(Character.toLowerCase(string.charAt(i)));\n            }\n        }\n        return sb.toString();\n    }\n}", "bug_type": "function misuse", "failure_symptoms": "incorrect output", "entry_point": "flipCase", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.flipCase(\"\"), \"\"),\n                Objects.equals(s.flipCase(\"Hello!\"), \"hELLO!\"),\n                Objects.equals(s.flipCase(\"These violent delights have violent ends\"), \"tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.flipCase(\"\"), \"\"),\n                Objects.equals(s.flipCase(\"Hello\"), \"hELLO\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public String flipCase(String string)", "docstring": "For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n>>> flipCase(\"Hello\")\n\"hELLO\"", "instruction": "Write a Java function `public String flipCase(String string)` to solve the following problem:\nFor a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n>>> flipCase(\"Hello\")\n\"hELLO\"", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String flipCase(String string) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < string.length(); i++ ) {\n            if (Character.isLowerCase(string.charAt(i))) {\n                sb.append(Character.toUpperCase(string.charAt(i)));\n            } else {\n                sb.append(Character.toLowerCase(string.charAt(i)));\n            }\n        }\n        return sb.toString();\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/31", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return true if a given number is prime, and false otherwise.\n    >>> isPrime(6)\n    false\n    >>> isPrime(101)\n    true\n    >>> isPrime(11)\n    true\n    >>> isPrime(13441)\n    true\n    >>> isPrime(61)\n    true\n    >>> isPrime(4)\n    false\n    >>> isPrime(1)\n    false\n     */\n    public boolean isPrime(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isPrime(int n) {\n", "canonical_solution": "        if (n < 2) {\n            return false;\n        }\n        for (int k = 2; k < n; k++) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n         return true;\n    }\n}", "buggy_solution": "        if (n < 1) {\n            return false;\n        }\n        for (int k = 1; k < n; k++) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n         return true;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "isPrime", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isPrime(6),\n                s.isPrime(101),\n                s.isPrime(11),\n                s.isPrime(13441),\n                s.isPrime(61),\n                !s.isPrime(4),\n                !s.isPrime(1),\n                s.isPrime(5),\n                s.isPrime(11),\n                s.isPrime(17),\n                !s.isPrime(5 * 17),\n                !s.isPrime(11 * 7),\n                !s.isPrime(13441 * 19)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isPrime(6),\n                s.isPrime(101),\n                s.isPrime(11),\n                s.isPrime(13441),\n                s.isPrime(61),\n                !s.isPrime(4),\n                !s.isPrime(1)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean isPrime(int n)", "docstring": "Return true if a given number is prime, and false otherwise.\n>>> isPrime(6)\nfalse\n>>> isPrime(101)\ntrue\n>>> isPrime(11)\ntrue\n>>> isPrime(13441)\ntrue\n>>> isPrime(61)\ntrue\n>>> isPrime(4)\nfalse\n>>> isPrime(1)\nfalse", "instruction": "Write a Java function `public boolean isPrime(int n)` to solve the following problem:\nReturn true if a given number is prime, and false otherwise.\n>>> isPrime(6)\nfalse\n>>> isPrime(101)\ntrue\n>>> isPrime(11)\ntrue\n>>> isPrime(13441)\ntrue\n>>> isPrime(61)\ntrue\n>>> isPrime(4)\nfalse\n>>> isPrime(1)\nfalse", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        for (int k = 2; k < n; k++ ) {\n            if (n % k == 0) {\n                return false;\n            }\n        }\n         return true;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/32", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    /**\n    xs are coefficients of a polynomial.\n    findZero find x such that poly(x) = 0.\n    findZero returns only only zero point, even if there are many.\n    Moreover, findZero only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> findZero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n    -0.5\n    >>> findZero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n     */\n    public double findZero(List<Double> xs) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    public double findZero(List<Double> xs) {\n", "canonical_solution": "        double begin = -1, end = 1;\n        while (poly(xs, begin) * poly(xs, end) > 0) {\n            begin *= 2;\n            end *= 2;\n        }\n        while (end - begin > 1e-10) {\n            double center = (begin + end) / 2;\n            if (poly(xs, begin) * poly(xs, center) > 0) {\n                begin = center;\n            } else {\n                end = center;\n            }\n        }\n        return begin;\n    }\n}", "buggy_solution": "        double begin = -1, end = 1;\n        while (poly(xs, begin) * poly(xs, end) > 0) {\n            begin *= 2;\n            end *= 2;\n        }\n        while (begin - end  > 1e-10) {\n            double center = (begin + end) / 2;\n            if (poly(xs, begin) * poly(xs, center) > 0) {\n                begin = center;\n            } else {\n                end = center;\n            }\n        }\n        return begin;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "findZero", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        Random rand = new Random(42);\n        for (int i = 0; i < 100; i++) {\n            int ncoeff = 2 * (rand.nextInt(3) + 1);\n            List<Double> coeffs = new ArrayList<>();\n            for (int j = 0; j < ncoeff; j++) {\n                int coeff = rand.nextInt(20) - 10;\n                if (coeff == 0) {\n                    coeff = 1;\n                }\n                coeffs.add((double) coeff);\n            }\n            double solution = s.findZero(coeffs);\n            if (Math.abs(s.poly(coeffs, solution)) > 1e-4) {\n                throw new AssertionError();\n            }\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n            Math.abs(s.findZero(new ArrayList<>(Arrays.asList(1.,2.)))+0.5)<1e-4,\n            Math.abs(s.findZero(new ArrayList<>(Arrays.asList(-6.,11.,-6.,1.)))-1)<1e-4\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public double findZero(List<Double> xs)", "docstring": "xs are coefficients of a polynomial.\nfindZero find x such that poly(x) = 0.\nfindZero returns only only zero point, even if there are many.\nMoreover, findZero only takes list xs having even number of coefficients\nand largest non zero coefficient as it guarantees\na solution.\n>>> findZero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n-0.5\n>>> findZero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n1.0", "instruction": "Write a Java function `public double findZero(List<Double> xs)` to solve the following problem:\nxs are coefficients of a polynomial.\nfindZero find x such that poly(x) = 0.\nfindZero returns only only zero point, even if there are many.\nMoreover, findZero only takes list xs having even number of coefficients\nand largest non zero coefficient as it guarantees\na solution.\n>>> findZero(Arrays.asList(1, 2)) // f(x) = 1 + 2x\n-0.5\n>>> findZero(Arrays.asList(-6, 11, -6, 1)) // (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n1.0", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n     */\n    public double poly(List<Double> xs, double x) {\n        double result = 0;\n        for (int i = 0; i < xs.size(); i++ ) {\n            result += xs.get(i) * Math.pow(x, i);\n        }\n        return result;\n    }\n    \n    public double findZero(List<Double> xs) {\n        double begin = -1, end = 1;\n        while (poly(xs, begin) * poly(xs, end) > 0) {\n            begin *= 2;\n            end *= 2;\n        }\n        while (end - begin > 1e-10) {\n            double center = (begin + end) / 2;\n            if (poly(xs, begin) * poly(xs, center) > 0) {\n                begin = center;\n            } else {\n                end = center;\n            }\n        }\n        return begin;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/36", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizzBuzz(50)\n    0\n    >>> fizzBuzz(78)\n    2\n    >>> fizzBuzz(79)\n    3\n     */\n    public int fizzBuzz(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fizzBuzz(int n) {\n", "canonical_solution": "        int result = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                char[] digits = String.valueOf(i).toCharArray();\n                for (char c : digits) {\n                    if (c == '7') {\n                        result += 1;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}", "buggy_solution": "        int result = 0;\n        for (int i = 1; i < n; i++) {\n            if (i % 11 == 0 && i % 13 == 0) {\n                char[] digits = String.valueOf(i).toCharArray();\n                for (char c : digits) {\n                    if (c == '7') {\n                        result += 1;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}", "bug_type": "operator misuse", "failure_symptoms": "incorrect output", "entry_point": "fizzBuzz", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fizzBuzz(50) == 0,\n                s.fizzBuzz(78) == 2,\n                s.fizzBuzz(79) == 3,\n                s.fizzBuzz(100) == 3,\n                s.fizzBuzz(200) == 6,\n                s.fizzBuzz(4000) == 192,\n                s.fizzBuzz(10000) == 639,\n                s.fizzBuzz(100000) == 8026\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fizzBuzz(50) == 0,\n                s.fizzBuzz(78) == 2,\n                s.fizzBuzz(79) == 3\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int fizzBuzz(int n)", "docstring": "Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n>>> fizzBuzz(50)\n0\n>>> fizzBuzz(78)\n2\n>>> fizzBuzz(79)\n3", "instruction": "Write a Java function `public int fizzBuzz(int n)` to solve the following problem:\nReturn the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n>>> fizzBuzz(50)\n0\n>>> fizzBuzz(78)\n2\n>>> fizzBuzz(79)\n3", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fizzBuzz(int n) {\n        int result = 0;\n        for (int i = 1; i < n; i++ ) {\n            if (i % 11 == 0 || i % 13 == 0) {\n                char[] digits = String.valueOf(i).toCharArray();\n                for (char c : digits) {\n                    if (c == '7') {\n                        result += 1;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/38", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    /**\n    takes as input string encoded with encodeCyclic function. Returns decoded string.\n     */\n    public String decodeCyclic(String s) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public String decodeCyclic(String s) {\n", "canonical_solution": "        return encodeCyclic(encodeCyclic(s));\n    }\n}", "buggy_solution": "        return encodeCyclic(s);\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "decodeCyclic", "import": "", "test_setup": "", "test": "\npublic class Main {\n    static char[] letters = \"abcdefghijklmnopqrstuvwxyz\".toCharArray();\n    static Random rand = new Random(42);\n    public static String random_string(int length) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < length; i++) {\n            sb.append(letters[rand.nextInt(26)]);\n        }\n        return sb.toString();\n    }\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        for (int i = 0; i < 100; i++) {\n            String str = random_string(rand.nextInt(10) + 10);\n            String encode_str = s.encodeCyclic(str);\n            if (!s.decodeCyclic(encode_str).equals(str)) {\n                throw new AssertionError();\n            }\n        }\n    }\n}", "example_test": "", "signature": "public String decodeCyclic(String s)", "docstring": "takes as input string encoded with encodeCyclic function. Returns decoded string.", "instruction": "Write a Java function `public String decodeCyclic(String s)` to solve the following problem:\ntakes as input string encoded with encodeCyclic function. Returns decoded string.", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    returns encoded string by cycling groups of three characters.\n     */\n    public String encodeCyclic(String s) {\n        // split string to groups. Each of length 3.\n        List<String> groups = new ArrayList<>();\n        for (int i = 0; i < s.length(); i += 3) {\n            groups.add(s.substring(i, Math.min(i + 3, s.length())));\n        }\n        // cycle elements in each group. Unless group has fewer elements than 3.\n        for (int i = 0; i < groups.size(); i++ ) {\n            if (groups.get(i).length() == 3) {\n                groups.set(i, groups.get(i).substring(1) + groups.get(i).charAt(0));\n            }\n        }\n        return String.join(\"\", groups);\n    }\n\n    public String decodeCyclic(String s) {\n        return encodeCyclic(encodeCyclic(s));\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/39", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    primeFib returns n-th number that is a Fibonacci number and it's also prime.\n    >>> primeFib(1)\n    2\n    >>> primeFib(2)\n    3\n    >>> primeFib(3)\n    5\n    >>> primeFib(4)\n    13\n    >>> primeFib(5)\n    89\n     */\n    public int primeFib(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int primeFib(int n) {\n", "canonical_solution": "        int f0 = 0, f1 = 1;\n        while (true) {\n            int p = f0 + f1;\n            boolean isPrime = p >= 2;\n            for (int k = 2; k < Math.min(Math.sqrt(p) + 1, p - 1); k++) {\n                if (p % k == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                n -= 1;\n            }\n            if (n == 0) {\n                return p;\n            }\n            f0 = f1;\n            f1 = p;\n        }\n    }\n}", "buggy_solution": "        int f0 = 0, f1 = 0;\n        while (true) {\n            int p = f0 + f1;\n            boolean isPrime = p >= 2;\n            for (int k = 2; k < Math.min(Math.sqrt(p), p); k++) {\n                if (p % k == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                n -= 1;\n            }\n            if (n == 0) {\n                return p;\n            }\n            f0 = f1;\n            f1 = p;\n        }\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "primeFib", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.primeFib(1) == 2,\n                s.primeFib(2) == 3,\n                s.primeFib(3) == 5,\n                s.primeFib(4) == 13,\n                s.primeFib(5) == 89,\n                s.primeFib(6) == 233,\n                s.primeFib(7) == 1597,\n                s.primeFib(8) == 28657,\n                s.primeFib(9) == 514229,\n                s.primeFib(10) == 433494437\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.primeFib(1) == 2,\n                s.primeFib(2) == 3,\n                s.primeFib(3) == 5,\n                s.primeFib(4) == 13,\n                s.primeFib(5) == 89\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int primeFib(int n)", "docstring": "primeFib returns n-th number that is a Fibonacci number and it's also prime.\n>>> primeFib(1)\n2\n>>> primeFib(2)\n3\n>>> primeFib(3)\n5\n>>> primeFib(4)\n13\n>>> primeFib(5)\n89", "instruction": "Write a Java function `public int primeFib(int n)` to solve the following problem:\nprimeFib returns n-th number that is a Fibonacci number and it's also prime.\n>>> primeFib(1)\n2\n>>> primeFib(2)\n3\n>>> primeFib(3)\n5\n>>> primeFib(4)\n13\n>>> primeFib(5)\n89", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int primeFib(int n) {\n        int f0 = 0, f1 = 1;\n        while (true) {\n            int p = f0 + f1;\n            boolean isPrime = p >= 2;\n            for (int k = 2; k < Math.min(Math.sqrt(p) + 1, p - 1); k++ ) {\n                if (p % k == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                n -= 1;\n            }\n            if (n == 0) {\n                return p;\n            }\n            f0 = f1;\n            f1 = p;\n        }\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/40", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    triplesSumToZero takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> triplesSumToZero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> triplesSumToZero(Arrays.asList(1, 3, -2, 1))\n    true\n    >>> triplesSumToZero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> triplesSumToZero(Arrays.asList(2, 4, -5, 3, 9, 7))\n    true\n    >>> triplesSumToZero(Arrays.asList(1))\n    false\n     */\n    public boolean triplesSumToZero(List<Integer> l) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean triplesSumToZero(List<Integer> l) {\n", "canonical_solution": "        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n                for (int k = j + 1; k < l.size(); k++) {\n                    if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}", "buggy_solution": "        for (int i = 1; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n                for (int k = j + 1; k < l.size(); k++) {\n                    if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "triplesSumToZero", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, 0))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, -1))),\n                s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, -2, 1))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 2, 3, 7))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 2, 5, 7))),\n                s.triplesSumToZero(new ArrayList<>(Arrays.asList(2, 4, -5, 3, 9, 7))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, -100))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(100, 3, 5, -100)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, 0))),\n                s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 3, -2, 1))),\n                !s.triplesSumToZero(new ArrayList<>(Arrays.asList(1, 2, 3, 7))),\n                s.triplesSumToZero(new ArrayList<>(Arrays.asList(2, 4, -5, 3, 9, 7)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean triplesSumToZero(List<Integer> l)", "docstring": "triplesSumToZero takes a list of integers as an input.\nit returns True if there are three distinct elements in the list that\nsum to zero, and False otherwise.\n>>> triplesSumToZero(Arrays.asList(1, 3, 5, 0))\nfalse\n>>> triplesSumToZero(Arrays.asList(1, 3, -2, 1))\ntrue\n>>> triplesSumToZero(Arrays.asList(1, 2, 3, 7))\nfalse\n>>> triplesSumToZero(Arrays.asList(2, 4, -5, 3, 9, 7))\ntrue\n>>> triplesSumToZero(Arrays.asList(1))\nfalse", "instruction": "Write a Java function `public boolean triplesSumToZero(List<Integer> l)` to solve the following problem:\ntriplesSumToZero takes a list of integers as an input.\nit returns True if there are three distinct elements in the list that\nsum to zero, and False otherwise.\n>>> triplesSumToZero(Arrays.asList(1, 3, 5, 0))\nfalse\n>>> triplesSumToZero(Arrays.asList(1, 3, -2, 1))\ntrue\n>>> triplesSumToZero(Arrays.asList(1, 2, 3, 7))\nfalse\n>>> triplesSumToZero(Arrays.asList(2, 4, -5, 3, 9, 7))\ntrue\n>>> triplesSumToZero(Arrays.asList(1))\nfalse", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean triplesSumToZero(List<Integer> l) {\n        for (int i = 0; i < l.size(); i++ ) {\n            for (int j = i + 1; j < l.size(); j++ ) {\n                for (int k = j + 1; k < l.size(); k++ ) {\n                    if (l.get(i) + l.get(j) + l.get(k) == 0) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/43", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    pairsSumToZero takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> pairsSumToZero(Arrays.asList(1, 3, 5, 0))\n    false\n    >>> pairsSumToZero(Arrays.asList(1, 3, -2, 1))\n    false\n    >>> pairsSumToZero(Arrays.asList(1, 2, 3, 7))\n    false\n    >>> pairsSumToZero(Arrays.asList(2, 4, -5, 3, 5, 7))\n    true\n    >>> pairsSumToZero(Arrays.asList(1))\n    false\n     */\n    public boolean pairsSumToZero(List<Integer> l) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean pairsSumToZero(List<Integer> l) {\n", "canonical_solution": "        for (int i = 0; i < l.size(); i++) {\n            for (int j = i + 1; j < l.size(); j++) {\n                if (l.get(i) + l.get(j) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "buggy_solution": "        for (int i = 0; i < l.size(); i++) {\n            for (int j = i; j < l.size(); j++) {\n                if (l.get(i) + l.get(j) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "pairsSumToZero", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, 0))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 3, -2, 1))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 2, 3, 7))),\n                s.pairsSumToZero(new ArrayList<>(Arrays.asList(2, 4, -5, 3, 5, 7))),\n                !s.pairsSumToZero(new ArrayList<>(List.of(1))),\n                s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 3, 2, 30))),\n                s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 3, 2, 31))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 4, 2, 30))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(-3, 9, -1, 4, 2, 31)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 3, 5, 0))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 3, -2, 1))),\n                !s.pairsSumToZero(new ArrayList<>(Arrays.asList(1, 2, 3, 7))),\n                s.pairsSumToZero(new ArrayList<>(Arrays.asList(2, 4, -5, 3, 5, 7)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean pairsSumToZero(List<Integer> l)", "docstring": "pairsSumToZero takes a list of integers as an input.\nit returns True if there are two distinct elements in the list that\nsum to zero, and False otherwise.\n>>> pairsSumToZero(Arrays.asList(1, 3, 5, 0))\nfalse\n>>> pairsSumToZero(Arrays.asList(1, 3, -2, 1))\nfalse\n>>> pairsSumToZero(Arrays.asList(1, 2, 3, 7))\nfalse\n>>> pairsSumToZero(Arrays.asList(2, 4, -5, 3, 5, 7))\ntrue\n>>> pairsSumToZero(Arrays.asList(1))\nfalse", "instruction": "Write a Java function `public boolean pairsSumToZero(List<Integer> l)` to solve the following problem:\npairsSumToZero takes a list of integers as an input.\nit returns True if there are two distinct elements in the list that\nsum to zero, and False otherwise.\n>>> pairsSumToZero(Arrays.asList(1, 3, 5, 0))\nfalse\n>>> pairsSumToZero(Arrays.asList(1, 3, -2, 1))\nfalse\n>>> pairsSumToZero(Arrays.asList(1, 2, 3, 7))\nfalse\n>>> pairsSumToZero(Arrays.asList(2, 4, -5, 3, 5, 7))\ntrue\n>>> pairsSumToZero(Arrays.asList(1))\nfalse", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean pairsSumToZero(List<Integer> l) {\n        for (int i = 0; i < l.size(); i++ ) {\n            for (int j = i + 1; j < l.size(); j++ ) {\n                if (l.get(i) + l.get(j) == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/46", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n    >>> fib4(5)\n    4\n    >>> fib4(6)\n    8\n    >>> fib4(7)\n    14\n     */\n    public int fib4(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fib4(int n) {\n", "canonical_solution": "        List<Integer> results = new ArrayList<>();\n        results.add(0);\n        results.add(0);\n        results.add(2);\n        results.add(0);\n        if (n < 4) {\n            return results.get(n);\n        }\n\n        for (int i = 4; i <= n; i++) {\n            results.add(results.get(0) + results.get(1) + results.get(2) + results.get(3));\n            results.remove(0);\n        }\n        return results.get(3);\n    }\n}", "buggy_solution": "        List<Integer> results = new ArrayList<>();\n        results.add(0);\n        results.add(0);\n        results.add(2);\n        results.add(0);\n        if (n < 4) {\n            return results.get(n);\n        }\n\n        for (int i = 4; i <= n; i++) {\n            results.add(results.get(0) + results.get(1) + results.get(2) + results.get(3));\n            results.remove(0);\n        }\n        return results.get(2);\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "fib4", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fib4(5) == 4,\n                s.fib4(8) == 28,\n                s.fib4(10) == 104,\n                s.fib4(12) == 386\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.fib4(5) == 4,\n                s.fib4(6) == 8,\n                s.fib4(7) == 14\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int fib4(int n)", "docstring": "The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nfib4(0) -> 0\nfib4(1) -> 0\nfib4(2) -> 2\nfib4(3) -> 0\nfib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\nPlease write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14", "instruction": "Write a Java function `public int fib4(int n)` to solve the following problem:\nThe Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\nfib4(0) -> 0\nfib4(1) -> 0\nfib4(2) -> 2\nfib4(3) -> 0\nfib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\nPlease write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.\n>>> fib4(5)\n4\n>>> fib4(6)\n8\n>>> fib4(7)\n14", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int fib4(int n) {\n        List<Integer> results = new ArrayList<>();\n        results.add(0);\n        results.add(0);\n        results.add(2);\n        results.add(0);\n        if (n < 4) {\n            return results.get(n);\n        }\n\n        for (int i = 4; i <= n; i++ ) {\n            results.add(results.get(0) + results.get(1) + results.get(2) + results.get(3));\n            results.remove(0);\n        }\n        return results.get(3);\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/48", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Checks if given string is a palindrome\n    >>> isPalindrome(\"\")\n    true\n    >>> isPalindrome(\"aba\")\n    true\n    >>> isPalindrome(\"aaaaa\")\n    true\n    >>> isPalindrome(\"zbcd\")\n    false\n     */\n    public boolean isPalindrome(String text) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isPalindrome(String text) {\n", "canonical_solution": "        for (int i = 0; i < text.length(); i++) {\n            if (text.charAt(i) != text.charAt(text.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "buggy_solution": "        for (int i = 0; i < text.length(); i++) {\n            if (text.charAt(i) != text.charAt(text.length() - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "isPalindrome", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isPalindrome(\"\"),\n                s.isPalindrome(\"aba\"),\n                s.isPalindrome(\"aaaaa\"),\n                !s.isPalindrome(\"zbcd\"),\n                s.isPalindrome(\"xywyx\"),\n                !s.isPalindrome(\"xywyz\"),\n                !s.isPalindrome(\"xywzx\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isPalindrome(\"\"),\n                s.isPalindrome(\"aba\"),\n                s.isPalindrome(\"aaaaa\"),\n                !s.isPalindrome(\"zbcd\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean isPalindrome(String text)", "docstring": "Checks if given string is a palindrome\n>>> isPalindrome(\"\")\ntrue\n>>> isPalindrome(\"aba\")\ntrue\n>>> isPalindrome(\"aaaaa\")\ntrue\n>>> isPalindrome(\"zbcd\")\nfalse", "instruction": "Write a Java function `public boolean isPalindrome(String text)` to solve the following problem:\nChecks if given string is a palindrome\n>>> isPalindrome(\"\")\ntrue\n>>> isPalindrome(\"aba\")\ntrue\n>>> isPalindrome(\"aaaaa\")\ntrue\n>>> isPalindrome(\"zbcd\")\nfalse", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isPalindrome(String text) {\n        for (int i = 0; i < text.length(); i++ ) {\n            if (text.charAt(i) != text.charAt(text.length() - 1 - i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/49", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n     */\n    public int modp(int n, int p) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int modp(int n, int p) {\n", "canonical_solution": "        int ret = 1;\n        for (int i = 0; i < n; i++) {\n            ret = (ret * 2) % p;\n        }\n        return ret;\n    }\n}", "buggy_solution": "        int ret = 0;\n        for (int i = 0; i < n; i++) {\n            ret = (ret * 2) % p;\n        }\n        return ret;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "modp", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.modp(3, 5) == 3,\n                s.modp(1101, 101) == 2,\n                s.modp(0, 101) == 1,\n                s.modp(3, 11) == 8,\n                s.modp(100, 101) == 1,\n                s.modp(30, 5) == 4,\n                s.modp(31, 5) == 3\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.modp(3, 5) == 3,\n                s.modp(1101, 101) == 2,\n                s.modp(0, 101) == 1,\n                s.modp(3, 11) == 8,\n                s.modp(100, 101) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int modp(int n, int p)", "docstring": "Return 2^n modulo p (be aware of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1", "instruction": "Write a Java function `public int modp(int n, int p)` to solve the following problem:\nReturn 2^n modulo p (be aware of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int modp(int n, int p) {\n        int ret = 1;\n        for (int i = 0; i < n; i++ ) {\n            ret = (ret * 2) % p;\n        }\n        return ret;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/59", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largestPrimeFactor(13195)\n    29\n    >>> largestPrimeFactor(2048)\n    2\n     */\n    public int largestPrimeFactor(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int largestPrimeFactor(int n) {\n", "canonical_solution": "        int largest = 1;\n        for (int j = 2; j <= n; j++) {\n            if (n % j == 0) {\n                boolean isPrime = j >= 2;\n                for (int i = 2; i < j - 1; i++) {\n                    if (j % i == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n                if (isPrime) {\n                    largest = Math.max(largest, j);\n                }\n            }\n        }\n        return largest;\n    }\n}", "buggy_solution": "        int largest = 1;\n        for (int j = 2; j <= n; j++) {\n            if (n % j == 0) {\n                boolean isPrime = j >= 2;\n                for (int i = 2; i < j - 1; i++) {\n                    if (n % i == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n                if (isPrime) {\n                    largest = Math.max(largest, j);\n                }\n            }\n        }\n        return largest;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "largestPrimeFactor", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.largestPrimeFactor(15) == 5,\n                s.largestPrimeFactor(27) == 3,\n                s.largestPrimeFactor(63) == 7,\n                s.largestPrimeFactor(330) == 11,\n                s.largestPrimeFactor(13195) == 29\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.largestPrimeFactor(2048) ==2,\n                s.largestPrimeFactor(13195) == 29\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int largestPrimeFactor(int n)", "docstring": "Return the largest prime factor of n. Assume n > 1 and is not a prime.\n>>> largestPrimeFactor(13195)\n29\n>>> largestPrimeFactor(2048)\n2", "instruction": "Write a Java function `public int largestPrimeFactor(int n)` to solve the following problem:\nReturn the largest prime factor of n. Assume n > 1 and is not a prime.\n>>> largestPrimeFactor(13195)\n29\n>>> largestPrimeFactor(2048)\n2", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int largestPrimeFactor(int n) {\n        int largest = 1;\n        for (int j = 2; j <= n; j++ ) {\n            if (n % j == 0) {\n                boolean isPrime = j >= 2;\n                for (int i = 2; i < j - 1; i++ ) {\n                    if (j % i == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n                if (isPrime) {\n                    largest = Math.max(largest, j);\n                }\n            }\n        }\n        return largest;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/60", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    sumToN is a function that sums numbers from 1 to n.\n    >>> sumToN(30)\n    465\n    >>> sumToN(100)\n    5050\n    >>> sumToN(5)\n    15\n    >>> sumToN(10)\n    55\n    >>> sumToN(1)\n    1\n     */\n    public int sumToN(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumToN(int n) {\n", "canonical_solution": "        int result = 0;\n        for (int i = 1; i <= n; i++) {\n            result += i;\n        }\n        return result;\n    }\n}", "buggy_solution": "        int result = 0;\n        for (int i = 1; i < n; i++) {\n            result += i;\n        }\n        return result;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "sumToN", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumToN(1) == 1,\n                s.sumToN(6) == 21,\n                s.sumToN(11) == 66,\n                s.sumToN(30) == 465,\n                s.sumToN(100) == 5050\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumToN(1) == 1,\n                s.sumToN(5) == 15,\n                s.sumToN(10) == 55,\n                s.sumToN(30) == 465,\n                s.sumToN(100) == 5050\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int sumToN(int n)", "docstring": "sumToN is a function that sums numbers from 1 to n.\n>>> sumToN(30)\n465\n>>> sumToN(100)\n5050\n>>> sumToN(5)\n15\n>>> sumToN(10)\n55\n>>> sumToN(1)\n1", "instruction": "Write a Java function `public int sumToN(int n)` to solve the following problem:\nsumToN is a function that sums numbers from 1 to n.\n>>> sumToN(30)\n465\n>>> sumToN(100)\n5050\n>>> sumToN(5)\n15\n>>> sumToN(10)\n55\n>>> sumToN(1)\n1", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumToN(int n) {\n        int result = 0;\n        for (int i = 1; i <= n; i++ ) {\n            result += i;\n        }\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/62", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n    [1, 4, 12, 20]\n    >>> derivative(Arrays.asList(1, 2, 3]))\n    [2, 6]\n     */\n    public List<Integer> derivative(List<Integer> xs) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> derivative(List<Integer> xs) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n}", "buggy_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < xs.size(); i++) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "derivative", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.derivative(new ArrayList<>(Arrays.asList(3, 1, 2, 4, 5))).equals(Arrays.asList(1, 4, 12, 20)),\n                s.derivative(new ArrayList<>(Arrays.asList(1, 2, 3))).equals(Arrays.asList(2, 6)),\n                s.derivative(new ArrayList<>(Arrays.asList(3, 2, 1))).equals(Arrays.asList(2, 2)),\n                s.derivative(new ArrayList<>(Arrays.asList(3, 2, 1, 0, 4))).equals(Arrays.asList(2, 2, 0, 16)),\n                s.derivative(List.of(1)).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.derivative(new ArrayList<>(Arrays.asList(3, 1, 2, 4, 5))).equals(Arrays.asList(1, 4, 12, 20)),\n                s.derivative(new ArrayList<>(Arrays.asList(1, 2, 3))).equals(Arrays.asList(2, 6))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> derivative(List<Integer> xs)", "docstring": "xs represent coefficients of a polynomial.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nReturn derivative of this polynomial in the same form.\n>>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n[1, 4, 12, 20]\n>>> derivative(Arrays.asList(1, 2, 3]))\n[2, 6]", "instruction": "Write a Java function `public List<Integer> derivative(List<Integer> xs)` to solve the following problem:\nxs represent coefficients of a polynomial.\nxs[0] + xs[1] * x + xs[2] * x^2 + ....\nReturn derivative of this polynomial in the same form.\n>>> derivative(Arrays.asList(3, 1, 2, 4, 5))\n[1, 4, 12, 20]\n>>> derivative(Arrays.asList(1, 2, 3]))\n[2, 6]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> derivative(List<Integer> xs) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 1; i < xs.size(); i++ ) {\n            result.add(i * xs.get(i));\n        }\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/68", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it.\n    The plucked node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The plucked node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 3:\n        Input: []\n        Output: []\n\n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n     */\n    public List<Integer> pluck(List<Integer> arr) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        if (arr.size() == 0) {\n            return result;\n        }\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n                if (arr.get(i) < min) {\n                    min = arr.get(i);\n                    minIndex = i;\n                }\n            }\n        }\n        if (minIndex != -1) {\n            result.add(min);\n            result.add(minIndex);\n        }\n        return result;\n    }\n}", "buggy_solution": "        List<Integer> result = new ArrayList<>();\n        if (arr.size() == 0) {\n            return result;\n        }\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for (int i = 0; i < arr.size(); i++) {\n            if (arr.get(i) % 2 == 0) {\n                if (arr.get(i) < min) {\n                    min = arr.get(i);\n                    minIndex = i;\n                }\n            }\n        }\n        if (minIndex != -1) {\n            result.add(minIndex);\n            result.add(min);\n        }\n        return result;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "pluck", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.pluck(new ArrayList<>(Arrays.asList(4, 2, 3))).equals(Arrays.asList(2, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(1, 2, 3))).equals(Arrays.asList(2, 1)),\n                s.pluck(new ArrayList<>(List.of())).equals(List.of()),\n                s.pluck(new ArrayList<>(Arrays.asList(5, 0, 3, 0, 4, 2))).equals(Arrays.asList(0, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(1, 2, 3, 0, 5, 3))).equals(Arrays.asList(0, 3)),\n                s.pluck(new ArrayList<>(Arrays.asList(5, 4, 8, 4, 8))).equals(Arrays.asList(4, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(7, 6, 7, 1))).equals(Arrays.asList(6, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(7, 9, 7, 1))).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.pluck(new ArrayList<>(Arrays.asList(4, 2, 3))).equals(Arrays.asList(2, 1)),\n                s.pluck(new ArrayList<>(Arrays.asList(1, 2, 3))).equals(Arrays.asList(2, 1)),\n                s.pluck(new ArrayList<>(List.of())).equals(List.of()),\n                s.pluck(new ArrayList<>(Arrays.asList(5, 0, 3, 0, 4, 2))).equals(Arrays.asList(0, 1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> pluck(List<Integer> arr)", "docstring": "\"Given an array representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\nThe plucked node should be returned in a list, [ smalest_value, its index ],\nIf there are no even values or the given array is empty, return [].\nExample 1:\nInput: [4,2,3]\nOutput: [2, 1]\nExplanation: 2 has the smallest even value, and 2 has the smallest index.\nExample 2:\nInput: [1,2,3]\nOutput: [2, 1]\nExplanation: 2 has the smallest even value, and 2 has the smallest index.\nExample 3:\nInput: []\nOutput: []\nExample 4:\nInput: [5, 0, 3, 0, 4, 2]\nOutput: [0, 1]\nExplanation: 0 is the smallest value, but  there are two zeros,\nso we will choose the first zero, which has the smallest index.\nConstraints:\n* 1 <= nodes.length <= 10000\n* 0 <= node.value", "instruction": "Write a Java function `public List<Integer> pluck(List<Integer> arr)` to solve the following problem:\n\"Given an array representing a branch of a tree that has non-negative integer nodes\nyour task is to pluck one of the nodes and return it.\nThe plucked node should be the node with the smallest even value.\nIf multiple nodes with the same smallest even value are found return the node that has smallest index.\nThe plucked node should be returned in a list, [ smalest_value, its index ],\nIf there are no even values or the given array is empty, return [].\nExample 1:\nInput: [4,2,3]\nOutput: [2, 1]\nExplanation: 2 has the smallest even value, and 2 has the smallest index.\nExample 2:\nInput: [1,2,3]\nOutput: [2, 1]\nExplanation: 2 has the smallest even value, and 2 has the smallest index.\nExample 3:\nInput: []\nOutput: []\nExample 4:\nInput: [5, 0, 3, 0, 4, 2]\nOutput: [0, 1]\nExplanation: 0 is the smallest value, but  there are two zeros,\nso we will choose the first zero, which has the smallest index.\nConstraints:\n* 1 <= nodes.length <= 10000\n* 0 <= node.value", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> pluck(List<Integer> arr) {\n        List<Integer> result = new ArrayList<>();\n        if (arr.size() == 0) {\n            return result;\n        }\n        int min = Integer.MAX_VALUE;\n        int minIndex = -1;\n        for (int i = 0; i < arr.size(); i++ ) {\n            if (arr.get(i) % 2 == 0) {\n                if (arr.get(i) < min) {\n                    min = arr.get(i);\n                    minIndex = i;\n                }\n            }\n        }\n        if (minIndex != -1) {\n            result.add(min);\n            result.add(minIndex);\n        }\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/69", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than\n    zero, and has a frequency greater than or equal to the value of the integer itself.\n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\n        search(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\n        search(Arrays.asList(5, 5, 4, 4, 4)) == -1\n     */\n    public int search(List<Integer> lst) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n", "canonical_solution": "        int[] frq = new int[Collections.max(lst) + 1];\n        for (int i : lst) {\n            frq[i] += 1;\n        }\n        int ans = -1;\n        for (int i = 1; i < frq.length; i++) {\n            if (frq[i] >= i) {\n                ans = i;\n            }\n        }\n        return ans;\n    }\n}", "buggy_solution": "        int[] frq = new int[Collections.max(lst) + 1];\n        for (int i : lst) {\n            frq[i] += 1;\n        }\n        int ans = 0;\n        for (int i = 1; i < frq.length; i++) {\n            if (frq[i] >= i) {\n                ans = i;\n            }\n        }\n        return ans;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "search", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.search(new ArrayList<>(Arrays.asList(5, 5, 5, 5, 1))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(4, 1, 4, 1, 4, 4))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(3, 3))) == -1,\n                s.search(new ArrayList<>(Arrays.asList(8, 8, 8, 8, 8, 8, 8, 8))) == 8,\n                s.search(new ArrayList<>(Arrays.asList(2, 3, 3, 2, 2))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(2, 7, 8, 8, 4, 8, 7, 3, 9, 6, 5, 10, 4, 3, 6, 7, 1, 7, 4, 10, 8, 1))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(3, 2, 8, 2))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(6, 7, 1, 8, 8, 10, 5, 8, 5, 3, 10))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(8, 8, 3, 6, 5, 6, 4))) == -1,\n                s.search(new ArrayList<>(Arrays.asList(6, 9, 6, 7, 1, 4, 7, 1, 8, 8, 9, 8, 10, 10, 8, 4, 10, 4, 10, 1, 2, 9, 5, 7, 9))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(1, 9, 10, 1, 3))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(6, 9, 7, 5, 8, 7, 5, 3, 7, 5, 10, 10, 3, 6, 10, 2, 8, 6, 5, 4, 9, 5, 3, 10))) == 5,\n                s.search(new ArrayList<>(List.of(1))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(8, 8, 10, 6, 4, 3, 5, 8, 2, 4, 2, 8, 4, 6, 10, 4, 2, 1, 10, 2, 1, 1, 5))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(2, 10, 4, 8, 2, 10, 5, 1, 2, 9, 5, 5, 6, 3, 8, 6, 4, 10))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(1, 6, 10, 1, 6, 9, 10, 8, 6, 8, 7, 3))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(9, 2, 4, 1, 5, 1, 5, 2, 5, 7, 7, 7, 3, 10, 1, 5, 4, 2, 8, 4, 1, 9, 10, 7, 10, 2, 8, 10, 9, 4))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(2, 6, 4, 2, 8, 7, 5, 6, 4, 10, 4, 6, 3, 7, 8, 8, 3, 1, 4, 2, 2, 10, 7))) == 4,\n                s.search(new ArrayList<>(Arrays.asList(9, 8, 6, 10, 2, 6, 10, 2, 7, 8, 10, 3, 8, 2, 6, 2, 3, 1))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(5, 5, 3, 9, 5, 6, 3, 2, 8, 5, 6, 10, 10, 6, 8, 4, 10, 7, 7, 10, 8))) == -1,\n                s.search(new ArrayList<>(List.of(10))) == -1,\n                s.search(new ArrayList<>(Arrays.asList(9, 7, 7, 2, 4, 7, 2, 10, 9, 7, 5, 7, 2))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(5, 4, 10, 2, 1, 1, 10, 3, 6, 1, 8))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(7, 9, 9, 9, 3, 4, 1, 5, 9, 1, 2, 1, 1, 10, 7, 5, 6, 7, 6, 7, 7, 6))) == 1,\n                s.search(new ArrayList<>(Arrays.asList(3, 10, 10, 9, 2))) == -1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.search(new ArrayList<>(Arrays.asList(4, 1, 2, 2, 3, 1))) == 2,\n                s.search(new ArrayList<>(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4))) == 3,\n                s.search(new ArrayList<>(Arrays.asList(5, 5, 4, 4, 4))) == -1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int search(List<Integer> lst)", "docstring": "You are given a non-empty list of positive integers. Return the greatest integer that is greater than\nzero, and has a frequency greater than or equal to the value of the integer itself.\nThe frequency of an integer is the number of times it appears in the list.\nIf no such a value exist, return -1.\nExamples:\nsearch(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\nsearch(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\nsearch(Arrays.asList(5, 5, 4, 4, 4)) == -1", "instruction": "Write a Java function `public int search(List<Integer> lst)` to solve the following problem:\nYou are given a non-empty list of positive integers. Return the greatest integer that is greater than\nzero, and has a frequency greater than or equal to the value of the integer itself.\nThe frequency of an integer is the number of times it appears in the list.\nIf no such a value exist, return -1.\nExamples:\nsearch(Arrays.asList(4, 1, 2, 2, 3, 1)) == 2\nsearch(Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4)) == 3\nsearch(Arrays.asList(5, 5, 4, 4, 4)) == -1", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int search(List<Integer> lst) {\n        int[] frq = new int[Collections.max(lst) + 1];\n        for (int i : lst) {\n            frq[i] += 1;\n        }\n        int ans = -1;\n        for (int i = 1; i < frq.length; i++ ) {\n            if (frq[i] >= i) {\n                ans = i;\n            }\n        }\n        return ans;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/73", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallestChange(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\n    smallestChange(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\n    smallestChange(Arrays.asList(1, 2, 3, 2, 1)) == 0\n     */\n    public int smallestChange(List<Integer> arr) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallestChange(List<Integer> arr) {\n", "canonical_solution": "        int ans = 0;\n        for (int i = 0; i < arr.size() / 2; i++) {\n            if (!Objects.equals(arr.get(i), arr.get(arr.size() - i - 1))) {\n                ans += 1;\n            }\n        }\n        return ans;\n    }\n}", "buggy_solution": "        int ans = 0;\n        for (int i = 0; i < arr.size() / 2; i++) {\n            if (!Objects.equals(ans, arr.get(arr.size() - i - 1))) {\n                ans += 1;\n            }\n        }\n        return ans;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "smallestChange", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))) == 4,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 3, 2, 2))) == 1,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 4, 2))) == 1,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 4, 4, 2))) == 1,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 2, 1))) == 0,\n                s.smallestChange(new ArrayList<>(Arrays.asList(3, 1, 1, 3))) == 0,\n                s.smallestChange(new ArrayList<>(List.of(1))) == 0,\n                s.smallestChange(new ArrayList<>(Arrays.asList(0, 1))) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 5, 4, 7, 9, 6))) == 4,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 3, 2, 2))) == 1,\n                s.smallestChange(new ArrayList<>(Arrays.asList(1, 2, 3, 2, 1))) == 0,\n                s.smallestChange(new ArrayList<>(Arrays.asList(3, 1, 1, 3))) == 0\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int smallestChange(List<Integer> arr)", "docstring": "Given an array arr of integers, find the minimum number of elements that\nneed to be changed to make the array palindromic. A palindromic array is an array that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\nFor example:\nsmallestChange(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\nsmallestChange(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\nsmallestChange(Arrays.asList(1, 2, 3, 2, 1)) == 0", "instruction": "Write a Java function `public int smallestChange(List<Integer> arr)` to solve the following problem:\nGiven an array arr of integers, find the minimum number of elements that\nneed to be changed to make the array palindromic. A palindromic array is an array that\nis read the same backwards and forwards. In one change, you can change one element to any other element.\nFor example:\nsmallestChange(Arrays.asList(1,2,3,5,4,7,9,6)) == 4\nsmallestChange(Arrays.asList(1, 2, 3, 4, 3, 2, 2)) == 1\nsmallestChange(Arrays.asList(1, 2, 3, 2, 1)) == 0", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int smallestChange(List<Integer> arr) {\n        int ans = 0;\n        for (int i = 0; i < arr.size() / 2; i++ ) {\n            if (!Objects.equals(arr.get(i), arr.get(arr.size() - i - 1))) {\n                ans += 1;\n            }\n        }\n        return ans;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/75", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100.\n    Example:\n    isMultiplyPrime(30) == true\n    30 = 2 * 3 * 5\n     */\n    public boolean isMultiplyPrime(int a) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isMultiplyPrime(int a) {\n", "canonical_solution": "        class IsPrime {\n            public static boolean isPrime(int n) {\n                for (int j = 2; j < n; j++) {\n                    if (n % j == 0) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        for (int i = 2; i < 101; i++) {\n            if (!IsPrime.isPrime(i)) {\n                continue;\n            }\n            for (int j = i; j < 101; j++) {\n                if (!IsPrime.isPrime(j)) {\n                    continue;\n                }\n                for (int k = j; k < 101; k++) {\n                    if (!IsPrime.isPrime(k)) {\n                        continue;\n                    }\n                    if (i * j * k == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}", "buggy_solution": "        class IsPrime {\n            public static boolean isPrime(int n) {\n                for (int j = 0; j < n; j++) {\n                    if (n % j == 0) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        for (int i = 2; i < 101; i++) {\n            if (!IsPrime.isPrime(i)) {\n                continue;\n            }\n            for (int j = i; j < 101; j++) {\n                if (!IsPrime.isPrime(j)) {\n                    continue;\n                }\n                for (int k = j; k < 101; k++) {\n                    if (!IsPrime.isPrime(k)) {\n                        continue;\n                    }\n                    if (i * j * k == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "isMultiplyPrime", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isMultiplyPrime(5),\n                s.isMultiplyPrime(30),\n                s.isMultiplyPrime(8),\n                !s.isMultiplyPrime(10),\n                s.isMultiplyPrime(125),\n                s.isMultiplyPrime(3 * 5 * 7),\n                !s.isMultiplyPrime(3 * 6 * 7),\n                !s.isMultiplyPrime(9 * 9 * 9),\n                !s.isMultiplyPrime(11 * 9 * 9),\n                s.isMultiplyPrime(11 * 13 * 7)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isMultiplyPrime(30)\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean isMultiplyPrime(int a)", "docstring": "Write a function that returns true if the given number is the multiplication of 3 prime numbers\nand false otherwise.\nKnowing that (a) is less then 100.\nExample:\nisMultiplyPrime(30) == true\n30 = 2 * 3 * 5", "instruction": "Write a Java function `public boolean isMultiplyPrime(int a)` to solve the following problem:\nWrite a function that returns true if the given number is the multiplication of 3 prime numbers\nand false otherwise.\nKnowing that (a) is less then 100.\nExample:\nisMultiplyPrime(30) == true\n30 = 2 * 3 * 5", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isMultiplyPrime(int a) {\n        class IsPrime {\n            public static boolean isPrime(int n) {\n                for (int j = 2; j < n; j++ ) {\n                    if (n % j == 0) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        for (int i = 2; i < 101; i++ ) {\n            if (!IsPrime.isPrime(i)) {\n                continue;\n            }\n            for (int j = i; j < 101; j++ ) {\n                if (!IsPrime.isPrime(j)) {\n                    continue;\n                }\n                for (int k = j; k < 101; k++ ) {\n                    if (!IsPrime.isPrime(k)) {\n                        continue;\n                    }\n                    if (i * j * k == a) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/80", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    isHappy(a) => false\n    isHappy(aa) => false\n    isHappy(abcd) => true\n    isHappy(aabb) => false\n    isHappy(adb) => true\n    isHappy(xyy) => false\n     */\n    public boolean isHappy(String s) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isHappy(String s) {\n", "canonical_solution": "        if (s.length() < 3) {\n            return false;\n        }\n\n        for (int i = 0; i < s.length() - 2; i++) {\n            if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i + 1) == s.charAt(i + 2) || s.charAt(i) == s.charAt(i + 2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "buggy_solution": "        if (s.length() < 3) {\n            return false;\n        }\n\n        for (int i = 0; i < s.length() - 2; i++) {\n            if (s.charAt(i) == s.charAt(i + 1) && s.charAt(i + 1) == s.charAt(i + 2) && s.charAt(i) == s.charAt(i + 2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "bug_type": "operator misuse", "failure_symptoms": "incorrect output", "entry_point": "isHappy", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isHappy(\"a\"),\n                !s.isHappy(\"aa\"),\n                s.isHappy(\"abcd\"),\n                !s.isHappy(\"aabb\"),\n                s.isHappy(\"adb\"),\n                !s.isHappy(\"xyy\"),\n                s.isHappy(\"iopaxpoi\"),\n                !s.isHappy(\"iopaxioi\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                !s.isHappy(\"a\"),\n                !s.isHappy(\"aa\"),\n                s.isHappy(\"abcd\"),\n                !s.isHappy(\"aabb\"),\n                s.isHappy(\"adb\"),\n                !s.isHappy(\"xyy\")\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean isHappy(String s)", "docstring": "You are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nisHappy(a) => false\nisHappy(aa) => false\nisHappy(abcd) => true\nisHappy(aabb) => false\nisHappy(adb) => true\nisHappy(xyy) => false", "instruction": "Write a Java function `public boolean isHappy(String s)` to solve the following problem:\nYou are given a string s.\nYour task is to check if the string is happy or not.\nA string is happy if its length is at least 3 and every 3 consecutive letters are distinct\nFor example:\nisHappy(a) => false\nisHappy(aa) => false\nisHappy(abcd) => true\nisHappy(aabb) => false\nisHappy(adb) => true\nisHappy(xyy) => false", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isHappy(String s) {\n        if (s.length() < 3) {\n            return false;\n        }\n\n        for (int i = 0; i < s.length() - 2; i++ ) {\n            if (s.charAt(i) == s.charAt(i + 1) || s.charAt(i + 1) == s.charAt(i + 2) || s.charAt(i) == s.charAt(i + 2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/82", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function that takes a string and returns true if the string\n    length is a prime number or false otherwise\n    Examples\n    primeLength(\"Hello\") == true\n    primeLength(\"abcdcba\") == true\n    primeLength(\"kittens\") == true\n    primeLength(\"orange\") == false\n     */\n    public boolean primeLength(String string) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean primeLength(String string) {\n", "canonical_solution": "        int l = string.length();\n        if (l == 0 || l == 1) {\n            return false;\n        }\n        for (int i = 2; i < l; i++) {\n            if (l % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "buggy_solution": "        int l = string.length();\n        if (l == 0 || l == 1) {\n            return false;\n        }\n        for (int i = 3; i < l; i++) {\n            if (l % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "primeLength", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.primeLength(\"Hello\") == true,\n                s.primeLength(\"abcdcba\") == true,\n                s.primeLength(\"kittens\") == true,\n                s.primeLength(\"orange\") == false,\n                s.primeLength(\"wow\") == true,\n                s.primeLength(\"world\") == true,\n                s.primeLength(\"MadaM\") == true,\n                s.primeLength(\"Wow\") == true,\n                s.primeLength(\"\") == false,\n                s.primeLength(\"HI\") == true,\n                s.primeLength(\"go\") == true,\n                s.primeLength(\"gogo\") == false,\n                s.primeLength(\"aaaaaaaaaaaaaaa\") == false,\n                s.primeLength(\"Madam\") == true,\n                s.primeLength(\"M\") == false,\n                s.primeLength(\"0\") == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.primeLength(\"Hello\") == true,\n                s.primeLength(\"abcdcba\") == true,\n                s.primeLength(\"kittens\") == true,\n                s.primeLength(\"orange\") == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean primeLength(String string)", "docstring": "Write a function that takes a string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprimeLength(\"Hello\") == true\nprimeLength(\"abcdcba\") == true\nprimeLength(\"kittens\") == true\nprimeLength(\"orange\") == false", "instruction": "Write a Java function `public boolean primeLength(String string)` to solve the following problem:\nWrite a function that takes a string and returns true if the string\nlength is a prime number or false otherwise\nExamples\nprimeLength(\"Hello\") == true\nprimeLength(\"abcdcba\") == true\nprimeLength(\"kittens\") == true\nprimeLength(\"orange\") == false", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean primeLength(String string) {\n        int l = string.length();\n        if (l == 0 || l == 1) {\n            return false;\n        }\n        for (int i = 2; i < l; i++ ) {\n            if (l % i == 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/87", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of lists, [[x1, y1], [x2, y2] ...] such that\n    each list is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n\n    Examples:\n    getRow([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\n    getRow([], 1) == []\n    getRow([[], [1], [1, 2, 3]], 3) == [[2, 2]]\n     */\n    public List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n", "canonical_solution": "        List<List<Integer>> coords = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            List<List<Integer>> row = new ArrayList<>();\n            for (int j = lst.get(i).size() - 1; j >= 0; j--) {\n                if (lst.get(i).get(j) == x) {\n                    row.add(Arrays.asList(i, j));\n                }\n            }\n            coords.addAll(row);\n        }\n        return coords;\n    }\n}", "buggy_solution": "        List<List<Integer>> coords = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            List<List<Integer>> row = new ArrayList<>();\n            for (int j = lst.get(i).size() - 1; j >= 0; j--) {\n                if (lst.get(i).get(j) == x) {\n                    row.add(Arrays.asList(j, i));\n                }\n            }\n            coords.addAll(row);\n        }\n        return coords;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "getRow", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getRow(Arrays.asList(\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 1, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 1)\n                ), 1).equals(Arrays.asList(Arrays.asList(0, 0), Arrays.asList(1, 4), Arrays.asList(1, 0), Arrays.asList(2, 5), Arrays.asList(2, 0))),\n                s.getRow(Arrays.asList(\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6)\n                ), 2).equals(Arrays.asList(Arrays.asList(0, 1), Arrays.asList(1, 1), Arrays.asList(2, 1), Arrays.asList(3, 1), Arrays.asList(4, 1), Arrays.asList(5, 1))),\n                s.getRow(Arrays.asList(\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 1, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 1, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 1, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 1, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 1)\n                ), 1).equals(Arrays.asList(Arrays.asList(0, 0), Arrays.asList(1, 0), Arrays.asList(2, 1), Arrays.asList(2, 0), Arrays.asList(3, 2), Arrays.asList(3, 0), Arrays.asList(4, 3), Arrays.asList(4, 0), Arrays.asList(5, 4), Arrays.asList(5, 0), Arrays.asList(6, 5), Arrays.asList(6, 0))),\n                s.getRow(List.of(), 1).equals(List.of()),\n                s.getRow(List.of(List.of(1)), 2).equals(List.of()),\n                s.getRow(Arrays.asList(List.of(), List.of(1), Arrays.asList(1, 2, 3)), 3).equals(List.of(Arrays.asList(2, 2)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getRow(Arrays.asList(\n                        Arrays.asList(1, 2, 3, 4, 5, 6),\n                        Arrays.asList(1, 2, 3, 4, 1, 6),\n                        Arrays.asList(1, 2, 3, 4, 5, 1)\n                ), 1).equals(Arrays.asList(Arrays.asList(0, 0), Arrays.asList(1, 4), Arrays.asList(1, 0), Arrays.asList(2, 5), Arrays.asList(2, 0))),\n                s.getRow(List.of(), 1).equals(List.of()),\n                s.getRow(Arrays.asList(List.of(), List.of(1), Arrays.asList(1, 2, 3)), 3).equals(List.of(Arrays.asList(2, 2)))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<List<Integer>> getRow(List<List<Integer>> lst, int x)", "docstring": "You are given a 2 dimensional data, as a nested lists,\nwhich is similar to matrix, however, unlike matrices,\neach row may contain a different number of columns.\nGiven lst, and integer x, find integers x in the list,\nand return list of lists, [[x1, y1], [x2, y2] ...] such that\neach list is a coordinate - (row, columns), starting with 0.\nSort coordinates initially by rows in ascending order.\nAlso, sort coordinates of the row by columns in descending order.\nExamples:\ngetRow([\n[1,2,3,4,5,6],\n[1,2,3,4,1,6],\n[1,2,3,4,5,1]\n], 1) == [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\ngetRow([], 1) == []\ngetRow([[], [1], [1, 2, 3]], 3) == [[2, 2]]", "instruction": "Write a Java function `public List<List<Integer>> getRow(List<List<Integer>> lst, int x)` to solve the following problem:\nYou are given a 2 dimensional data, as a nested lists,\nwhich is similar to matrix, however, unlike matrices,\neach row may contain a different number of columns.\nGiven lst, and integer x, find integers x in the list,\nand return list of lists, [[x1, y1], [x2, y2] ...] such that\neach list is a coordinate - (row, columns), starting with 0.\nSort coordinates initially by rows in ascending order.\nAlso, sort coordinates of the row by columns in descending order.\nExamples:\ngetRow([\n[1,2,3,4,5,6],\n[1,2,3,4,1,6],\n[1,2,3,4,5,1]\n], 1) == [[0, 0], [1, 4], [1, 0], [2, 5], [2, 0]]\ngetRow([], 1) == []\ngetRow([[], [1], [1, 2, 3]], 3) == [[2, 2]]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<List<Integer>> getRow(List<List<Integer>> lst, int x) {\n        List<List<Integer>> coords = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++ ) {\n            List<List<Integer>> row = new ArrayList<>();\n            for (int j = lst.get(i).size() - 1; j >= 0; j--) {\n                if (lst.get(i).get(j) == x) {\n                    row.add(Arrays.asList(i, j));\n                }\n            }\n            coords.addAll(row);\n        }\n        return coords;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/94", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n     */\n    public int skjkasdkd(List<Integer> lst) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int skjkasdkd(List<Integer> lst) {\n", "canonical_solution": "        int maxx = 0;\n        for (int i : lst) {\n            if (i > maxx) {\n                boolean isPrime = i != 1;\n                for (int j = 2; j < Math.sqrt(i) + 1; j++) {\n                    if (i % j == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n                if (isPrime) {\n                    maxx = i;\n                }\n            }\n        }\n        int sum = 0;\n        for (char c : String.valueOf(maxx).toCharArray()) {\n            sum += (c - '0');\n        }\n        return sum;\n    }\n}", "buggy_solution": "        int maxx = 0;\n        for (int i : lst) {\n            if (i > maxx) {\n                boolean isPrime = i != 1;\n                for (int j = 2; j < Math.sqrt(i) + 1; j++) {\n                    if (i % j == 0) {\n                        isPrime = true;\n                        break;\n                    }\n                }\n                if (isPrime) {\n                    maxx = i;\n                }\n            }\n        }\n        int sum = 0;\n        for (char c : String.valueOf(maxx).toCharArray()) {\n            sum += (c - '0');\n        }\n        return sum;\n    }\n}", "bug_type": "operator misuse", "failure_symptoms": "incorrect output", "entry_point": "skjkasdkd", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.skjkasdkd(Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)) == 10,\n                s.skjkasdkd(Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)) == 25,\n                s.skjkasdkd(Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)) == 13,\n                s.skjkasdkd(Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)) == 11,\n                s.skjkasdkd(Arrays.asList(0, 81, 12, 3, 1, 21)) == 3,\n                s.skjkasdkd(Arrays.asList(0, 8, 1, 2, 1, 7)) == 7,\n                s.skjkasdkd(List.of(8191)) == 19,\n                s.skjkasdkd(Arrays.asList(8191, 123456, 127, 7)) == 19,\n                s.skjkasdkd(Arrays.asList(127, 97, 8192)) == 10\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.skjkasdkd(Arrays.asList(0, 3, 2, 1, 3, 5, 7, 4, 5, 5, 5, 2, 181, 32, 4, 32, 3, 2, 32, 324, 4, 3)) == 10,\n                s.skjkasdkd(Arrays.asList(1, 0, 1, 8, 2, 4597, 2, 1, 3, 40, 1, 2, 1, 2, 4, 2, 5, 1)) == 25,\n                s.skjkasdkd(Arrays.asList(1, 3, 1, 32, 5107, 34, 83278, 109, 163, 23, 2323, 32, 30, 1, 9, 3)) == 13,\n                s.skjkasdkd(Arrays.asList(0, 724, 32, 71, 99, 32, 6, 0, 5, 91, 83, 0, 5, 6)) == 11,\n                s.skjkasdkd(Arrays.asList(0, 81, 12, 3, 1, 21)) == 3,\n                s.skjkasdkd(Arrays.asList(0, 8, 1, 2, 1, 7)) == 7\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int skjkasdkd(List<Integer> lst)", "docstring": "You are given a list of integers.\nYou need to find the largest prime value and return the sum of its digits.\nExamples:\nFor lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\nFor lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\nFor lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\nFor lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\nFor lst = [0,81,12,3,1,21] the output should be 3\nFor lst = [0,8,1,2,1,7] the output should be 7", "instruction": "Write a Java function `public int skjkasdkd(List<Integer> lst)` to solve the following problem:\nYou are given a list of integers.\nYou need to find the largest prime value and return the sum of its digits.\nExamples:\nFor lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\nFor lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\nFor lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\nFor lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\nFor lst = [0,81,12,3,1,21] the output should be 3\nFor lst = [0,8,1,2,1,7] the output should be 7", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int skjkasdkd(List<Integer> lst) {\n        int maxx = 0;\n        for (int i : lst) {\n            if (i > maxx) {\n                boolean isPrime = i != 1;\n                for (int j = 2; j < Math.sqrt(i) + 1; j++ ) {\n                    if (i % j == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n                if (isPrime) {\n                    maxx = i;\n                }\n            }\n        }\n        int sum = 0;\n        for (char c : String.valueOf(maxx).toCharArray()) {\n            sum += (c - '0');\n        }\n        return sum;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/96", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    countUpTo(5) => [2,3]\n    countUpTo(11) => [2,3,5,7]\n    countUpTo(0) => []\n    countUpTo(20) => [2,3,5,7,11,13,17,19]\n    countUpTo(1) => []\n    countUpTo(18) => [2,3,5,7,11,13,17]\n     */\n    public List<Integer> countUpTo(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> countUpTo(int n) {\n", "canonical_solution": "        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            boolean isPrime = true;\n            for (int j = 2; j < i; j++) {\n                if (i % j == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}", "buggy_solution": "        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++) {\n            boolean isPrime = true;\n            for (int j = 2; j < i; j++) {\n                if (j % i == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "countUpTo", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.countUpTo(5).equals(Arrays.asList(2, 3)),\n                s.countUpTo(6).equals(Arrays.asList(2, 3, 5)),\n                s.countUpTo(7).equals(Arrays.asList(2, 3, 5)),\n                s.countUpTo(10).equals(Arrays.asList(2, 3, 5, 7)),\n                s.countUpTo(0).equals(List.of()),\n                s.countUpTo(22).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19)),\n                s.countUpTo(1).equals(List.of()),\n                s.countUpTo(18).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17)),\n                s.countUpTo(47).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43)),\n                s.countUpTo(101).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.countUpTo(5).equals(Arrays.asList(2, 3)),\n                s.countUpTo(11).equals(Arrays.asList(2, 3, 5, 7)),\n                s.countUpTo(0).equals(List.of()),\n                s.countUpTo(20).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19)),\n                s.countUpTo(1).equals(List.of()),\n                s.countUpTo(18).equals(Arrays.asList(2, 3, 5, 7, 11, 13, 17))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> countUpTo(int n)", "docstring": "Implement a function that takes an non-negative integer and returns an array of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncountUpTo(5) => [2,3]\ncountUpTo(11) => [2,3,5,7]\ncountUpTo(0) => []\ncountUpTo(20) => [2,3,5,7,11,13,17,19]\ncountUpTo(1) => []\ncountUpTo(18) => [2,3,5,7,11,13,17]", "instruction": "Write a Java function `public List<Integer> countUpTo(int n)` to solve the following problem:\nImplement a function that takes an non-negative integer and returns an array of the first n\nintegers that are prime numbers and less than n.\nfor example:\ncountUpTo(5) => [2,3]\ncountUpTo(11) => [2,3,5,7]\ncountUpTo(0) => []\ncountUpTo(20) => [2,3,5,7,11,13,17,19]\ncountUpTo(1) => []\ncountUpTo(18) => [2,3,5,7,11,13,17]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> countUpTo(int n) {\n        List<Integer> primes = new ArrayList<>();\n        for (int i = 2; i < n; i++ ) {\n            boolean isPrime = true;\n            for (int j = 2; j < i; j++ ) {\n                if (i % j == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            if (isPrime) {\n                primes.add(i);\n            }\n        }\n        return primes;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/100", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> makeAPile(3)\n    [3, 5, 7]\n     */\n    public List<Integer> makeAPile(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> makeAPile(int n) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            result.add(n + 2 * i);\n        }\n        return result;\n    }\n}", "buggy_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            result.add(n + 2 * i + i);\n        }\n        return result;\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "makeAPile", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.makeAPile(3).equals(Arrays.asList(3, 5, 7)),\n                s.makeAPile(4).equals(Arrays.asList(4, 6, 8, 10)),\n                s.makeAPile(5).equals(Arrays.asList(5, 7, 9, 11, 13)),\n                s.makeAPile(6).equals(Arrays.asList(6, 8, 10, 12, 14, 16)),\n                s.makeAPile(8).equals(Arrays.asList(8, 10, 12, 14, 16, 18, 20, 22))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.makeAPile(3).equals(Arrays.asList(3, 5, 7))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> makeAPile(int n)", "docstring": "Given a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n- the next odd number if n is odd.\n- the next even number if n is even.\nReturn the number of stones in each level in a list, where element at index\ni represents the number of stones in the level (i+1).\nExamples:\n>>> makeAPile(3)\n[3, 5, 7]", "instruction": "Write a Java function `public List<Integer> makeAPile(int n)` to solve the following problem:\nGiven a positive integer n, you have to make a pile of n levels of stones.\nThe first level has n stones.\nThe number of stones in the next level is:\n- the next odd number if n is odd.\n- the next even number if n is even.\nReturn the number of stones in each level in a list, where element at index\ni represents the number of stones in the level (i+1).\nExamples:\n>>> makeAPile(3)\n[3, 5, 7]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> makeAPile(int n) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < n; i++ ) {\n            result.add(n + 2 * i);\n        }\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/106", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Implement the function f that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    f(5) == [1, 2, 6, 24, 15]\n     */\n    public List<Integer> f(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> f(int n) {\n", "canonical_solution": "        List<Integer> ret = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                int x = 1;\n                for (int j = 1; j <= i; j++) {\n                    x *= j;\n                }\n                ret.add(x);\n            } else {\n                int x = 0;\n                for (int j = 1; j <= i; j++) {\n                    x += j;\n                }\n                ret.add(x);\n            }\n        }\n        return ret;\n    }\n}", "buggy_solution": "        List<Integer> ret = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            if (i % 2 == 0) {\n                int x = 1;\n                for (int j = 1; j <= i; j++) {\n                    x *= i;\n                }\n                ret.add(x);\n            } else {\n                int x = 0;\n                for (int j = 1; j <= i; j++) {\n                    x += j;\n                }\n                ret.add(x);\n            }\n        }\n        return ret;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "f", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.f(5).equals(Arrays.asList(1, 2, 6, 24, 15)),\n                s.f(7).equals(Arrays.asList(1, 2, 6, 24, 15, 720, 28)),\n                s.f(1).equals(List.of(1)),\n                s.f(3).equals(Arrays.asList(1, 2, 6))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.f(5).equals(Arrays.asList(1, 2, 6, 24, 15))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> f(int n)", "docstring": "Implement the function f that takes n as a parameter,\nand returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\nor the sum of numbers from 1 to i otherwise.\ni starts from 1.\nthe factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\nExample:\nf(5) == [1, 2, 6, 24, 15]", "instruction": "Write a Java function `public List<Integer> f(int n)` to solve the following problem:\nImplement the function f that takes n as a parameter,\nand returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\nor the sum of numbers from 1 to i otherwise.\ni starts from 1.\nthe factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\nExample:\nf(5) == [1, 2, 6, 24, 15]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> f(int n) {\n        List<Integer> ret = new ArrayList<>();\n        for (int i = 1; i <= n; i++ ) {\n            if (i % 2 == 0) {\n                int x = 1;\n                for (int j = 1; j <= i; j++ ) {\n                    x *= j;\n                }\n                ret.add(x);\n            } else {\n                int x = 0;\n                for (int j = 1; j <= i; j++ ) {\n                    x += j;\n                }\n                ret.add(x);\n            }\n        }\n        return ret;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/107", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n     */\n    public List<Integer> evenOddPalindrome(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> evenOddPalindrome(int n) {\n", "canonical_solution": "        int evenPalindromeCount = 0, oddPalindromeCount = 0;\n\n        for (int i = 1; i <= n; i++) {\n            if (String.valueOf(i).equals(new StringBuilder(String.valueOf(i)).reverse().toString())) {\n                if (i % 2 == 1) {\n                    oddPalindromeCount += 1;\n                } else {\n                    evenPalindromeCount += 1;\n                }\n            }\n        }\n        return Arrays.asList(evenPalindromeCount, oddPalindromeCount);\n    }\n}", "buggy_solution": "        int evenPalindromeCount = 0, oddPalindromeCount = 0;\n\n        for (int i = 1; i < n; i++) {\n            if (String.valueOf(i).equals(new StringBuilder(String.valueOf(i)).reverse().toString())) {\n                if (i % 2 == 1) {\n                    oddPalindromeCount += 1;\n                } else {\n                    evenPalindromeCount += 1;\n                }\n            }\n        }\n        return Arrays.asList(evenPalindromeCount, oddPalindromeCount);\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "evenOddPalindrome", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.evenOddPalindrome(123).equals(Arrays.asList(8, 13)),\n                s.evenOddPalindrome(12).equals(Arrays.asList(4, 6)),\n                s.evenOddPalindrome(3).equals(Arrays.asList(1, 2)),\n                s.evenOddPalindrome(63).equals(Arrays.asList(6, 8)),\n                s.evenOddPalindrome(25).equals(Arrays.asList(5, 6)),\n                s.evenOddPalindrome(19).equals(Arrays.asList(4, 6)),\n                s.evenOddPalindrome(9).equals(Arrays.asList(4, 5)),\n                s.evenOddPalindrome(1).equals(Arrays.asList(0, 1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.evenOddPalindrome(12).equals(Arrays.asList(4, 6)),\n                s.evenOddPalindrome(3).equals(Arrays.asList(1, 2))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> evenOddPalindrome(int n)", "docstring": "Given a positive integer n, return a tuple that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\nExample 1:\nInput: 3\nOutput: (1, 2)\nExplanation:\nInteger palindrome are 1, 2, 3. one of them is even, and two of them are odd.\nExample 2:\nInput: 12\nOutput: (4, 6)\nExplanation:\nInteger palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\nNote:\n1. 1 <= n <= 10^3\n2. returned tuple has the number of even and odd integer palindromes respectively.", "instruction": "Write a Java function `public List<Integer> evenOddPalindrome(int n)` to solve the following problem:\nGiven a positive integer n, return a tuple that has the number of even and odd\ninteger palindromes that fall within the range(1, n), inclusive.\nExample 1:\nInput: 3\nOutput: (1, 2)\nExplanation:\nInteger palindrome are 1, 2, 3. one of them is even, and two of them are odd.\nExample 2:\nInput: 12\nOutput: (4, 6)\nExplanation:\nInteger palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\nNote:\n1. 1 <= n <= 10^3\n2. returned tuple has the number of even and odd integer palindromes respectively.", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> evenOddPalindrome(int n) {\n        int evenPalindromeCount = 0, oddPalindromeCount = 0;\n\n        for (int i = 1; i <= n; i++ ) {\n            if (String.valueOf(i).equals(new StringBuilder(String.valueOf(i)).reverse().toString())) {\n                if (i % 2 == 1) {\n                    oddPalindromeCount += 1;\n                } else {\n                    evenPalindromeCount += 1;\n                }\n            }\n        }\n        return Arrays.asList(evenPalindromeCount, oddPalindromeCount);\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/109", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing\n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n\n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index.\n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return true else return False.\n    If the given array is empty then return true.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\n    moveOneBall(Arrays.asList(3, 4, 5, 1, 2))==>true\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    moveOneBall(Arrays.asList(3, 5, 4, 1, 2))==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n     */\n    public boolean moveOneBall(List<Integer> arr) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean moveOneBall(List<Integer> arr) {\n", "canonical_solution": "        if (arr.size() == 0) {\n            return true;\n        }\n        List<Integer> sortedArr = new ArrayList<>(arr);\n        Collections.sort(sortedArr);\n\n        int minValue = Collections.min(arr);\n        int minIndex = arr.indexOf(minValue);\n        List<Integer> myArr = new ArrayList<>(arr.subList(minIndex, arr.size()));\n        myArr.addAll(arr.subList(0, minIndex));\n        for (int i = 0; i < arr.size(); i++) {\n            if (myArr.get(i) != sortedArr.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "buggy_solution": "        if (arr.size() == 0) {\n            return true;\n        }\n        List<Integer> sortedArr = new ArrayList<>(arr);\n        Collections.sort(sortedArr);\n\n        int minValue = Collections.min(arr);\n        int minIndex = sortedArr.indexOf(minValue);\n        List<Integer> myArr = new ArrayList<>(arr.subList(minIndex, arr.size()));\n        myArr.addAll(arr.subList(0, minIndex));\n        for (int i = 0; i < arr.size(); i++) {\n            if (myArr.get(i) != sortedArr.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "bug_type": "variable misuse", "failure_symptoms": "incorrect output", "entry_point": "moveOneBall", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 4, 5, 1, 2))) == true,\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 5, 10, 1, 2))) == true,\n                s.moveOneBall(new ArrayList<>(Arrays.asList(4, 3, 1, 2))) == false,\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 5, 4, 1, 2))) == false,\n                s.moveOneBall(new ArrayList<>(Arrays.asList())) == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 4, 5, 1, 2))) == true,\n                s.moveOneBall(new ArrayList<>(Arrays.asList(3, 5, 4, 1, 2))) == false\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean moveOneBall(List<Integer> arr)", "docstring": "We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the array will be randomly ordered. Your task is to determine if\nit is possible to get an array sorted in non-decreasing order by performing\nthe following operation on the given array:\nYou are allowed to perform right shift operation any number of times.\nOne right shift operation means shifting all elements of the array by one\nposition in the right direction. The last element of the array will be moved to\nthe starting position in the array i.e. 0th index.\nIf it is possible to obtain the sorted array by performing the above operation\nthen return true else return False.\nIf the given array is empty then return true.\nNote: The given list is guaranteed to have unique elements.\nFor Example:\nmoveOneBall(Arrays.asList(3, 4, 5, 1, 2))==>true\nExplanation: By performin 2 right shift operations, non-decreasing order can\nbe achieved for the given array.\nmoveOneBall(Arrays.asList(3, 5, 4, 1, 2))==>False\nExplanation:It is not possible to get non-decreasing order for the given\narray by performing any number of right shift operations.", "instruction": "Write a Java function `public boolean moveOneBall(List<Integer> arr)` to solve the following problem:\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\nnumbers in the array will be randomly ordered. Your task is to determine if\nit is possible to get an array sorted in non-decreasing order by performing\nthe following operation on the given array:\nYou are allowed to perform right shift operation any number of times.\nOne right shift operation means shifting all elements of the array by one\nposition in the right direction. The last element of the array will be moved to\nthe starting position in the array i.e. 0th index.\nIf it is possible to obtain the sorted array by performing the above operation\nthen return true else return False.\nIf the given array is empty then return true.\nNote: The given list is guaranteed to have unique elements.\nFor Example:\nmoveOneBall(Arrays.asList(3, 4, 5, 1, 2))==>true\nExplanation: By performin 2 right shift operations, non-decreasing order can\nbe achieved for the given array.\nmoveOneBall(Arrays.asList(3, 5, 4, 1, 2))==>False\nExplanation:It is not possible to get non-decreasing order for the given\narray by performing any number of right shift operations.", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean moveOneBall(List<Integer> arr) {\n        if (arr.size() == 0) {\n            return true;\n        }\n        List<Integer> sortedArr = new ArrayList<>(arr);\n        Collections.sort(sortedArr);\n\n        int minValue = Collections.min(arr);\n        int minIndex = arr.indexOf(minValue);\n        List<Integer> myArr = new ArrayList<>(arr.subList(minIndex, arr.size()));\n        myArr.addAll(arr.subList(0, minIndex));\n        for (int i = 0; i < arr.size(); i++ ) {\n            if (myArr.get(i) != sortedArr.get(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/126", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return false. Assume no negative numbers and only integers.\n\n    Examples\n    isSorted(Arrays.asList(5)) -> true\n    isSorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\n    isSorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\n    isSorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\n    isSorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\n    isSorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\n    isSorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\n    isSorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false\n     */\n    public boolean isSorted(List<Integer> lst) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isSorted(List<Integer> lst) {\n", "canonical_solution": "        List<Integer> sortedLst = new ArrayList<>(lst);\n        Collections.sort(sortedLst);\n        if (!lst.equals(sortedLst)) {\n            return false;\n        }\n        for (int i = 0; i < lst.size() - 2; i++) {\n            if (lst.get(i) == lst.get(i + 1) && lst.get(i) == lst.get(i + 2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "buggy_solution": "        List<Integer> sortedLst = new ArrayList<>(lst);\n        Collections.sort(sortedLst);\n        if (!lst.equals(sortedLst)) {\n            return false;\n        }\n        for (int i = 0; i < lst.size() - 2; i++) {\n            if (lst.get(i) == lst.get(i + 1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "isSorted", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isSorted(new ArrayList<>(List.of(5))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 3, 2, 4, 5))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 3, 2, 4, 5, 6, 7))) == false,\n                s.isSorted(new ArrayList<>(List.of())) == true,\n                s.isSorted(new ArrayList<>(List.of(1))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(3, 2, 1))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 2, 2, 3, 4))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 3, 3, 4))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 2, 3, 3, 4))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4))) == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isSorted(new ArrayList<>(List.of(5))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 3, 2, 4, 5))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7))) == true,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 3, 2, 4, 5, 6, 7))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 2, 2, 3, 4))) == false,\n                s.isSorted(new ArrayList<>(Arrays.asList(1, 2, 2, 3, 3, 4))) == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean isSorted(List<Integer> lst)", "docstring": "Given a list of numbers, return whether or not they are sorted\nin ascending order. If list has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\nExamples\nisSorted(Arrays.asList(5)) -> true\nisSorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\nisSorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\nisSorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\nisSorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\nisSorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\nisSorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\nisSorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false", "instruction": "Write a Java function `public boolean isSorted(List<Integer> lst)` to solve the following problem:\nGiven a list of numbers, return whether or not they are sorted\nin ascending order. If list has more than 1 duplicate of the same\nnumber, return false. Assume no negative numbers and only integers.\nExamples\nisSorted(Arrays.asList(5)) -> true\nisSorted(Arrays.asList(1, 2, 3, 4, 5)) -> true\nisSorted(Arrays.asList(1, 3, 2, 4, 5)) -> false\nisSorted(Arrays.asList(1, 2, 3, 4, 5, 6)) -> true\nisSorted(Arrays.asList(1, 2, 3, 4, 5, 6, 7)) -> true\nisSorted(Arrays.asList(1, 3, 2, 4, 5, 6, 7)) -> false\nisSorted(Arrays.asList(1, 2, 2, 3, 3, 4)) -> true\nisSorted(Arrays.asList(1, 2, 2, 2, 3, 4)) -> false", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isSorted(List<Integer> lst) {\n        List<Integer> sortedLst = new ArrayList<>(lst);\n        Collections.sort(sortedLst);\n        if (!lst.equals(sortedLst)) {\n            return false;\n        }\n        for (int i = 0; i < lst.size() - 2; i++ ) {\n            if (lst.get(i) == lst.get(i + 1) && lst.get(i) == lst.get(i + 2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/127", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these two\n    intervals is a prime number.\n    Example, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the intersection is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection((1, 2), (2, 3)) ==> \"NO\"\n    intersection((-1, 1), (0, 4)) ==> \"NO\"\n    intersection((-3, -1), (-5, 5)) ==> \"YES\"\n     */\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n", "canonical_solution": "        int l = Math.max(interval1.get(0), interval2.get(0));\n        int r = Math.min(interval1.get(1), interval2.get(1));\n        int length = r - l;\n        if (length <= 0) {\n            return \"NO\";\n        }\n        if (length == 1) {\n            return \"NO\";\n        }\n        if (length == 2) {\n            return \"YES\";\n        }\n        for (int i = 2; i < length; i++) {\n            if (length % i == 0) {\n                return \"NO\";\n            }\n        }\n        return \"YES\";\n    }\n}", "buggy_solution": "        int l = Math.max(interval1.get(0), interval2.get(0));\n        int r = Math.min(interval1.get(1), interval2.get(1));\n        int length = r - l;\n        if (length == 1) {\n            return \"NO\";\n        }\n        return \"YES\";\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "intersection", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5)), \"YES\" ),\n                Objects.equals(s.intersection(Arrays.asList(-2, 2), Arrays.asList(-4, 0)), \"YES\" ),\n                Objects.equals(s.intersection(Arrays.asList(-11, 2), Arrays.asList(-1, -1)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(1, 2), Arrays.asList(3, 5)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(1, 2), Arrays.asList(1, 2)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-2, -2), Arrays.asList(-3, -2)), \"NO\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.intersection(Arrays.asList(1, 2), Arrays.asList(2, 3)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-1, 1), Arrays.asList(0, 4)), \"NO\" ),\n                Objects.equals(s.intersection(Arrays.asList(-3, -1), Arrays.asList(-5, 5)), \"YES\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public String intersection(List<Integer> interval1, List<Integer> interval2)", "docstring": "You are given two intervals,\nwhere each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two\nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n[input/output] samples:\nintersection((1, 2), (2, 3)) ==> \"NO\"\nintersection((-1, 1), (0, 4)) ==> \"NO\"\nintersection((-3, -1), (-5, 5)) ==> \"YES\"", "instruction": "Write a Java function `public String intersection(List<Integer> interval1, List<Integer> interval2)` to solve the following problem:\nYou are given two intervals,\nwhere each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\nThe given intervals are closed which means that the interval (start, end)\nincludes both start and end.\nFor each given interval, it is assumed that its start is less or equal its end.\nYour task is to determine whether the length of intersection of these two\nintervals is a prime number.\nExample, the intersection of the intervals (1, 3), (2, 4) is (2, 3)\nwhich its length is 1, which not a prime number.\nIf the length of the intersection is a prime number, return \"YES\",\notherwise, return \"NO\".\nIf the two intervals don't intersect, return \"NO\".\n[input/output] samples:\nintersection((1, 2), (2, 3)) ==> \"NO\"\nintersection((-1, 1), (0, 4)) ==> \"NO\"\nintersection((-3, -1), (-5, 5)) ==> \"YES\"", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String intersection(List<Integer> interval1, List<Integer> interval2) {\n        int l = Math.max(interval1.get(0), interval2.get(0));\n        int r = Math.min(interval1.get(1), interval2.get(1));\n        int length = r - l;\n        if (length <= 0) {\n            return \"NO\";\n        }\n        if (length == 1) {\n            return \"NO\";\n        }\n        if (length == 2) {\n            return \"YES\";\n        }\n        for (int i = 2; i < length; i++ ) {\n            if (length % i == 0) {\n                return \"NO\";\n            }\n        }\n        return \"YES\";\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/129", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n     */\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n", "canonical_solution": "        int n = grid.size();\n        int val = n * n + 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid.get(i).get(j) == 1) {\n                    List<Integer> temp = new ArrayList<>();\n                    if (i != 0) {\n                        temp.add(grid.get(i - 1).get(j));\n                    }\n                    if (j != 0) {\n                        temp.add(grid.get(i).get(j - 1));\n                    }\n                    if (i != n - 1) {\n                        temp.add(grid.get(i + 1).get(j));\n                    }\n                    if (j != n - 1) {\n                        temp.add(grid.get(i).get(j + 1));\n                    }\n                    val = Collections.min(temp);\n                }\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            if (i % 2 == 0) {\n                ans.add(1);\n            } else {\n                ans.add(val);\n            }\n        }\n        return ans;\n    }\n}", "buggy_solution": "        int n = grid.size();\n        int val = n * n + 1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid.get(i).get(j) == 1) {\n                    List<Integer> temp = new ArrayList<>();\n                    if (i != 0) {\n                        temp.add(grid.get(i).get(j));\n                    }\n                    if (j != 0) {\n                        temp.add(grid.get(i).get(j));\n                    }\n                    if (i != n - 1) {\n                        temp.add(grid.get(i).get(j));\n                    }\n                    if (j != n - 1) {\n                        temp.add(grid.get(i).get(j));\n                    }\n                    val = Collections.min(temp);\n                }\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < k; i++) {\n            if (i == 0) {\n                ans.add(1);\n            } else {\n                ans.add(val);\n            }\n        }\n        return ans;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "minPath", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.minPath(Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6), Arrays.asList(7, 8, 9)), 3).equals(Arrays.asList(1, 2, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(5, 9, 3), Arrays.asList(4, 1, 6), Arrays.asList(7, 8, 2)), 1).equals(List.of(1)),\n                s.minPath(Arrays.asList(Arrays.asList(1, 2, 3, 4), Arrays.asList(5, 6, 7, 8), Arrays.asList(9, 10, 11, 12), Arrays.asList(13, 14, 15, 16)), 4).equals(Arrays.asList(1, 2, 1, 2)),\n                s.minPath(Arrays.asList(Arrays.asList(6, 4, 13, 10), Arrays.asList(5, 7, 12, 1), Arrays.asList(3, 16, 11, 15), Arrays.asList(8, 14, 9, 2)), 7).equals(Arrays.asList(1, 10, 1, 10, 1, 10, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(8, 14, 9, 2), Arrays.asList(6, 4, 13, 15), Arrays.asList(5, 7, 1, 12), Arrays.asList(3, 10, 11, 16)), 5).equals(Arrays.asList(1, 7, 1, 7, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(11, 8, 7, 2), Arrays.asList(5, 16, 14, 4), Arrays.asList(9, 3, 15, 6), Arrays.asList(12, 13, 10, 1)), 9).equals(Arrays.asList(1, 6, 1, 6, 1, 6, 1, 6, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(12, 13, 10, 1), Arrays.asList(9, 3, 15, 6), Arrays.asList(5, 16, 14, 4), Arrays.asList(11, 8, 7, 2)), 12).equals(Arrays.asList(1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6)),\n                s.minPath(Arrays.asList(Arrays.asList(2, 7, 4), Arrays.asList(3, 1, 5), Arrays.asList(6, 8, 9)), 8).equals(Arrays.asList(1, 3, 1, 3, 1, 3, 1, 3)),\n                s.minPath(Arrays.asList(Arrays.asList(6, 1, 5), Arrays.asList(3, 8, 9), Arrays.asList(2, 7, 4)), 8).equals(Arrays.asList(1, 5, 1, 5, 1, 5, 1, 5)),\n                s.minPath(Arrays.asList(Arrays.asList(1, 2), Arrays.asList(3, 4)), 10).equals(Arrays.asList(1, 2, 1, 2, 1, 2, 1, 2, 1, 2)),\n                s.minPath(Arrays.asList(Arrays.asList(1, 3), Arrays.asList(3, 2)), 10).equals(Arrays.asList(1, 3, 1, 3, 1, 3, 1, 3, 1, 3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.minPath(Arrays.asList(Arrays.asList(1, 2, 3), Arrays.asList(4, 5, 6), Arrays.asList(7, 8, 9)), 3).equals(Arrays.asList(1, 2, 1)),\n                s.minPath(Arrays.asList(Arrays.asList(5, 9, 3), Arrays.asList(4, 1, 6), Arrays.asList(7, 8, 2)), 1).equals(List.of(1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> minPath(List<List<Integer>> grid, int k)", "docstring": "Given a grid with N rows and N columns (N >= 2) and a positive integer k,\neach cell of the grid contains a value. Every integer in the range [1, N * N]\ninclusive appears exactly once on the cells of the grid.\nYou have to find the minimum path of length k in the grid. You can start\nfrom any cell, and in each step you can move to any of the neighbor cells,\nin other words, you can go to cells which share an edge with you current\ncell.\nPlease note that a path of length k means visiting exactly k cells (not\nnecessarily distinct).\nYou CANNOT go off the grid.\nA path A (of length k) is considered less than a path B (of length k) if\nafter making the ordered lists of the values on the cells that A and B go\nthrough (let's call them lst_A and lst_B), lst_A is lexicographically less\nthan lst_B, in other words, there exist an integer index i (1 <= i <= k)\nsuch that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\nlst_A[j] = lst_B[j].\nIt is guaranteed that the answer is unique.\nReturn an ordered list of the values on the cells that the minimum path go through.\nExamples:\nInput: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\nOutput: [1, 2, 1]\nInput: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\nOutput: [1]", "instruction": "Write a Java function `public List<Integer> minPath(List<List<Integer>> grid, int k)` to solve the following problem:\nGiven a grid with N rows and N columns (N >= 2) and a positive integer k,\neach cell of the grid contains a value. Every integer in the range [1, N * N]\ninclusive appears exactly once on the cells of the grid.\nYou have to find the minimum path of length k in the grid. You can start\nfrom any cell, and in each step you can move to any of the neighbor cells,\nin other words, you can go to cells which share an edge with you current\ncell.\nPlease note that a path of length k means visiting exactly k cells (not\nnecessarily distinct).\nYou CANNOT go off the grid.\nA path A (of length k) is considered less than a path B (of length k) if\nafter making the ordered lists of the values on the cells that A and B go\nthrough (let's call them lst_A and lst_B), lst_A is lexicographically less\nthan lst_B, in other words, there exist an integer index i (1 <= i <= k)\nsuch that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\nlst_A[j] = lst_B[j].\nIt is guaranteed that the answer is unique.\nReturn an ordered list of the values on the cells that the minimum path go through.\nExamples:\nInput: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\nOutput: [1, 2, 1]\nInput: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\nOutput: [1]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> minPath(List<List<Integer>> grid, int k) {\n        int n = grid.size();\n        int val = n * n + 1;\n        for (int i = 0; i < n; i++ ) {\n            for (int j = 0; j < n; j++ ) {\n                if (grid.get(i).get(j) == 1) {\n                    List<Integer> temp = new ArrayList<>();\n                    if (i != 0) {\n                        temp.add(grid.get(i - 1).get(j));\n                    }\n                    if (j != 0) {\n                        temp.add(grid.get(i).get(j - 1));\n                    }\n                    if (i != n - 1) {\n                        temp.add(grid.get(i + 1).get(j));\n                    }\n                    if (j != n - 1) {\n                        temp.add(grid.get(i).get(j + 1));\n                    }\n                    val = Collections.min(temp);\n                }\n            }\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int i = 0; i < k; i++ ) {\n            if (i % 2 == 0) {\n                ans.add(1);\n            } else {\n                ans.add(val);\n            }\n        }\n        return ans;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/130", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    tri(1) = 3\n    tri(n) = 1 + n / 2, if n is even.\n    tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\n    For example:\n    tri(2) = 1 + (2 / 2) = 2\n    tri(4) = 3\n    tri(3) = tri(2) + tri(1) + tri(4)\n           = 2 + 3 + 3 = 8\n    You are given a non-negative integer number n, you have to a return a list of the\n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    tri(3) = [1, 3, 2, 8]\n     */\n    public List<Integer> tri(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n", "canonical_solution": "        if (n == 0) {\n            return List.of(1);\n        }\n        List<Integer> myTri = new ArrayList<>(Arrays.asList(1, 3));\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                myTri.add(i / 2 + 1);\n            } else {\n                myTri.add(myTri.get(myTri.size() - 1) + myTri.get(myTri.size() - 2) + (i + 3) / 2);\n            }\n        }\n        return myTri;\n    }\n}", "buggy_solution": "        if (n == 0) {\n            return List.of(1);\n        }\n        List<Integer> myTri = new ArrayList<>(Arrays.asList(1, 3));\n        for (int i = 2; i <= n; i++) {\n            if (i % 2 == 0) {\n                myTri.add(i / 2 + 1);\n            } else {\n                myTri.add(myTri.get(myTri.size() - 1) + myTri.get(myTri.size() - 2) + i + (i + 3) / 2);\n            }\n        }\n        return myTri;\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "tri", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.tri(3).equals(Arrays.asList(1, 3, 2, 8)),\n                s.tri(4).equals(Arrays.asList(1, 3, 2, 8, 3)),\n                s.tri(5).equals(Arrays.asList(1, 3, 2, 8, 3, 15)),\n                s.tri(6).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4)),\n                s.tri(7).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24)),\n                s.tri(8).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24, 5)),\n                s.tri(9).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24, 5, 35)),\n                s.tri(20).equals(Arrays.asList(1, 3, 2, 8, 3, 15, 4, 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11)),\n                s.tri(0).equals(List.of(1)),\n                s.tri(1).equals(Arrays.asList(1, 3))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.tri(3).equals(Arrays.asList(1, 3, 2, 8))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> tri(int n)", "docstring": "Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in\nthe last couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence:\ntri(1) = 3\ntri(n) = 1 + n / 2, if n is even.\ntri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nYou are given a non-negative integer number n, you have to a return a list of the\nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = [1, 3, 2, 8]", "instruction": "Write a Java function `public List<Integer> tri(int n)` to solve the following problem:\nEveryone knows Fibonacci sequence, it was studied deeply by mathematicians in\nthe last couple centuries. However, what people don't know is Tribonacci sequence.\nTribonacci sequence is defined by the recurrence:\ntri(1) = 3\ntri(n) = 1 + n / 2, if n is even.\ntri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if n is odd.\nFor example:\ntri(2) = 1 + (2 / 2) = 2\ntri(4) = 3\ntri(3) = tri(2) + tri(1) + tri(4)\n= 2 + 3 + 3 = 8\nYou are given a non-negative integer number n, you have to a return a list of the\nfirst n + 1 numbers of the Tribonacci sequence.\nExamples:\ntri(3) = [1, 3, 2, 8]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> tri(int n) {\n        if (n == 0) {\n            return List.of(1);\n        }\n        List<Integer> myTri = new ArrayList<>(Arrays.asList(1, 3));\n        for (int i = 2; i <= n; i++ ) {\n            if (i % 2 == 0) {\n                myTri.add(i / 2 + 1);\n            } else {\n                myTri.add(myTri.get(myTri.size() - 1) + myTri.get(myTri.size() - 2) + (i + 3) / 2);\n            }\n        }\n        return myTri;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/132", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return true if and only if there is a valid subsequence of brackets\n    where at least one bracket in the subsequence is nested.\n\n    isNested(\"[[]]\") -> true\n    isNested(\"[]]]]]]][[[[[]\") -> false\n    isNested(\"[][]\") -> false\n    isNested(\"[]\") -> false\n    isNested(\"[[][]]\") -> true\n    isNested(\"[[]][[\") -> true\n     */\n    public boolean isNested(String string) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isNested(String string) {\n", "canonical_solution": "        List<Integer> openingBracketIndex = new ArrayList<>(), closingBracketIndex = new ArrayList<>();\n        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i) == '[') {\n                openingBracketIndex.add(i);\n            } else {\n                closingBracketIndex.add(i);\n            }\n        }\n        Collections.reverse(closingBracketIndex);\n        int i = 0, l = closingBracketIndex.size();\n        for (int idx : openingBracketIndex) {\n            if (i < l && idx < closingBracketIndex.get(i)) {\n                i += 1;\n            }\n        }\n        return i >= 2;\n    }\n}", "buggy_solution": "        List<Integer> openingBracketIndex = new ArrayList<>(), closingBracketIndex = new ArrayList<>();\n        for (int i = 0; i < string.length(); i++) {\n            if (string.charAt(i) == '(') {\n                openingBracketIndex.add(i);\n            } else {\n                closingBracketIndex.add(i);\n            }\n        }\n        Collections.reverse(closingBracketIndex);\n        int i = 0, l = closingBracketIndex.size();\n        for (int idx : openingBracketIndex) {\n            if (i < l && idx < closingBracketIndex.get(i)) {\n                i += 1;\n            }\n        }\n        return i >= 2;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "isNested", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isNested(\"[[]]\" ),\n                !s.isNested(\"[]]]]]]][[[[[]\" ),\n                !s.isNested(\"[][]\" ),\n                !s.isNested(\"[]\" ),\n                s.isNested(\"[[[[]]]]\" ),\n                !s.isNested(\"[]]]]]]]]]]\" ),\n                s.isNested(\"[][][[]]\" ),\n                !s.isNested(\"[[]\" ),\n                !s.isNested(\"[]]\" ),\n                s.isNested(\"[[]][[\" ),\n                s.isNested(\"[[][]]\" ),\n                !s.isNested(\"\" ),\n                !s.isNested(\"[[[[[[[[\" ),\n                !s.isNested(\"]]]]]]]]\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.isNested(\"[[]]\" ),\n                !s.isNested(\"[]]]]]]][[[[[]\" ),\n                !s.isNested(\"[][]\" ),\n                !s.isNested(\"[]\" ),\n                s.isNested(\"[[]][[\" ),\n                s.isNested(\"[[][]]\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean isNested(String string)", "docstring": "Create a function that takes a string as input which contains only square brackets.\nThe function should return true if and only if there is a valid subsequence of brackets\nwhere at least one bracket in the subsequence is nested.\nisNested(\"[[]]\") -> true\nisNested(\"[]]]]]]][[[[[]\") -> false\nisNested(\"[][]\") -> false\nisNested(\"[]\") -> false\nisNested(\"[[][]]\") -> true\nisNested(\"[[]][[\") -> true", "instruction": "Write a Java function `public boolean isNested(String string)` to solve the following problem:\nCreate a function that takes a string as input which contains only square brackets.\nThe function should return true if and only if there is a valid subsequence of brackets\nwhere at least one bracket in the subsequence is nested.\nisNested(\"[[]]\") -> true\nisNested(\"[]]]]]]][[[[[]\") -> false\nisNested(\"[][]\") -> false\nisNested(\"[]\") -> false\nisNested(\"[[][]]\") -> true\nisNested(\"[[]][[\") -> true", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean isNested(String string) {\n        List<Integer> openingBracketIndex = new ArrayList<>(), closingBracketIndex = new ArrayList<>();\n        for (int i = 0; i < string.length(); i++ ) {\n            if (string.charAt(i) == '[') {\n                openingBracketIndex.add(i);\n            } else {\n                closingBracketIndex.add(i);\n            }\n        }\n        Collections.reverse(closingBracketIndex);\n        int i = 0, l = closingBracketIndex.size();\n        for (int idx : openingBracketIndex) {\n            if (i < l && idx < closingBracketIndex.get(i)) {\n                i += 1;\n            }\n        }\n        return i >= 2;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/139", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> specialFactorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n     */\n    public long specialFactorial(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public long specialFactorial(int n) {\n", "canonical_solution": "        long factI = 1, specialFact = 1;\n        for (int i = 1; i <= n; i++) {\n            factI *= i;\n            specialFact *= factI;\n        }\n        return specialFact;\n    }\n}", "buggy_solution": "        long factI = 1, specialFact = 1;\n        for (int i = 1; i <= n; i++) {\n            i *= n;\n            factI *= i;\n            specialFact *= factI;\n        }\n        return specialFact;\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "specialFactorial", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.specialFactorial(4) == 288,\n                s.specialFactorial(5) == 34560,\n                s.specialFactorial(7) == 125411328000L,\n                s.specialFactorial(1) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.specialFactorial(4) == 288\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public long specialFactorial(int n)", "docstring": "The Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\nFor example:\n>>> specialFactorial(4)\n288\nThe function will receive an integer as input and should return the special\nfactorial of this integer.", "instruction": "Write a Java function `public long specialFactorial(int n)` to solve the following problem:\nThe Brazilian factorial is defined as:\nbrazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\nwhere n > 0\nFor example:\n>>> specialFactorial(4)\n288\nThe function will receive an integer as input and should return the special\nfactorial of this integer.", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public long specialFactorial(int n) {\n        long factI = 1, specialFact = 1;\n        for (int i = 1; i <= n; i++ ) {\n            factI *= i;\n            specialFact *= factI;\n        }\n        return specialFact;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/140", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given a string text, replace all spaces in it with underscores,\n    and if a string has more than 2 consecutive spaces,\n    then replace all consecutive spaces with -\n\n    fixSpaces(\"Example\") == \"Example\"\n    fixSpaces(\"Example 1\") == \"Example_1\"\n    fixSpaces(\" Example 2\") == \"_Example_2\"\n    fixSpaces(\" Example   3\") == \"_Example-3\"\n     */\n    public String fixSpaces(String text) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fixSpaces(String text) {\n", "canonical_solution": "        StringBuilder sb = new StringBuilder();\n        int start = 0, end = 0;\n        for (int i = 0; i < text.length(); i++) {\n            if (text.charAt(i) == ' ') {\n                end += 1;\n            } else {\n                if (end - start > 2) {\n                    sb.append('-');\n                } else if (end - start > 0) {\n                    sb.append(\"_\".repeat(end - start));\n                }\n                sb.append(text.charAt(i));\n                start = i + 1;\n                end = i + 1;\n            }\n        }\n        if (end - start > 2) {\n            sb.append('-');\n        } else if (end - start > 0) {\n            sb.append(\"_\".repeat(end - start));\n        }\n        return sb.toString();\n    }\n}", "buggy_solution": "        StringBuilder sb = new StringBuilder();\n        int start = 0, end = 0;\n        for (int i = 0; i < text.length(); i++) {\n            if (text.charAt(i) == ' ') {\n                end += 1;\n            } else {\n                if (end - start > 2) {\n                    sb.append('-');\n                } else if (end - start > 0) {\n                    sb.append(\"_\".repeat(end - start));\n                }\n                sb.append(text.charAt(i));\n                start = i + 1;\n                end = i + 1;\n            }\n        }\n        if (end - start > 2) {\n            sb.append('-');\n        } else if (end - start > 0) {\n            sb.append(\"__\".repeat(end - start));\n        }\n        return sb.toString();\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "fixSpaces", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.fixSpaces(\"Example\" ), \"Example\" ),\n                Objects.equals(s.fixSpaces(\"Mudasir Hanif \" ), \"Mudasir_Hanif_\" ),\n                Objects.equals(s.fixSpaces(\"Yellow Yellow  Dirty  Fellow\" ), \"Yellow_Yellow__Dirty__Fellow\" ),\n                Objects.equals(s.fixSpaces(\"Exa   mple\" ), \"Exa-mple\" ),\n                Objects.equals(s.fixSpaces(\"   Exa 1 2 2 mple\" ), \"-Exa_1_2_2_mple\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.fixSpaces(\"Example\" ), \"Example\" ),\n                Objects.equals(s.fixSpaces(\"Example 1\" ), \"Example_1\" ),\n                Objects.equals(s.fixSpaces(\" Example 2\" ), \"_Example_2\" ),\n                Objects.equals(s.fixSpaces(\" Example   3\" ), \"_Example-3\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public String fixSpaces(String text)", "docstring": "Given a string text, replace all spaces in it with underscores,\nand if a string has more than 2 consecutive spaces,\nthen replace all consecutive spaces with -\nfixSpaces(\"Example\") == \"Example\"\nfixSpaces(\"Example 1\") == \"Example_1\"\nfixSpaces(\" Example 2\") == \"_Example_2\"\nfixSpaces(\" Example   3\") == \"_Example-3\"", "instruction": "Write a Java function `public String fixSpaces(String text)` to solve the following problem:\nGiven a string text, replace all spaces in it with underscores,\nand if a string has more than 2 consecutive spaces,\nthen replace all consecutive spaces with -\nfixSpaces(\"Example\") == \"Example\"\nfixSpaces(\"Example 1\") == \"Example_1\"\nfixSpaces(\" Example 2\") == \"_Example_2\"\nfixSpaces(\" Example   3\") == \"_Example-3\"", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String fixSpaces(String text) {\n        StringBuilder sb = new StringBuilder();\n        int start = 0, end = 0;\n        for (int i = 0; i < text.length(); i++ ) {\n            if (text.charAt(i) == ' ') {\n                end += 1;\n            } else {\n                if (end - start > 2) {\n                    sb.append('-');\n                } else if (end - start > 0) {\n                    sb.append(\"_\".repeat(end - start));\n                }\n                sb.append(text.charAt(i));\n                start = i + 1;\n                end = i + 1;\n            }\n        }\n        if (end - start > 2) {\n            sb.append('-');\n        } else if (end - start > 0) {\n            sb.append(\"_\".repeat(end - start));\n        }\n        return sb.toString();\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/142", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\n\n    Examples:\n    For lst = [1,2,3] the output should be 6\n    For lst = []  the output should be 0\n    For lst = [-1,-5,2,-1,-5]  the output should be -126\n     */\n    public int sumSquares(List<Integer> lst) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumSquares(List<Integer> lst) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                result.add(lst.get(i) * lst.get(i));\n            } else if (i % 4 == 0) {\n                result.add((int) Math.pow(lst.get(i), 3));\n            } else {\n                result.add(lst.get(i));\n            }\n        }\n        return result.stream().reduce(Integer::sum).orElse(0);\n    }\n}", "buggy_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++) {\n            if (i % 3 == 0) {\n                result.add(lst.get(i) * lst.get(i));\n            } else {\n                result.add(lst.get(i));\n            }\n        }\n        return result.stream().reduce(Integer::sum).orElse(0);\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "sumSquares", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumSquares(Arrays.asList(1,2,3)) == 6,\n                s.sumSquares(Arrays.asList(1,4,9)) == 14,\n                s.sumSquares(List.of()) == 0,\n                s.sumSquares(Arrays.asList(1,1,1,1,1,1,1,1,1)) == 9,\n                s.sumSquares(Arrays.asList(-1,-1,-1,-1,-1,-1,-1,-1,-1)) == -3,\n                s.sumSquares(List.of(0)) == 0,\n                s.sumSquares(Arrays.asList(-1,-5,2,-1,-5)) == -126,\n                s.sumSquares(Arrays.asList(-56,-99,1,0,-2)) == 3030,\n                s.sumSquares(Arrays.asList(-1,0,0,0,0,0,0,0,-1)) == 0,\n                s.sumSquares(Arrays.asList(-16, -9, -2, 36, 36, 26, -20, 25, -40, 20, -4, 12, -26, 35, 37)) == -14196,\n                s.sumSquares(Arrays.asList(-1, -3, 17, -1, -15, 13, -1, 14, -14, -12, -5, 14, -14, 6, 13, 11, 16, 16, 4, 10)) == -1448\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.sumSquares(Arrays.asList(1,2,3)) == 6,\n                s.sumSquares(List.of()) == 0,\n                s.sumSquares(Arrays.asList(-1,-5,2,-1,-5)) == -126\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int sumSquares(List<Integer> lst)", "docstring": "This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\nchange the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\nExamples:\nFor lst = [1,2,3] the output should be 6\nFor lst = []  the output should be 0\nFor lst = [-1,-5,2,-1,-5]  the output should be -126", "instruction": "Write a Java function `public int sumSquares(List<Integer> lst)` to solve the following problem:\nThis function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a\nmultiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not\nchange the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries.\nExamples:\nFor lst = [1,2,3] the output should be 6\nFor lst = []  the output should be 0\nFor lst = [-1,-5,2,-1,-5]  the output should be -126", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int sumSquares(List<Integer> lst) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < lst.size(); i++ ) {\n            if (i % 3 == 0) {\n                result.add(lst.get(i) * lst.get(i));\n            } else if (i % 4 == 0) {\n                result.add((int) Math.pow(lst.get(i), 3));\n            } else {\n                result.add(lst.get(i));\n            }\n        }\n        return result.stream().reduce(Integer::sum).orElse(0);\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/143", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n        Input: sentence = \"This is a test\"\n        Output: \"is\"\n\n    Example 2:\n        Input: sentence = \"lets go for swimming\"\n        Output: \"go for\"\n\n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n     */\n    public String wordsInSentence(String sentence) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String wordsInSentence(String sentence) {\n", "canonical_solution": "        List<String> newLst = new ArrayList<>();\n        for (String word : sentence.split(\" \" )) {\n            boolean flg = true;\n            if (word.length() == 1) {\n                continue;\n            }\n            for (int i = 2; i < word.length(); i++) {\n                if (word.length() % i == 0) {\n                    flg = false;\n                    break;\n                }\n            }\n            if (flg) {\n                newLst.add(word);\n            }\n        }\n        return String.join(\" \", newLst);\n    }\n}", "buggy_solution": "        List<String> newLst = new ArrayList<>();\n        for (String word : sentence.split(\" \" )) {\n            boolean flg = true;\n            for (int i = 2; i < word.length(); i++) {\n                if (word.length() % i == 0) {\n                    flg = false;\n                    break;\n                }\n            }\n            if (flg) {\n                newLst.add(word);\n            }\n        }\n        return String.join(\" \", newLst);\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "wordsInSentence", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.wordsInSentence(\"This is a test\" ), \"is\" ),\n                Objects.equals(s.wordsInSentence(\"lets go for swimming\" ), \"go for\" ),\n                Objects.equals(s.wordsInSentence(\"there is no place available here\" ), \"there is no place\" ),\n                Objects.equals(s.wordsInSentence(\"Hi I am Hussein\" ), \"Hi am Hussein\" ),\n                Objects.equals(s.wordsInSentence(\"go for it\" ), \"go for it\" ),\n                Objects.equals(s.wordsInSentence(\"here\" ), \"\" ),\n                Objects.equals(s.wordsInSentence(\"here is\" ), \"is\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                Objects.equals(s.wordsInSentence(\"This is a test\" ), \"is\" ),\n                Objects.equals(s.wordsInSentence(\"lets go for swimming\" ), \"go for\" )\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public String wordsInSentence(String sentence)", "docstring": "You are given a string representing a sentence,\nthe sentence contains some words separated by a space,\nand you have to return a string that contains the words from the original sentence,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.\nExample 1:\nInput: sentence = \"This is a test\"\nOutput: \"is\"\nExample 2:\nInput: sentence = \"lets go for swimming\"\nOutput: \"go for\"\nConstraints:\n* 1 <= len(sentence) <= 100\n* sentence contains only letters", "instruction": "Write a Java function `public String wordsInSentence(String sentence)` to solve the following problem:\nYou are given a string representing a sentence,\nthe sentence contains some words separated by a space,\nand you have to return a string that contains the words from the original sentence,\nwhose lengths are prime numbers,\nthe order of the words in the new string should be the same as the original one.\nExample 1:\nInput: sentence = \"This is a test\"\nOutput: \"is\"\nExample 2:\nInput: sentence = \"lets go for swimming\"\nOutput: \"go for\"\nConstraints:\n* 1 <= len(sentence) <= 100\n* sentence contains only letters", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public String wordsInSentence(String sentence) {\n        List<String> newLst = new ArrayList<>();\n        for (String word : sentence.split(\" \" )) {\n            boolean flg = true;\n            if (word.length() == 1) {\n                continue;\n            }\n            for (int i = 2; i < word.length(); i++ ) {\n                if (word.length() % i == 0) {\n                    flg = false;\n                    break;\n                }\n            }\n            if (flg) {\n                newLst.add(word);\n            }\n        }\n        return String.join(\" \", newLst);\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/145", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum of their digits.\n    Note: if there are several items with similar sum of their digits,\n    order them based on their index in original list.\n\n    For example:\n    >>> orderByPoints(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n    >>> orderByPoints(Arrays.asList()) == []\n     */\n    public List<Integer> orderByPoints(List<Integer> nums) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> orderByPoints(List<Integer> nums) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>(nums);\n        result.sort((o1, o2) -> {\n            int sum1 = 0;\n            int sum2 = 0;\n\n            for (int i = 0; i < String.valueOf(o1).length(); i++) {\n                if (i != 0 || o1 >= 0) {\n                    sum1 += (String.valueOf(o1).charAt(i) - '0' );\n                    if (i == 1 && o1 < 0) {\n                        sum1 = -sum1;\n                    }\n                }\n            }\n            for (int i = 0; i < String.valueOf(o2).length(); i++) {\n                if (i != 0 || o2 >= 0) {\n                    sum2 += (String.valueOf(o2).charAt(i) - '0' );\n                    if (i == 1 && o2 < 0) {\n                        sum2 = -sum2;\n                    }\n                }\n            }\n            return Integer.compare(sum1, sum2);\n        });\n        return result;\n    }\n}", "buggy_solution": "        List<Integer> result = new ArrayList<>(nums);\n        result.sort((o1, o2) -> {\n            int sum1 = 0;\n            int sum2 = 0;\n\n            for (int i = 0; i < String.valueOf(o1).length(); i++) {\n                if (i != 0 || o1 >= 0) {\n                    sum1 += (String.valueOf(o1).charAt(i) - '0' );\n                    if (i == 1 && o1 < 0) {\n                        sum1 = -sum1;\n                    }\n                }\n            }\n            for (int i = 0; i < String.valueOf(o2).length(); i++) {\n                if (i != 0 || o2 >= 0) {\n                    sum2 += (String.valueOf(o2).charAt(i) - '0' );\n                    if (i == 1 && o2 < 0) {\n                        sum2 = -sum2 + sum1;\n                    }\n                }\n            }\n            return Integer.compare(sum1, sum2);\n        });\n        return result;\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "orderByPoints", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.orderByPoints(new ArrayList<>(Arrays.asList(1, 11, -1, -11, -12))).equals(Arrays.asList(-1, -11, 1, -12, 11)),\n                s.orderByPoints(new ArrayList<>(Arrays.asList(1234, 423, 463, 145, 2, 423, 423, 53, 6, 37, 3457, 3, 56, 0, 46))).equals(Arrays.asList(0, 2, 3, 6, 53, 423, 423, 423, 1234, 145, 37, 46, 56, 463, 3457)),\n                s.orderByPoints(new ArrayList<>(List.of())).equals(List.of()),\n                s.orderByPoints(new ArrayList<>(Arrays.asList(1, -11, -32, 43, 54, -98, 2, -3))).equals(Arrays.asList(-3, -32, -98, -11, 1, 2, 43, 54)),\n                s.orderByPoints(new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11))).equals(Arrays.asList(1, 10, 2, 11, 3, 4, 5, 6, 7, 8, 9)),\n                s.orderByPoints(new ArrayList<>(Arrays.asList(0, 6, 6, -76, -21, 23, 4))).equals(Arrays.asList(-76, -21, 0, 4, 23, 6, 6))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.orderByPoints(new ArrayList<>(Arrays.asList(1, 11, -1, -11, -12))).equals(Arrays.asList(-1, -11, 1, -12, 11)),\n                s.orderByPoints(new ArrayList<>(List.of())).equals(List.of())\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> orderByPoints(List<Integer> nums)", "docstring": "Write a function which sorts the given list of integers\nin ascending order according to the sum of their digits.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original list.\nFor example:\n>>> orderByPoints(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n>>> orderByPoints(Arrays.asList()) == []", "instruction": "Write a Java function `public List<Integer> orderByPoints(List<Integer> nums)` to solve the following problem:\nWrite a function which sorts the given list of integers\nin ascending order according to the sum of their digits.\nNote: if there are several items with similar sum of their digits,\norder them based on their index in original list.\nFor example:\n>>> orderByPoints(Arrays.asList(1, 11, -1, -11, -12)) == [-1, -11, 1, -12, 11]\n>>> orderByPoints(Arrays.asList()) == []", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> orderByPoints(List<Integer> nums) {\n        List<Integer> result = new ArrayList<>(nums);\n        result.sort((o1, o2) -> {\n            int sum1 = 0;\n            int sum2 = 0;\n\n            for (int i = 0; i < String.valueOf(o1).length(); i++ ) {\n                if (i != 0 || o1 >= 0) {\n                    sum1 += (String.valueOf(o1).charAt(i) - '0' );\n                    if (i == 1 && o1 < 0) {\n                        sum1 = -sum1;\n                    }\n                }\n            }\n            for (int i = 0; i < String.valueOf(o2).length(); i++ ) {\n                if (i != 0 || o2 >= 0) {\n                    sum2 += (String.valueOf(o2).charAt(i) - '0' );\n                    if (i == 1 && o2 < 0) {\n                        sum2 = -sum2;\n                    }\n                }\n            }\n            return Integer.compare(sum1, sum2);\n        });\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/147", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k,\n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n        Input: n = 5\n        Output: 1\n        Explanation:\n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n     */\n    public int getMaxTriples(int n) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int getMaxTriples(int n) {\n", "canonical_solution": "        List<Integer> A = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            A.add(i * i - i + 1);\n        }\n        int count = 0;\n        for (int i = 0; i < A.size(); i++) {\n            for (int j = i + 1; j < A.size(); j++) {\n                for (int k = j + 1; k < A.size(); k++) {\n                    if ((A.get(i) + A.get(j) + A.get(k)) % 3 == 0) {\n                        count += 1;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}", "buggy_solution": "        List<Integer> A = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            A.add(i * i);\n        }\n        int count = 0;\n        for (int i = 0; i < A.size(); i++) {\n            for (int j = i + 1; j < A.size(); j++) {\n                for (int k = j + 1; k < A.size(); k++) {\n                    if ((A.get(i) + A.get(j) + A.get(k)) % 3 == 0) {\n                        count += 1;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}", "bug_type": "missing logic", "failure_symptoms": "incorrect output", "entry_point": "getMaxTriples", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getMaxTriples(5) == 1,\n                s.getMaxTriples(6) == 4,\n                s.getMaxTriples(10) == 36,\n                s.getMaxTriples(100) == 53361\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.getMaxTriples(5) == 1\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int getMaxTriples(int n)", "docstring": "You are given a positive integer n. You have to create an integer array a of length n.\nFor each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\nReturn the number of triples (a[i], a[j], a[k]) of a where i < j < k,\nand a[i] + a[j] + a[k] is a multiple of 3.\nExample :\nInput: n = 5\nOutput: 1\nExplanation:\na = [1, 3, 7, 13, 21]\nThe only valid triple is (1, 7, 13).", "instruction": "Write a Java function `public int getMaxTriples(int n)` to solve the following problem:\nYou are given a positive integer n. You have to create an integer array a of length n.\nFor each i (1 <= i <= n), the value of a[i] = i * i - i + 1.\nReturn the number of triples (a[i], a[j], a[k]) of a where i < j < k,\nand a[i] + a[j] + a[k] is a multiple of 3.\nExample :\nInput: n = 5\nOutput: 1\nExplanation:\na = [1, 3, 7, 13, 21]\nThe only valid triple is (1, 7, 13).", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int getMaxTriples(int n) {\n        List<Integer> A = new ArrayList<>();\n        for (int i = 1; i <= n; i++ ) {\n            A.add(i * i - i + 1);\n        }\n        int count = 0;\n        for (int i = 0; i < A.size(); i++ ) {\n            for (int j = i + 1; j < A.size(); j++ ) {\n                for (int k = j + 1; k < A.size(); k++ ) {\n                    if ((A.get(i) + A.get(j) + A.get(k)) % 3 == 0) {\n                        count += 1;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/150", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    A simple program which should return the value of x if n is\n    a prime number and should return the value of y otherwise.\n\n    Examples:\n    for xOrY(7, 34, 12) == 34\n    for xOrY(15, 8, 5) == 5\n     */\n    public int xOrY(int n, int x, int y) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int xOrY(int n, int x, int y) {\n", "canonical_solution": "        if (n == 1) {\n            return y;\n        }\n        for (int i = 2; i < n; i++) {\n            if (n % i == 0) {\n                return y;\n            }\n        }\n        return x;\n    }\n}", "buggy_solution": "        if (n == 1) {\n            return y;\n        }\n        for (int i = 2; i < n; i++) {\n            if (n % i - 1 == 0) {\n                return y;\n            }\n        }\n        return x;\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "xOrY", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.xOrY(7, 34, 12) == 34,\n                s.xOrY(15, 8, 5) == 5,\n                s.xOrY(3, 33, 5212) == 33,\n                s.xOrY(1259, 3, 52) == 3,\n                s.xOrY(7919, -1, 12) == -1,\n                s.xOrY(3609, 1245, 583) == 583,\n                s.xOrY(91, 56, 129) == 129,\n                s.xOrY(6, 34, 1234) == 1234,\n                s.xOrY(1, 2, 0) == 0,\n                s.xOrY(2, 2, 0) == 2\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.xOrY(7, 34, 12) == 34,\n                s.xOrY(15, 8, 5) == 5\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public int xOrY(int n, int x, int y)", "docstring": "A simple program which should return the value of x if n is\na prime number and should return the value of y otherwise.\nExamples:\nfor xOrY(7, 34, 12) == 34\nfor xOrY(15, 8, 5) == 5", "instruction": "Write a Java function `public int xOrY(int n, int x, int y)` to solve the following problem:\nA simple program which should return the value of x if n is\na prime number and should return the value of y otherwise.\nExamples:\nfor xOrY(7, 34, 12) == 34\nfor xOrY(15, 8, 5) == 5", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int xOrY(int n, int x, int y) {\n        if (n == 1) {\n            return y;\n        }\n        for (int i = 2; i < n; i++ ) {\n            if (n % i == 0) {\n                return y;\n            }\n        }\n        return x;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/152", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n    Your task is to determine if a person correctly guessed the results of a number of matches.\n    You are given two arrays of scores and guesses of equal length, where each index shows a match.\n    Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score.\n\n    example:\n\n    compare(Arrays.asList(1,2,3,4,5,1),Arrays.asList(1,2,3,4,2,-2)) -> [0,0,0,0,3,3]\n    compare(Arrays.asList(0,5,0,0,0,4),Arrays.asList(4,1,1,0,0,-2)) -> [4,4,1,0,0,6]\n     */\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n", "canonical_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            result.add(Math.abs(game.get(i) - guess.get(i)));\n        }\n        return result;\n    }\n}", "buggy_solution": "        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++) {\n            result.add(Math.abs(game.get(i) - guess.get(i))+Math.abs(guess.get(i) - game.get(i)));\n        }\n        return result;\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "compare", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2)).equals(Arrays.asList(0, 0, 0, 0, 3, 3)),\n                s.compare(Arrays.asList(0,5,0,0,0,4), Arrays.asList(4,1,1,0,0,-2)).equals(Arrays.asList(4,4,1,0,0,6)),\n                s.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2)).equals(Arrays.asList(0, 0, 0, 0, 3, 3)),\n                s.compare(Arrays.asList(0, 0, 0, 0, 0, 0), Arrays.asList(0, 0, 0, 0, 0, 0)).equals(Arrays.asList(0, 0, 0, 0, 0, 0)),\n                s.compare(Arrays.asList(1, 2, 3), Arrays.asList(-1, -2, -3)).equals(Arrays.asList(2, 4, 6)),\n                s.compare(Arrays.asList(1, 2, 3, 5), Arrays.asList(-1, 2, 3, 4)).equals(Arrays.asList(2, 0, 0, 1))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.compare(Arrays.asList(1, 2, 3, 4, 5, 1), Arrays.asList(1, 2, 3, 4, 2, -2)).equals(Arrays.asList(0, 0, 0, 0, 3, 3)),\n                s.compare(Arrays.asList(0,5,0,0,0,4), Arrays.asList(4,1,1,0,0,-2)).equals(Arrays.asList(4,4,1,0,0,6))\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public List<Integer> compare(List<Integer> game, List<Integer> guess)", "docstring": "I think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two arrays of scores and guesses of equal length, where each index shows a match.\nReturn an array of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\nexample:\ncompare(Arrays.asList(1,2,3,4,5,1),Arrays.asList(1,2,3,4,2,-2)) -> [0,0,0,0,3,3]\ncompare(Arrays.asList(0,5,0,0,0,4),Arrays.asList(4,1,1,0,0,-2)) -> [4,4,1,0,0,6]", "instruction": "Write a Java function `public List<Integer> compare(List<Integer> game, List<Integer> guess)` to solve the following problem:\nI think we all remember that feeling when the result of some long-awaited\nevent is finally known. The feelings and thoughts you have at that moment are\ndefinitely worth noting down and comparing.\nYour task is to determine if a person correctly guessed the results of a number of matches.\nYou are given two arrays of scores and guesses of equal length, where each index shows a match.\nReturn an array of the same length denoting how far off each guess was. If they have guessed correctly,\nthe value is 0, and if not, the value is the absolute difference between the guess and the score.\nexample:\ncompare(Arrays.asList(1,2,3,4,5,1),Arrays.asList(1,2,3,4,2,-2)) -> [0,0,0,0,3,3]\ncompare(Arrays.asList(0,5,0,0,0,4),Arrays.asList(4,1,1,0,0,-2)) -> [4,4,1,0,0,6]", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public List<Integer> compare(List<Integer> game, List<Integer> guess) {\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < game.size(); i++ ) {\n            result.add(Math.abs(game.get(i) - guess.get(i)));\n        }\n        return result;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/154", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\n    cycpatternCheck(\"abcd\",\"abd\") => false\n    cycpatternCheck(\"hello\",\"ell\") => true\n    cycpatternCheck(\"whassup\",\"psus\") => false\n    cycpatternCheck(\"abab\",\"baa\") => true\n    cycpatternCheck(\"efef\",\"eeff\") => false\n    cycpatternCheck(\"himenss\",\"simen\") => true\n     */\n    public boolean cycpatternCheck(String a, String b) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpatternCheck(String a, String b) {\n", "canonical_solution": "        int l = b.length();\n        String pat = b + b;\n        for (int i = 0; i <= a.length() - l; i++) {\n            for (int j = 0; j <= l; j++) {\n                if (a.substring(i, i + l).equals(pat.substring(j, j + l))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "buggy_solution": "        int l = b.length();\n        String pat = b + b;\n        for (int i = 0; i <= a.length() - l; i++) {\n            for (int j = 0; j <= b.length() - l; j++) {\n                if (a.substring(i, i + l).equals(pat.substring(j, j + l))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "bug_type": "value misuse", "failure_symptoms": "incorrect output", "entry_point": "cycpatternCheck", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.cycpatternCheck(\"xyzw\", \"xyw\") == false,\n                s.cycpatternCheck(\"yello\", \"ell\") == true,\n                s.cycpatternCheck(\"whattup\", \"ptut\") == false,\n                s.cycpatternCheck(\"efef\", \"fee\") == true,\n                s.cycpatternCheck(\"abab\", \"aabb\") == false,\n                s.cycpatternCheck(\"winemtt\", \"tinem\") == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "public class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.cycpatternCheck(\"abcd\", \"abd\") == false,\n                s.cycpatternCheck(\"hello\", \"ell\") == true,\n                s.cycpatternCheck(\"whassup\", \"psus\") == false,\n                s.cycpatternCheck(\"abab\", \"baa\") == true,\n                s.cycpatternCheck(\"efef\", \"eeff\") == false,\n                s.cycpatternCheck(\"himenss\", \"simen\") == true\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}\n", "signature": "public boolean cycpatternCheck(String a, String b)", "docstring": "You are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\ncycpatternCheck(\"abcd\",\"abd\") => false\ncycpatternCheck(\"hello\",\"ell\") => true\ncycpatternCheck(\"whassup\",\"psus\") => false\ncycpatternCheck(\"abab\",\"baa\") => true\ncycpatternCheck(\"efef\",\"eeff\") => false\ncycpatternCheck(\"himenss\",\"simen\") => true", "instruction": "Write a Java function `public boolean cycpatternCheck(String a, String b)` to solve the following problem:\nYou are given 2 words. You need to return true if the second word or any of its rotations is a substring in the first word\ncycpatternCheck(\"abcd\",\"abd\") => false\ncycpatternCheck(\"hello\",\"ell\") => true\ncycpatternCheck(\"whassup\",\"psus\") => false\ncycpatternCheck(\"abab\",\"baa\") => true\ncycpatternCheck(\"efef\",\"eeff\") => false\ncycpatternCheck(\"himenss\",\"simen\") => true", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public boolean cycpatternCheck(String a, String b) {\n        int l = b.length();\n        String pat = b + b;\n        for (int i = 0; i <= a.length() - l; i++ ) {\n            for (int j = 0; j <= l; j++ ) {\n                if (a.substring(i, i + l).equals(pat.substring(j, j + l))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}", "token_boundary_changed": false}
{"task_id": "Java/160", "prompt": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    /**\n    Given two lists operator, and operand. The first list has basic algebra operations, and\n    the second list is a list of integers. Use the two given lists to build the algebric\n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + )\n    Subtraction ( - )\n    Multiplication ( * )\n    Floor division ( / )\n    Exponentiation ( ** )\n\n    Example:\n    operator[\"+\", \"*\", \"-\"]\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n     */\n    public int doAlgebra(List<String> operator, List<Integer> operand) {\n", "declaration": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int doAlgebra(List<String> operator, List<Integer> operand) {\n", "canonical_solution": "        List<String> ops = new ArrayList<>(operator);\n        List<Integer> nums = new ArrayList<>(operand);\n        for (int i = ops.size() - 1; i >= 0; i--) {\n            if (ops.get(i).equals(\"**\")) {\n                nums.set(i, (int) Math.round(Math.pow(nums.get(i), nums.get(i + 1))));\n                nums.remove(i + 1);\n                ops.remove(i);\n            }\n        }\n        for (int i = 0; i < ops.size(); i++) {\n            if (ops.get(i).equals(\"*\")) {\n                nums.set(i, nums.get(i) * nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            } else if (ops.get(i).equals(\"/\")) {\n                nums.set(i, nums.get(i) / nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            }\n        }\n        for (int i = 0; i < ops.size(); i++) {\n            if (ops.get(i).equals(\"+\")) {\n                nums.set(i, nums.get(i) + nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            } else if (ops.get(i).equals(\"-\")) {\n                nums.set(i, nums.get(i) - nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            }\n        }\n        return nums.get(0);\n    }\n}", "buggy_solution": "        List<String> ops = new ArrayList<>(operator);\n        List<Integer> nums = new ArrayList<>(operand);\n        for (int i = ops.size() - 1; i >= 0; i--) {\n            if (ops.get(i).equals(\"**\")) {\n                nums.set(i, (int) Math.round(Math.pow(nums.get(i + 1), nums.get(i + 1))));\n                nums.remove(i + 1);\n                ops.remove(i);\n            }\n        }\n        for (int i = 0; i < ops.size(); i++) {\n            if (ops.get(i).equals(\"*\")) {\n                nums.set(i, nums.get(i) * nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            } else if (ops.get(i).equals(\"/\")) {\n                nums.set(i, nums.get(i) / nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            }\n        }\n        for (int i = 0; i < ops.size(); i++) {\n            if (ops.get(i).equals(\"+\")) {\n                nums.set(i, nums.get(i) + nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            } else if (ops.get(i).equals(\"-\")) {\n                nums.set(i, nums.get(i) - nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            }\n        }\n        return nums.get(0);\n    }\n}", "bug_type": "excess logic", "failure_symptoms": "incorrect output", "entry_point": "doAlgebra", "import": "", "test_setup": "", "test": "\npublic class Main {\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        List<Boolean> correct = Arrays.asList(\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"**\", \"*\", \"+\")), new ArrayList<>(Arrays.asList(2, 3, 4, 5))) == 37,\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"+\", \"*\", \"-\")), new ArrayList<>(Arrays.asList(2, 3, 4, 5))) == 9,\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"/\", \"*\")), new ArrayList<>(Arrays.asList(7, 3, 4))) == 8,\n                s.doAlgebra(new ArrayList<>(Arrays.asList(\"+\", \"**\", \"**\")), new ArrayList<>(Arrays.asList(7, 5, 3, 2))) == 1953132\n        );\n        if (correct.contains(false)) {\n            throw new AssertionError();\n        }\n    }\n}", "example_test": "", "signature": "public int doAlgebra(List<String> operator, List<Integer> operand)", "docstring": "Given two lists operator, and operand. The first list has basic algebra operations, and\nthe second list is a list of integers. Use the two given lists to build the algebric\nexpression and return the evaluation of this expression.\nThe basic algebra operations:\nAddition ( + )\nSubtraction ( - )\nMultiplication ( * )\nFloor division ( / )\nExponentiation ( ** )\nExample:\noperator[\"+\", \"*\", \"-\"]\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\nNote:\nThe length of operator list is equal to the length of operand list minus one.\nOperand is a list of of non-negative integers.\nOperator list has at least one operator, and operand list has at least two operands.", "instruction": "Write a Java function `public int doAlgebra(List<String> operator, List<Integer> operand)` to solve the following problem:\nGiven two lists operator, and operand. The first list has basic algebra operations, and\nthe second list is a list of integers. Use the two given lists to build the algebric\nexpression and return the evaluation of this expression.\nThe basic algebra operations:\nAddition ( + )\nSubtraction ( - )\nMultiplication ( * )\nFloor division ( / )\nExponentiation ( ** )\nExample:\noperator[\"+\", \"*\", \"-\"]\narray = [2, 3, 4, 5]\nresult = 2 + 3 * 4 - 5\n=> result = 9\nNote:\nThe length of operator list is equal to the length of operand list minus one.\nOperand is a list of of non-negative integers.\nOperator list has at least one operator, and operand list has at least two operands.", "modified_context": "import java.util.*;\nimport java.lang.*;\n\nclass Solution {\n    public int doAlgebra(List<String> operator, List<Integer> operand) {\n        List<String> ops = new ArrayList<>(operator);\n        List<Integer> nums = new ArrayList<>(operand);\n        for (int i = ops.size() - 1; i >= 0; i--) {\n            if (ops.get(i).equals(\"**\")) {\n                nums.set(i, (int) Math.round(Math.pow(nums.get(i), nums.get(i + 1))));\n                nums.remove(i + 1);\n                ops.remove(i);\n            }\n        }\n        for (int i = 0; i < ops.size(); i++ ) {\n            if (ops.get(i).equals(\"*\")) {\n                nums.set(i, nums.get(i) * nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            } else if (ops.get(i).equals(\"/\")) {\n                nums.set(i, nums.get(i) / nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            }\n        }\n        for (int i = 0; i < ops.size(); i++ ) {\n            if (ops.get(i).equals(\"+\")) {\n                nums.set(i, nums.get(i) + nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            } else if (ops.get(i).equals(\"-\")) {\n                nums.set(i, nums.get(i) - nums.get(i + 1));\n                nums.remove(i + 1);\n                ops.remove(i);\n                i--;\n            }\n        }\n        return nums.get(0);\n    }\n}", "token_boundary_changed": false}
