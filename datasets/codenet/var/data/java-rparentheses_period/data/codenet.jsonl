{"id": "Java/4", "code": "import java.util.Scanner;\n\npublic class SampleSolution implements Runnable {\n\n    private static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Thread(null, new SampleSolution(), \"\", 128 * 1024 * 1024).start();\n    }\n\n    public void run() {\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        long cost1 = 0;\n        long cost2 = 0;\n        int current1 = 0;\n        int current2 = 0;\n        long[] dp1 = new long[n];\n        long[] dp2 = new long[n];\n        for (int i = 0, j = n - 1; i < n; i++, j--) {\n            cost1 += Math.abs(a[i] - current1);\n            current1 = a[i];\n            dp1[i] = cost1;\n            cost2 += Math.abs(a[j] - current2);\n            current2 = a[j];\n            dp2[j] = cost2;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                System.out.println(dp2[i + 1] + Math.abs(a[1]));\n            } else if (i == n - 1) {\n                System.out.println(dp1[i - 1] + Math.abs(a[i - 1]));\n            } else {\n                System.out.println(dp1[i - 1] + dp2[i + 1] + Math.abs(a[i - 1] - a[i + 1]));\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["3\n3 5 -1\n"], "output": ["12\n8\n10\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution implements Runnable {\n\n    private static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Thread(null, new SampleSolution(), \"\", 128 * 1024 * 1024) .start();\n    }\n\n    public void run() {\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        long cost1 = 0;\n        long cost2 = 0;\n        int current1 = 0;\n        int current2 = 0;\n        long[] dp1 = new long[n];\n        long[] dp2 = new long[n];\n        for (int i = 0, j = n - 1; i < n; i++, j--) {\n            cost1 += Math.abs(a[i] - current1);\n            current1 = a[i];\n            dp1[i] = cost1;\n            cost2 += Math.abs(a[j] - current2);\n            current2 = a[j];\n            dp2[j] = cost2;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                System.out.println(dp2[i + 1] + Math.abs(a[1]));\n            } else if (i == n - 1) {\n                System.out.println(dp1[i - 1] + Math.abs(a[i - 1]));\n            } else {\n                System.out.println(dp1[i - 1] + dp2[i + 1] + Math.abs(a[i - 1] - a[i + 1]));\n            }\n        }\n    }\n}\n"}
{"id": "Java/6", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] strs = reader.readLine().split(\" \");\n        int[] nums = new int[strs.length];\n        int top = 0;\n        for (int i = 0; i < strs.length; i++) {\n            switch (strs[i].charAt(0)) {\n                case '+':\n                    top--;\n                    nums[top - 1] = nums[top - 1] + nums[top];\n                    break;\n                case '-':\n                    top--;\n                    nums[top - 1] = nums[top - 1] - nums[top];\n                    break;\n                case '*':\n                    top--;\n                    nums[top - 1] = nums[top - 1] * nums[top];\n                    break;\n                default:\n                    nums[top] = Integer.parseInt(strs[i]);\n                    top++;\n                    break;\n            }\n        }\n        System.out.println(nums[0]);\n    }\n}\n", "test_IO": {"input": ["1 2 +\n"], "output": ["3\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] strs = reader.readLine() .split(\" \");\n        int[] nums = new int[strs.length];\n        int top = 0;\n        for (int i = 0; i < strs.length; i++) {\n            switch (strs[i].charAt(0)) {\n                case '+':\n                    top--;\n                    nums[top - 1] = nums[top - 1] + nums[top];\n                    break;\n                case '-':\n                    top--;\n                    nums[top - 1] = nums[top - 1] - nums[top];\n                    break;\n                case '*':\n                    top--;\n                    nums[top - 1] = nums[top - 1] * nums[top];\n                    break;\n                default:\n                    nums[top] = Integer.parseInt(strs[i]);\n                    top++;\n                    break;\n            }\n        }\n        System.out.println(nums[0]);\n    }\n}\n"}
{"id": "Java/7", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    static Scanner sc = new Scanner(System.in);\n    static String[] nums = sc.nextLine().split(\" \");\n\n    static int N = Integer.parseInt(nums[0]);\n    static int M = Integer.parseInt(nums[1]);\n    static char[][] room = new char[N][M];\n    static int D = Integer.parseInt(nums[2]);\n    static int num = 0;\n\n    public static void main(String[] args) {\n        inputRoom();\n\n        if (M >= D) {\n            setWE();\n        }\n\n        if (N >= D) {\n            setNS();\n        }\n\n        System.out.println(num);\n        sc.close();\n    }\n\n    private static void setWE() {\n        boolean canPut = true;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M - D + 1; j++) {\n                canPut = true;\n\n                for (int k = 0; k < D; k++) {\n                    if (SampleSolution.room[i][j + k] == '#') {\n                        canPut = false;\n                        break;\n                    }\n                }\n\n                if (canPut == true) {\n                    num++;\n                }\n            }\n        }\n    }\n\n    private static void setNS() {\n        boolean canPut = true;\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N - D + 1; j++) {\n                canPut = true;\n\n                for (int k = 0; k < D; k++) {\n                    if (SampleSolution.room[j + k][i] == '#') {\n                        canPut = false;\n                        break;\n                    }\n                }\n\n                if (canPut == true) {\n                    num++;\n                }\n            }\n        }\n    }\n\n    private static void inputRoom() {\n        String str_room = \"\";\n\n        for (int i = 0; i < N; i++) {\n            str_room = sc.nextLine();\n            SampleSolution.room[i] = str_room.toCharArray();\n        }\n    }\n}\n", "test_IO": {"input": ["3 5 2\n...#.\n#...#\n....#\n"], "output": ["12\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    static Scanner sc = new Scanner(System.in);\n    static String[] nums = sc.nextLine() .split(\" \");\n\n    static int N = Integer.parseInt(nums[0]);\n    static int M = Integer.parseInt(nums[1]);\n    static char[][] room = new char[N][M];\n    static int D = Integer.parseInt(nums[2]);\n    static int num = 0;\n\n    public static void main(String[] args) {\n        inputRoom();\n\n        if (M >= D) {\n            setWE();\n        }\n\n        if (N >= D) {\n            setNS();\n        }\n\n        System.out.println(num);\n        sc.close();\n    }\n\n    private static void setWE() {\n        boolean canPut = true;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < M - D + 1; j++) {\n                canPut = true;\n\n                for (int k = 0; k < D; k++) {\n                    if (SampleSolution.room[i][j + k] == '#') {\n                        canPut = false;\n                        break;\n                    }\n                }\n\n                if (canPut == true) {\n                    num++;\n                }\n            }\n        }\n    }\n\n    private static void setNS() {\n        boolean canPut = true;\n\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < N - D + 1; j++) {\n                canPut = true;\n\n                for (int k = 0; k < D; k++) {\n                    if (SampleSolution.room[j + k][i] == '#') {\n                        canPut = false;\n                        break;\n                    }\n                }\n\n                if (canPut == true) {\n                    num++;\n                }\n            }\n        }\n    }\n\n    private static void inputRoom() {\n        String str_room = \"\";\n\n        for (int i = 0; i < N; i++) {\n            str_room = sc.nextLine();\n            SampleSolution.room[i] = str_room.toCharArray();\n        }\n    }\n}\n"}
{"id": "Java/9", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] a = new int[n];\n        String[] elements = br.readLine().split(\" \");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(elements[i]);\n        }\n\n        int swapCount = 0;\n\n        for (int i = 0; i < a.length; i++) {\n            int mini = i;\n\n            for (int j = i; j < a.length; j++) {\n                if (a[j] < a[mini]) {\n                    mini = j;\n                }\n            }\n\n            if (mini != i) {\n                int v = a[mini];\n                a[mini] = a[i];\n                a[i] = v;\n\n                swapCount++;\n            }\n        }\n\n        String ans = String.valueOf(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            ans += \" \" + a[i];\n        }\n\n        System.out.println(ans);\n        System.out.println(swapCount);\n    }\n}\n", "test_IO": {"input": ["6\n5 6 4 2 1 3\n"], "output": ["1 2 3 4 5 6\n4\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] a = new int[n];\n        String[] elements = br.readLine() .split(\" \");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(elements[i]);\n        }\n\n        int swapCount = 0;\n\n        for (int i = 0; i < a.length; i++) {\n            int mini = i;\n\n            for (int j = i; j < a.length; j++) {\n                if (a[j] < a[mini]) {\n                    mini = j;\n                }\n            }\n\n            if (mini != i) {\n                int v = a[mini];\n                a[mini] = a[i];\n                a[i] = v;\n\n                swapCount++;\n            }\n        }\n\n        String ans = String.valueOf(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            ans += \" \" + a[i];\n        }\n\n        System.out.println(ans);\n        System.out.println(swapCount);\n    }\n}\n"}
{"id": "Java/12", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n\n        for (int i = 0; i < k; i++) {\n            int d = scanner.nextInt();\n            for (int j = 0; j < d; j++) {\n                int person = scanner.nextInt();\n\n                if (!map.containsKey(person)) {\n                    map.put(person, new ArrayList<>());\n                }\n                map.get(person).add(d);\n            }\n        }\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (!map.containsKey(i)) {\n                count++;\n            }\n        }\n\n        System.out.println(count);\n    }\n}\n", "test_IO": {"input": ["3 2\n2\n1 3\n1\n3\n"], "output": ["1\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n\n        for (int i = 0; i < k; i++) {\n            int d = scanner.nextInt();\n            for (int j = 0; j < d; j++) {\n                int person = scanner.nextInt();\n\n                if (!map.containsKey(person)) {\n                    map.put(person, new ArrayList<>());\n                }\n                map.get(person) .add(d);\n            }\n        }\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (!map.containsKey(i)) {\n                count++;\n            }\n        }\n\n        System.out.println(count);\n    }\n}\n"}
{"id": "Java/14", "code": "import static java.lang.System.out;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        new SampleSolution().run();\n    }\n\n    MyInput in = new MyInput();\n\n    public void run() {\n        String Sd = in.next();\n        String T = in.next();\n        int count = 0;\n        char c;\n        boolean ok = false;\n        int first = -1;\n        int end = -1;\n        for (int j = 0; j < Sd.length(); j++) {\n            count = 0;\n            for (int i = 0; i + j < Sd.length(); i++) {\n                c = Sd.charAt(i + j);\n                if (c == '?' || c == T.charAt(count)) {\n                    count++;\n                    if (count == T.length()) {\n                        first = i + j - T.length() + 1;\n                        end = i + j;\n                        ok = true;\n                        break;\n                    }\n                } else count = 0;\n            }\n        }\n        if (ok) {\n            for (int i = 0; i < Sd.length(); i++) {\n                if (first <= i && i <= end) {\n                    out.print(T.charAt(i - first));\n                } else {\n                    if (Sd.charAt(i) == '?') out.print(\"a\");\n                    else out.print(Sd.charAt(i));\n                }\n            }\n            out.println();\n        } else {\n            out.println(\"UNRESTORABLE\");\n        }\n    }\n}\n\nclass MyInput {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "test_IO": {"input": ["?tc????\ncoder\n"], "output": ["atcoder\n"]}, "modified_context": "import static java.lang.System.out;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        new SampleSolution() .run();\n    }\n\n    MyInput in = new MyInput();\n\n    public void run() {\n        String Sd = in.next();\n        String T = in.next();\n        int count = 0;\n        char c;\n        boolean ok = false;\n        int first = -1;\n        int end = -1;\n        for (int j = 0; j < Sd.length(); j++) {\n            count = 0;\n            for (int i = 0; i + j < Sd.length(); i++) {\n                c = Sd.charAt(i + j);\n                if (c == '?' || c == T.charAt(count)) {\n                    count++;\n                    if (count == T.length()) {\n                        first = i + j - T.length() + 1;\n                        end = i + j;\n                        ok = true;\n                        break;\n                    }\n                } else count = 0;\n            }\n        }\n        if (ok) {\n            for (int i = 0; i < Sd.length(); i++) {\n                if (first <= i && i <= end) {\n                    out.print(T.charAt(i - first));\n                } else {\n                    if (Sd.charAt(i) == '?') out.print(\"a\");\n                    else out.print(Sd.charAt(i));\n                }\n            }\n            out.println();\n        } else {\n            out.println(\"UNRESTORABLE\");\n        }\n    }\n}\n\nclass MyInput {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n"}
{"id": "Java/16", "code": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class SampleSolution {\n    public static final Scanner in =\n            new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    public static final PrintStream out = System.out;\n    public static final PrintStream err = System.err;\n\n    public static void main(String[] args) {\n        String Si = in.next();\n        char[] S = new StringBuilder(Si).reverse().toString().toCharArray();\n\n        long[] dp = new long[13];\n        dp[0] = 1;\n\n        for (int i = 0, d = 1; i < S.length; i++, d = d * 10 % 13) {\n            long[] nd = new long[13];\n\n            err.println(\"d: \" + d + \", i: \" + i + \", S[i]: \" + S[i]);\n            char c = S[i];\n\n            if (Character.isDigit(c)) {\n                int x = (c - '0') * d;\n\n                for (int j = 0; j < 13; j++) {\n                    nd[(j + x) % 13] = dp[j];\n                }\n            } else {\n                for (int xi = 0; xi < 10; xi++) {\n                    int x = xi * d;\n\n                    for (int j = 0; j < 13; j++) {\n                        int ni = (j + x) % 13;\n                        nd[ni] = (nd[ni] + dp[j]) % 1000000007;\n                    }\n                }\n            }\n\n            err.println(Arrays.toString(nd));\n            dp = nd;\n        }\n\n        out.println(dp[5]);\n    }\n}\n", "test_IO": {"input": ["??2??5\n"], "output": ["768\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class SampleSolution {\n    public static final Scanner in =\n            new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    public static final PrintStream out = System.out;\n    public static final PrintStream err = System.err;\n\n    public static void main(String[] args) {\n        String Si = in.next();\n        char[] S = new StringBuilder(Si) .reverse() .toString() .toCharArray();\n\n        long[] dp = new long[13];\n        dp[0] = 1;\n\n        for (int i = 0, d = 1; i < S.length; i++, d = d * 10 % 13) {\n            long[] nd = new long[13];\n\n            err.println(\"d: \" + d + \", i: \" + i + \", S[i]: \" + S[i]);\n            char c = S[i];\n\n            if (Character.isDigit(c)) {\n                int x = (c - '0') * d;\n\n                for (int j = 0; j < 13; j++) {\n                    nd[(j + x) % 13] = dp[j];\n                }\n            } else {\n                for (int xi = 0; xi < 10; xi++) {\n                    int x = xi * d;\n\n                    for (int j = 0; j < 13; j++) {\n                        int ni = (j + x) % 13;\n                        nd[ni] = (nd[ni] + dp[j]) % 1000000007;\n                    }\n                }\n            }\n\n            err.println(Arrays.toString(nd));\n            dp = nd;\n        }\n\n        out.println(dp[5]);\n    }\n}\n"}
{"id": "Java/17", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    Scanner sc;\n    int max = 0, cur = 0;\n\n    void solve() {\n        int a = ni();\n        int b = ni();\n\n        System.out.println(Math.max(0, a - 2 * b));\n    }\n\n    SampleSolution() {\n        try {\n            sc = new Scanner(System.in);\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    int ni() {\n        int a = sc.nextInt();\n        return a;\n    }\n\n    long nl() {\n        return sc.nextLong();\n    }\n\n    float nf() {\n        float a = sc.nextFloat();\n        return a;\n    }\n\n    double nd() {\n        double a = sc.nextDouble();\n        return a;\n    }\n\n    String ns() {\n        return sc.nextLine();\n    }\n\n    StringTokenizer nst(String s) {\n        return new StringTokenizer(s);\n    }\n\n    void ia(int a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextInt();\n    }\n\n    void la(long a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextLong();\n    }\n\n    void fa(float a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextFloat();\n    }\n\n    void da(double a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextDouble();\n    }\n\n    void sa(String a[], boolean empty) {\n        if (empty) {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = \"\";\n            }\n        } else {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = ns();\n            }\n        }\n    }\n\n    void ida(int a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = ni();\n            }\n        }\n    }\n\n    void lda(long a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nl();\n            }\n        }\n    }\n\n    void dda(double a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nd();\n            }\n        }\n    }\n\n    int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n\n    double stod(String s) {\n        return Double.parseDouble(s);\n    }\n\n    long lmin(long a[]) {\n        long min = Long.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    int imin(int a[]) {\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    long lmax(long a[]) {\n        long max = Long.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    int imax(int a[]) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    boolean ibs(int a[], int toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    boolean lbs(long a[], long toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    int stb(String s) {\n        int sum = 0;\n        int k = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            sum += stoi(s.charAt(i) + \"\") * Math.pow(2, k++);\n        }\n        return sum;\n    }\n}\n", "test_IO": {"input": ["12 4\n"], "output": ["4\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    Scanner sc;\n    int max = 0, cur = 0;\n\n    void solve() {\n        int a = ni();\n        int b = ni();\n\n        System.out.println(Math.max(0, a - 2 * b));\n    }\n\n    SampleSolution() {\n        try {\n            sc = new Scanner(System.in);\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution() .solve();\n    }\n\n    int ni() {\n        int a = sc.nextInt();\n        return a;\n    }\n\n    long nl() {\n        return sc.nextLong();\n    }\n\n    float nf() {\n        float a = sc.nextFloat();\n        return a;\n    }\n\n    double nd() {\n        double a = sc.nextDouble();\n        return a;\n    }\n\n    String ns() {\n        return sc.nextLine();\n    }\n\n    StringTokenizer nst(String s) {\n        return new StringTokenizer(s);\n    }\n\n    void ia(int a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextInt();\n    }\n\n    void la(long a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextLong();\n    }\n\n    void fa(float a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextFloat();\n    }\n\n    void da(double a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextDouble();\n    }\n\n    void sa(String a[], boolean empty) {\n        if (empty) {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = \"\";\n            }\n        } else {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = ns();\n            }\n        }\n    }\n\n    void ida(int a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = ni();\n            }\n        }\n    }\n\n    void lda(long a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nl();\n            }\n        }\n    }\n\n    void dda(double a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nd();\n            }\n        }\n    }\n\n    int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n\n    double stod(String s) {\n        return Double.parseDouble(s);\n    }\n\n    long lmin(long a[]) {\n        long min = Long.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    int imin(int a[]) {\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    long lmax(long a[]) {\n        long max = Long.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    int imax(int a[]) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    boolean ibs(int a[], int toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    boolean lbs(long a[], long toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    int stb(String s) {\n        int sum = 0;\n        int k = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            sum += stoi(s.charAt(i) + \"\") * Math.pow(2, k++);\n        }\n        return sum;\n    }\n}\n"}
{"id": "Java/18", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n        BufferedReader in = new BufferedReader(reader);\n        String[] str = in.readLine().split(\" \");\n        int n = Integer.parseInt(str[0]);\n        double d = Integer.parseInt(str[1]);\n        int cnt = 0;\n\n        for (int i = 0; i < n; i++) {\n            str = in.readLine().split(\" \");\n            double x = Integer.parseInt(str[0]);\n            double y = Integer.parseInt(str[1]);\n            if (Math.sqrt(x * x + y * y) <= d) {\n                cnt++;\n            }\n        }\n        System.out.println(cnt);\n    }\n}\n", "test_IO": {"input": ["4 5\n0 5\n-2 4\n3 4\n4 -4\n"], "output": ["3\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.nio.charset.StandardCharsets;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n        BufferedReader in = new BufferedReader(reader);\n        String[] str = in.readLine() .split(\" \");\n        int n = Integer.parseInt(str[0]);\n        double d = Integer.parseInt(str[1]);\n        int cnt = 0;\n\n        for (int i = 0; i < n; i++) {\n            str = in.readLine() .split(\" \");\n            double x = Integer.parseInt(str[0]);\n            double y = Integer.parseInt(str[1]);\n            if (Math.sqrt(x * x + y * y) <= d) {\n                cnt++;\n            }\n        }\n        System.out.println(cnt);\n    }\n}\n"}
{"id": "Java/19", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SampleSolution {\n    static final long MOD1 = 1000000007;\n    static final long MOD2 = 998244353;\n    static long[] tenmod;\n    static final long inv9 = modInv(9);\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputReader sc = new InputReader(System.in);\n        int N = sc.nextInt();\n        int Q = sc.nextInt();\n        tenmod = new long[N + 1];\n        tenmod[0] = 1;\n        for (int j = 1; j <= N; j++) {\n            tenmod[j] = (tenmod[j - 1] * 10L) % MOD2;\n        }\n        S[] dat = new S[N];\n        Arrays.setAll(dat, i -> new S(tenmod[N - i - 1], i, i));\n        LazySegTree<S, F> lazySegTree =\n                new LazySegTree<S, F>(dat, S::op, S.E, S::map, F::composite, F.I);\n        for (int j = 0; j < Q; j++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt() - 1;\n            long D = sc.nextLong();\n            lazySegTree.apply(l, r + 1, new F(D, N));\n            out.println(lazySegTree.allProd().sum);\n        }\n        out.flush();\n    }\n\n    static class S {\n        static final S E = new S(0, Integer.MAX_VALUE / 2, Integer.MIN_VALUE / 2);\n        long sum;\n        int l;\n        int r;\n\n        public S(long sum, int l, int r) {\n            super();\n            this.sum = sum;\n            this.l = l;\n            this.r = r;\n        }\n\n        public static S op(S s1, S s2) {\n            long sum = s1.sum + s2.sum;\n            if (sum >= MOD2) {\n                sum -= MOD2;\n            }\n            return new S(sum, Math.min(s1.l, s2.l), Math.max(s1.r, s2.r));\n        }\n\n        static S map(F f, S s) {\n            long c = (tenmod[(f.N - s.l)] - tenmod[(f.N - s.r - 1)]);\n            if (c < 0) {\n                c += MOD2;\n            }\n            return new S(((f.D * c) % MOD2 * inv9) % MOD2, s.l, s.r);\n        }\n    }\n\n    static class F {\n        static final F I = new F(0, 0);\n        long D;\n        int N;\n\n        public F(long D, int N) {\n            super();\n            this.D = D;\n            this.N = N;\n        }\n\n        public static F composite(F f, F g) {\n            return new F(f.D, f.N);\n        }\n    }\n\n    static long modInv(long x) {\n        return modPow(x, MOD2 - 2);\n    }\n\n    static long modPow(long x, long y) {\n        long z = 1;\n        while (y > 0) {\n            if (y % 2 == 0) {\n                x = (x * x) % MOD2;\n                y /= 2;\n            } else {\n                z = (z * x) % MOD2;\n                y--;\n            }\n        }\n        return z;\n    }\n\n    static class LazySegTree<S, F> {\n        final int MAX;\n\n        final int N;\n        final int Log;\n        final java.util.function.BinaryOperator<S> Op;\n        final S E;\n        final java.util.function.BiFunction<F, S, S> Mapping;\n        final java.util.function.BinaryOperator<F> Composition;\n        final F Id;\n\n        final S[] Dat;\n        final F[] Laz;\n\n        @SuppressWarnings(\"unchecked\")\n        public LazySegTree(\n                int n,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this.MAX = n;\n            int k = 1;\n            while (k < n) k <<= 1;\n            this.N = k;\n            this.Log = Integer.numberOfTrailingZeros(N);\n            this.Op = op;\n            this.E = e;\n            this.Mapping = mapping;\n            this.Composition = composition;\n            this.Id = id;\n            this.Dat = (S[]) new Object[N << 1];\n            this.Laz = (F[]) new Object[N];\n            java.util.Arrays.fill(Dat, E);\n            java.util.Arrays.fill(Laz, Id);\n        }\n\n        public LazySegTree(\n                S[] dat,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this(dat.length, op, e, mapping, composition, id);\n            build(dat);\n        }\n\n        private void build(S[] dat) {\n            int l = dat.length;\n            System.arraycopy(dat, 0, Dat, N, l);\n            for (int i = N - 1; i > 0; i--) {\n                Dat[i] = Op.apply(Dat[i << 1 | 0], Dat[i << 1 | 1]);\n            }\n        }\n\n        private void push(int k) {\n            if (Laz[k] == Id) return;\n            int lk = k << 1 | 0, rk = k << 1 | 1;\n            Dat[lk] = Mapping.apply(Laz[k], Dat[lk]);\n            Dat[rk] = Mapping.apply(Laz[k], Dat[rk]);\n            if (lk < N) Laz[lk] = Composition.apply(Laz[k], Laz[lk]);\n            if (rk < N) Laz[rk] = Composition.apply(Laz[k], Laz[rk]);\n            Laz[k] = Id;\n        }\n\n        private void pushTo(int k) {\n            for (int i = Log; i > 0; i--) push(k >> i);\n        }\n\n        private void pushTo(int lk, int rk) {\n            for (int i = Log; i > 0; i--) {\n                if (((lk >> i) << i) != lk) push(lk >> i);\n                if (((rk >> i) << i) != rk) push(rk >> i);\n            }\n        }\n\n        private void updateFrom(int k) {\n            k >>= 1;\n            while (k > 0) {\n                Dat[k] = Op.apply(Dat[k << 1 | 0], Dat[k << 1 | 1]);\n                k >>= 1;\n            }\n        }\n\n        private void updateFrom(int lk, int rk) {\n            for (int i = 1; i <= Log; i++) {\n                if (((lk >> i) << i) != lk) {\n                    int lki = lk >> i;\n                    Dat[lki] = Op.apply(Dat[lki << 1 | 0], Dat[lki << 1 | 1]);\n                }\n                if (((rk >> i) << i) != rk) {\n                    int rki = (rk - 1) >> i;\n                    Dat[rki] = Op.apply(Dat[rki << 1 | 0], Dat[rki << 1 | 1]);\n                }\n            }\n        }\n\n        public void set(int p, S x) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = x;\n            updateFrom(p);\n        }\n\n        public S get(int p) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            return Dat[p];\n        }\n\n        public S allProd() {\n            return Dat[1];\n        }\n\n        public void apply(int p, F f) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = Mapping.apply(f, Dat[p]);\n            updateFrom(p);\n        }\n\n        public void apply(int l, int r, F f) {\n            if (l > r) {\n                throw new IllegalArgumentException(String.format(\"Invalid range: [%d, %d)\", l, r));\n            }\n            inclusiveRangeCheck(l);\n            inclusiveRangeCheck(r);\n            if (l == r) return;\n            l += N;\n            r += N;\n            pushTo(l, r);\n            for (int l2 = l, r2 = r; l2 < r2; ) {\n                if ((l2 & 1) == 1) {\n                    Dat[l2] = Mapping.apply(f, Dat[l2]);\n                    if (l2 < N) Laz[l2] = Composition.apply(f, Laz[l2]);\n                    l2++;\n                }\n                if ((r2 & 1) == 1) {\n                    r2--;\n                    Dat[r2] = Mapping.apply(f, Dat[r2]);\n                    if (r2 < N) Laz[r2] = Composition.apply(f, Laz[r2]);\n                }\n                l2 >>= 1;\n                r2 >>= 1;\n            }\n            updateFrom(l, r);\n        }\n\n        public int maxRight(int l, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(l);\n            if (!g.test(E)) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (l == MAX) return MAX;\n            l += N;\n            pushTo(l);\n            S sum = E;\n            do {\n                l >>= Integer.numberOfTrailingZeros(l);\n                if (!g.test(Op.apply(sum, Dat[l]))) {\n                    while (l < N) {\n                        push(l);\n                        l = l << 1;\n                        if (g.test(Op.apply(sum, Dat[l]))) {\n                            sum = Op.apply(sum, Dat[l]);\n                            l++;\n                        }\n                    }\n                    return l - N;\n                }\n                sum = Op.apply(sum, Dat[l]);\n                l++;\n            } while ((l & -l) != l);\n            return MAX;\n        }\n\n        public int minLeft(int r, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(r);\n            if (!g.test(E)) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (r == 0) return 0;\n            r += N;\n            pushTo(r - 1);\n            S sum = E;\n            do {\n                r--;\n                while (r > 1 && (r & 1) == 1) r >>= 1;\n                if (!g.test(Op.apply(Dat[r], sum))) {\n                    while (r < N) {\n                        push(r);\n                        r = r << 1 | 1;\n                        if (g.test(Op.apply(Dat[r], sum))) {\n                            sum = Op.apply(Dat[r], sum);\n                            r--;\n                        }\n                    }\n                    return r + 1 - N;\n                }\n                sum = Op.apply(Dat[r], sum);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n        private void exclusiveRangeCheck(int p) {\n            if (p < 0 || p >= MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d).\", p, 0, MAX));\n            }\n        }\n\n        private void inclusiveRangeCheck(int p) {\n            if (p < 0 || p > MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d].\", p, 0, MAX));\n            }\n        }\n\n        private int indent = 6;\n\n        public void setIndent(int newIndent) {\n            this.indent = newIndent;\n        }\n\n        @Override\n        public String toString() {\n            return makeString(1, 0);\n        }\n\n        private String makeString(int k, int sp) {\n            if (k >= N) return indent(sp) + Dat[k];\n            String s = \"\";\n            s += makeString(k << 1 | 1, sp + indent);\n            s += \"\\n\";\n            s += indent(sp) + Dat[k] + \"/\" + Laz[k];\n            s += \"\\n\";\n            s += makeString(k << 1 | 0, sp + indent);\n            return s;\n        }\n\n        private static String indent(int n) {\n            StringBuilder sb = new StringBuilder();\n            while (n-- > 0) sb.append(' ');\n            return sb.toString();\n        }\n    }\n\n    static class InputReader {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n\n        public InputReader(InputStream in) {\n            this.in = in;\n            this.curbuf = this.lenbuf = 0;\n        }\n\n        public boolean hasNextByte() {\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return false;\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[curbuf++];\n            else return -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private void skip() {\n            while (hasNextByte() && isSpaceChar(buffer[curbuf])) curbuf++;\n        }\n\n        public boolean hasNext() {\n            skip();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isSpaceChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            if (!hasNext()) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        public char[][] nextCharMap(int n, int m) {\n            char[][] map = new char[n][m];\n            for (int i = 0; i < n; i++) map[i] = next().toCharArray();\n            return map;\n        }\n    }\n}\n", "test_IO": {"input": ["8 5\n3 6 2\n1 4 7\n3 8 3\n2 2 2\n4 5 1\n"], "output": ["11222211\n77772211\n77333333\n72333333\n72311333\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SampleSolution {\n    static final long MOD1 = 1000000007;\n    static final long MOD2 = 998244353;\n    static long[] tenmod;\n    static final long inv9 = modInv(9);\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputReader sc = new InputReader(System.in);\n        int N = sc.nextInt();\n        int Q = sc.nextInt();\n        tenmod = new long[N + 1];\n        tenmod[0] = 1;\n        for (int j = 1; j <= N; j++) {\n            tenmod[j] = (tenmod[j - 1] * 10L) % MOD2;\n        }\n        S[] dat = new S[N];\n        Arrays.setAll(dat, i -> new S(tenmod[N - i - 1], i, i));\n        LazySegTree<S, F> lazySegTree =\n                new LazySegTree<S, F>(dat, S::op, S.E, S::map, F::composite, F.I);\n        for (int j = 0; j < Q; j++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt() - 1;\n            long D = sc.nextLong();\n            lazySegTree.apply(l, r + 1, new F(D, N));\n            out.println(lazySegTree.allProd() .sum);\n        }\n        out.flush();\n    }\n\n    static class S {\n        static final S E = new S(0, Integer.MAX_VALUE / 2, Integer.MIN_VALUE / 2);\n        long sum;\n        int l;\n        int r;\n\n        public S(long sum, int l, int r) {\n            super();\n            this.sum = sum;\n            this.l = l;\n            this.r = r;\n        }\n\n        public static S op(S s1, S s2) {\n            long sum = s1.sum + s2.sum;\n            if (sum >= MOD2) {\n                sum -= MOD2;\n            }\n            return new S(sum, Math.min(s1.l, s2.l), Math.max(s1.r, s2.r));\n        }\n\n        static S map(F f, S s) {\n            long c = (tenmod[(f.N - s.l)] - tenmod[(f.N - s.r - 1)]);\n            if (c < 0) {\n                c += MOD2;\n            }\n            return new S(((f.D * c) % MOD2 * inv9) % MOD2, s.l, s.r);\n        }\n    }\n\n    static class F {\n        static final F I = new F(0, 0);\n        long D;\n        int N;\n\n        public F(long D, int N) {\n            super();\n            this.D = D;\n            this.N = N;\n        }\n\n        public static F composite(F f, F g) {\n            return new F(f.D, f.N);\n        }\n    }\n\n    static long modInv(long x) {\n        return modPow(x, MOD2 - 2);\n    }\n\n    static long modPow(long x, long y) {\n        long z = 1;\n        while (y > 0) {\n            if (y % 2 == 0) {\n                x = (x * x) % MOD2;\n                y /= 2;\n            } else {\n                z = (z * x) % MOD2;\n                y--;\n            }\n        }\n        return z;\n    }\n\n    static class LazySegTree<S, F> {\n        final int MAX;\n\n        final int N;\n        final int Log;\n        final java.util.function.BinaryOperator<S> Op;\n        final S E;\n        final java.util.function.BiFunction<F, S, S> Mapping;\n        final java.util.function.BinaryOperator<F> Composition;\n        final F Id;\n\n        final S[] Dat;\n        final F[] Laz;\n\n        @SuppressWarnings(\"unchecked\")\n        public LazySegTree(\n                int n,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this.MAX = n;\n            int k = 1;\n            while (k < n) k <<= 1;\n            this.N = k;\n            this.Log = Integer.numberOfTrailingZeros(N);\n            this.Op = op;\n            this.E = e;\n            this.Mapping = mapping;\n            this.Composition = composition;\n            this.Id = id;\n            this.Dat = (S[]) new Object[N << 1];\n            this.Laz = (F[]) new Object[N];\n            java.util.Arrays.fill(Dat, E);\n            java.util.Arrays.fill(Laz, Id);\n        }\n\n        public LazySegTree(\n                S[] dat,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this(dat.length, op, e, mapping, composition, id);\n            build(dat);\n        }\n\n        private void build(S[] dat) {\n            int l = dat.length;\n            System.arraycopy(dat, 0, Dat, N, l);\n            for (int i = N - 1; i > 0; i--) {\n                Dat[i] = Op.apply(Dat[i << 1 | 0], Dat[i << 1 | 1]);\n            }\n        }\n\n        private void push(int k) {\n            if (Laz[k] == Id) return;\n            int lk = k << 1 | 0, rk = k << 1 | 1;\n            Dat[lk] = Mapping.apply(Laz[k], Dat[lk]);\n            Dat[rk] = Mapping.apply(Laz[k], Dat[rk]);\n            if (lk < N) Laz[lk] = Composition.apply(Laz[k], Laz[lk]);\n            if (rk < N) Laz[rk] = Composition.apply(Laz[k], Laz[rk]);\n            Laz[k] = Id;\n        }\n\n        private void pushTo(int k) {\n            for (int i = Log; i > 0; i--) push(k >> i);\n        }\n\n        private void pushTo(int lk, int rk) {\n            for (int i = Log; i > 0; i--) {\n                if (((lk >> i) << i) != lk) push(lk >> i);\n                if (((rk >> i) << i) != rk) push(rk >> i);\n            }\n        }\n\n        private void updateFrom(int k) {\n            k >>= 1;\n            while (k > 0) {\n                Dat[k] = Op.apply(Dat[k << 1 | 0], Dat[k << 1 | 1]);\n                k >>= 1;\n            }\n        }\n\n        private void updateFrom(int lk, int rk) {\n            for (int i = 1; i <= Log; i++) {\n                if (((lk >> i) << i) != lk) {\n                    int lki = lk >> i;\n                    Dat[lki] = Op.apply(Dat[lki << 1 | 0], Dat[lki << 1 | 1]);\n                }\n                if (((rk >> i) << i) != rk) {\n                    int rki = (rk - 1) >> i;\n                    Dat[rki] = Op.apply(Dat[rki << 1 | 0], Dat[rki << 1 | 1]);\n                }\n            }\n        }\n\n        public void set(int p, S x) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = x;\n            updateFrom(p);\n        }\n\n        public S get(int p) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            return Dat[p];\n        }\n\n        public S allProd() {\n            return Dat[1];\n        }\n\n        public void apply(int p, F f) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = Mapping.apply(f, Dat[p]);\n            updateFrom(p);\n        }\n\n        public void apply(int l, int r, F f) {\n            if (l > r) {\n                throw new IllegalArgumentException(String.format(\"Invalid range: [%d, %d)\", l, r));\n            }\n            inclusiveRangeCheck(l);\n            inclusiveRangeCheck(r);\n            if (l == r) return;\n            l += N;\n            r += N;\n            pushTo(l, r);\n            for (int l2 = l, r2 = r; l2 < r2; ) {\n                if ((l2 & 1) == 1) {\n                    Dat[l2] = Mapping.apply(f, Dat[l2]);\n                    if (l2 < N) Laz[l2] = Composition.apply(f, Laz[l2]);\n                    l2++;\n                }\n                if ((r2 & 1) == 1) {\n                    r2--;\n                    Dat[r2] = Mapping.apply(f, Dat[r2]);\n                    if (r2 < N) Laz[r2] = Composition.apply(f, Laz[r2]);\n                }\n                l2 >>= 1;\n                r2 >>= 1;\n            }\n            updateFrom(l, r);\n        }\n\n        public int maxRight(int l, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(l);\n            if (!g.test(E)) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (l == MAX) return MAX;\n            l += N;\n            pushTo(l);\n            S sum = E;\n            do {\n                l >>= Integer.numberOfTrailingZeros(l);\n                if (!g.test(Op.apply(sum, Dat[l]))) {\n                    while (l < N) {\n                        push(l);\n                        l = l << 1;\n                        if (g.test(Op.apply(sum, Dat[l]))) {\n                            sum = Op.apply(sum, Dat[l]);\n                            l++;\n                        }\n                    }\n                    return l - N;\n                }\n                sum = Op.apply(sum, Dat[l]);\n                l++;\n            } while ((l & -l) != l);\n            return MAX;\n        }\n\n        public int minLeft(int r, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(r);\n            if (!g.test(E)) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (r == 0) return 0;\n            r += N;\n            pushTo(r - 1);\n            S sum = E;\n            do {\n                r--;\n                while (r > 1 && (r & 1) == 1) r >>= 1;\n                if (!g.test(Op.apply(Dat[r], sum))) {\n                    while (r < N) {\n                        push(r);\n                        r = r << 1 | 1;\n                        if (g.test(Op.apply(Dat[r], sum))) {\n                            sum = Op.apply(Dat[r], sum);\n                            r--;\n                        }\n                    }\n                    return r + 1 - N;\n                }\n                sum = Op.apply(Dat[r], sum);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n        private void exclusiveRangeCheck(int p) {\n            if (p < 0 || p >= MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d).\", p, 0, MAX));\n            }\n        }\n\n        private void inclusiveRangeCheck(int p) {\n            if (p < 0 || p > MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d].\", p, 0, MAX));\n            }\n        }\n\n        private int indent = 6;\n\n        public void setIndent(int newIndent) {\n            this.indent = newIndent;\n        }\n\n        @Override\n        public String toString() {\n            return makeString(1, 0);\n        }\n\n        private String makeString(int k, int sp) {\n            if (k >= N) return indent(sp) + Dat[k];\n            String s = \"\";\n            s += makeString(k << 1 | 1, sp + indent);\n            s += \"\\n\";\n            s += indent(sp) + Dat[k] + \"/\" + Laz[k];\n            s += \"\\n\";\n            s += makeString(k << 1 | 0, sp + indent);\n            return s;\n        }\n\n        private static String indent(int n) {\n            StringBuilder sb = new StringBuilder();\n            while (n-- > 0) sb.append(' ');\n            return sb.toString();\n        }\n    }\n\n    static class InputReader {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n\n        public InputReader(InputStream in) {\n            this.in = in;\n            this.curbuf = this.lenbuf = 0;\n        }\n\n        public boolean hasNextByte() {\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return false;\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[curbuf++];\n            else return -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private void skip() {\n            while (hasNextByte() && isSpaceChar(buffer[curbuf])) curbuf++;\n        }\n\n        public boolean hasNext() {\n            skip();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isSpaceChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            if (!hasNext()) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        public char[][] nextCharMap(int n, int m) {\n            char[][] map = new char[n][m];\n            for (int i = 0; i < n; i++) map[i] = next() .toCharArray();\n            return map;\n        }\n    }\n}\n"}
{"id": "Java/20", "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String sc = br.readLine();\n        int n = Integer.parseInt(sc);\n        String[] str = new String[n];\n        for (int i = 0; i < n; i++) {\n            str[i] = br.readLine();\n        }\n        String[] mark = {\"S\", \"H\", \"C\", \"D\"};\n        for (String ma : mark) {\n            for (int i = 1; i <= 13; i++) {\n                String s = Integer.toString(i);\n                String st = ma + \" \" + s;\n                if (Arrays.asList(str).contains(st)) {\n                    continue;\n                } else {\n                    System.out.println(st);\n                }\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["47\nS 10\nS 11\nS 12\nS 13\nH 1\nH 2\nS 6\nS 7\nS 8\nS 9\nH 6\nH 8\nH 9\nH 10\nH 11\nH 4\nH 5\nS 2\nS 3\nS 4\nS 5\nH 12\nH 13\nC 1\nC 2\nD 1\nD 2\nD 3\nD 4\nD 5\nD 6\nD 7\nC 3\nC 4\nC 5\nC 6\nC 7\nC 8\nC 9\nC 10\nC 11\nC 13\nD 9\nD 10\nD 11\nD 12\nD 13\n"], "output": ["S 1\nH 3\nH 7\nC 12\nD 8\n"]}, "modified_context": "import java.io.*;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String sc = br.readLine();\n        int n = Integer.parseInt(sc);\n        String[] str = new String[n];\n        for (int i = 0; i < n; i++) {\n            str[i] = br.readLine();\n        }\n        String[] mark = {\"S\", \"H\", \"C\", \"D\"};\n        for (String ma : mark) {\n            for (int i = 1; i <= 13; i++) {\n                String s = Integer.toString(i);\n                String st = ma + \" \" + s;\n                if (Arrays.asList(str) .contains(st)) {\n                    continue;\n                } else {\n                    System.out.println(st);\n                }\n            }\n        }\n    }\n}\n"}
{"id": "Java/24", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        MyWriter out = new MyWriter(System.out);\n\n        MyScanner sc = new MyScanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        LinkedList<Integer>[] list = new LinkedList[100001];\n\n        for (int i = 0; i < N; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if (list[a] == null) {\n                list[a] = new LinkedList<Integer>();\n            }\n            list[a].add(b);\n        }\n\n        int res = 0;\n        PriorityQueue<Integer> pqueue = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int i = 1; i <= M; i++) {\n            if (list[i] != null) {\n                pqueue.addAll(list[i]);\n            }\n            if (!pqueue.isEmpty()) res += pqueue.poll();\n        }\n\n        out.println(res);\n        out.flush();\n    }\n\n    static final class MyScanner {\n        static final int BUFFER_SIZE = 8192;\n        private final InputStream in;\n        private final byte[] buffer = new byte[BUFFER_SIZE];\n        private int point;\n        private int readLength;\n\n        MyScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private int readByte() {\n            if (point < readLength) {\n                int result = buffer[point];\n                point += 1;\n                return result;\n            }\n            try {\n                readLength = in.read(buffer);\n            } catch (IOException e) {\n                throw new AssertionError(null, e);\n            }\n            if (readLength == -1) {\n                return -1;\n            }\n            point = 1;\n            return buffer[0];\n        }\n\n        private static boolean isPrintableCharExceptSpace(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        String next() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder b = new StringBuilder();\n            do {\n                b.appendCodePoint(c);\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c));\n            return b.toString();\n        }\n\n        long nextLong() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long result = 0L;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                result = result * 10L + (c - '0');\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c));\n            return minus ? -result : result;\n        }\n\n        int nextInt() {\n            long n = nextLong();\n            if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n                throw new InputMismatchException();\n            }\n            return (int) n;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] result = new int[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextInt();\n            }\n            return result;\n        }\n\n        private static boolean allSameLength(int[] a, int[] b, int[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (int[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static boolean allSameLength(char[] a, char[] b, char[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (char[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        void nextVerticalIntArrays(int[] a, int[] b, int[]... c) {\n            if (!allSameLength(a, b, c)) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n                b[i] = nextInt();\n                for (int[] d : c) {\n                    d[i] = nextInt();\n                }\n            }\n        }\n\n        long[] nextLongArray(int n) {\n            long[] result = new long[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextLong();\n            }\n            return result;\n        }\n\n        char nextChar() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            return (char) c;\n        }\n\n        char[] nextCharArray(int n) {\n            char[] result = new char[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextChar();\n            }\n            return result;\n        }\n\n        char[][] next2dCharArray(int n, int m) {\n            char[][] result = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    result[i][j] = nextChar();\n                }\n            }\n            return result;\n        }\n\n        void nextVerticalCharArrays(char[] a, char[] b, char[]... c) {\n            if (!allSameLength(a, b, c)) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextChar();\n                b[i] = nextChar();\n                for (char[] d : c) {\n                    d[i] = nextChar();\n                }\n            }\n        }\n    }\n\n    static final class MyWriter extends PrintWriter {\n        MyWriter(OutputStream out) {\n            super(out);\n        }\n\n        void joinAndPrintln(int[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(int[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter).append(x[i]);\n                }\n            }\n            println(b.toString());\n        }\n\n        void joinAndPrintln(long[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(long[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter).append(x[i]);\n                }\n            }\n            println(b.toString());\n        }\n\n        void joinAndPrintln(Iterable<?> iterable) {\n            joinAndPrintln(iterable, \" \");\n        }\n\n        void joinAndPrintln(Iterable<?> iterable, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            for (Iterator<?> i = iterable.iterator(); i.hasNext(); ) {\n                b.append(i.next());\n                while (i.hasNext()) {\n                    b.append(delimiter).append(i.next());\n                }\n            }\n            println(b.toString());\n        }\n    }\n}\n", "test_IO": {"input": ["3 4\n4 3\n4 1\n2 2\n"], "output": ["5\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        MyWriter out = new MyWriter(System.out);\n\n        MyScanner sc = new MyScanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        LinkedList<Integer>[] list = new LinkedList[100001];\n\n        for (int i = 0; i < N; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if (list[a] == null) {\n                list[a] = new LinkedList<Integer>();\n            }\n            list[a].add(b);\n        }\n\n        int res = 0;\n        PriorityQueue<Integer> pqueue = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int i = 1; i <= M; i++) {\n            if (list[i] != null) {\n                pqueue.addAll(list[i]);\n            }\n            if (!pqueue.isEmpty()) res += pqueue.poll();\n        }\n\n        out.println(res);\n        out.flush();\n    }\n\n    static final class MyScanner {\n        static final int BUFFER_SIZE = 8192;\n        private final InputStream in;\n        private final byte[] buffer = new byte[BUFFER_SIZE];\n        private int point;\n        private int readLength;\n\n        MyScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private int readByte() {\n            if (point < readLength) {\n                int result = buffer[point];\n                point += 1;\n                return result;\n            }\n            try {\n                readLength = in.read(buffer);\n            } catch (IOException e) {\n                throw new AssertionError(null, e);\n            }\n            if (readLength == -1) {\n                return -1;\n            }\n            point = 1;\n            return buffer[0];\n        }\n\n        private static boolean isPrintableCharExceptSpace(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        String next() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder b = new StringBuilder();\n            do {\n                b.appendCodePoint(c);\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c));\n            return b.toString();\n        }\n\n        long nextLong() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long result = 0L;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                result = result * 10L + (c - '0');\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c));\n            return minus ? -result : result;\n        }\n\n        int nextInt() {\n            long n = nextLong();\n            if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n                throw new InputMismatchException();\n            }\n            return (int) n;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] result = new int[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextInt();\n            }\n            return result;\n        }\n\n        private static boolean allSameLength(int[] a, int[] b, int[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (int[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static boolean allSameLength(char[] a, char[] b, char[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (char[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        void nextVerticalIntArrays(int[] a, int[] b, int[]... c) {\n            if (!allSameLength(a, b, c)) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n                b[i] = nextInt();\n                for (int[] d : c) {\n                    d[i] = nextInt();\n                }\n            }\n        }\n\n        long[] nextLongArray(int n) {\n            long[] result = new long[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextLong();\n            }\n            return result;\n        }\n\n        char nextChar() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            return (char) c;\n        }\n\n        char[] nextCharArray(int n) {\n            char[] result = new char[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextChar();\n            }\n            return result;\n        }\n\n        char[][] next2dCharArray(int n, int m) {\n            char[][] result = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    result[i][j] = nextChar();\n                }\n            }\n            return result;\n        }\n\n        void nextVerticalCharArrays(char[] a, char[] b, char[]... c) {\n            if (!allSameLength(a, b, c)) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextChar();\n                b[i] = nextChar();\n                for (char[] d : c) {\n                    d[i] = nextChar();\n                }\n            }\n        }\n    }\n\n    static final class MyWriter extends PrintWriter {\n        MyWriter(OutputStream out) {\n            super(out);\n        }\n\n        void joinAndPrintln(int[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(int[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter) .append(x[i]);\n                }\n            }\n            println(b.toString());\n        }\n\n        void joinAndPrintln(long[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(long[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter) .append(x[i]);\n                }\n            }\n            println(b.toString());\n        }\n\n        void joinAndPrintln(Iterable<?> iterable) {\n            joinAndPrintln(iterable, \" \");\n        }\n\n        void joinAndPrintln(Iterable<?> iterable, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            for (Iterator<?> i = iterable.iterator(); i.hasNext(); ) {\n                b.append(i.next());\n                while (i.hasNext()) {\n                    b.append(delimiter) .append(i.next());\n                }\n            }\n            println(b.toString());\n        }\n    }\n}\n"}
{"id": "Java/30", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\nclass SampleSolution {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static FastScanner sc = new FastScanner(br);\n    static PrintWriter out = new PrintWriter(System.out);\n    static Random rnd = new Random();\n\n    public static void main(String args[]) throws Exception {\n        int n = sc.nextInt();\n        long[] pre = new long[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1] + sc.nextLong();\n        }\n\n        long min = Long.MAX_VALUE;\n\n        for (int i = 1; i < n; i++) {\n            long val1 = pre[i], val2 = pre[n] - pre[i];\n\n            min = Math.min(min, Math.abs(val1 - val2));\n        }\n\n        out.println(min);\n        out.close();\n    }\n}\n\nclass FastScanner {\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\n    public String getNextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public String next() throws Exception {\n        return getNextToken().toString();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(getNextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(getNextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(getNextToken());\n    }\n}\n", "test_IO": {"input": ["6\n1 2 3 4 5 6\n"], "output": ["1\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\nclass SampleSolution {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static FastScanner sc = new FastScanner(br);\n    static PrintWriter out = new PrintWriter(System.out);\n    static Random rnd = new Random();\n\n    public static void main(String args[]) throws Exception {\n        int n = sc.nextInt();\n        long[] pre = new long[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1] + sc.nextLong();\n        }\n\n        long min = Long.MAX_VALUE;\n\n        for (int i = 1; i < n; i++) {\n            long val1 = pre[i], val2 = pre[n] - pre[i];\n\n            min = Math.min(min, Math.abs(val1 - val2));\n        }\n\n        out.println(min);\n        out.close();\n    }\n}\n\nclass FastScanner {\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\n    public String getNextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public String next() throws Exception {\n        return getNextToken() .toString();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(getNextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(getNextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(getNextToken());\n    }\n}\n"}
{"id": "Java/31", "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        try (Scanner scanner = new Scanner(System.in)) {\n            int n = scanner.nextInt();\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, n).forEach(i -> set.add(scanner.nextInt()));\n            System.out.println(set.size());\n        }\n    }\n}\n", "test_IO": {"input": ["4\n10\n8\n8\n6\n"], "output": ["3\n"]}, "modified_context": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        try (Scanner scanner = new Scanner(System.in)) {\n            int n = scanner.nextInt();\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, n) .forEach(i -> set.add(scanner.nextInt()));\n            System.out.println(set.size());\n        }\n    }\n}\n"}
{"id": "Java/35", "code": "import java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String[] s = \".,!? :abc:def:ghi:jkl:mno:pqrs:tuv:wxyz\".split(\":\");\n        char[][] k = new char[9][];\n        for (int i = 0; i < 9; i++) {\n            k[i] = s[i].toCharArray();\n        }\n        while (n-- > 0) {\n            char[] c = sc.next().toCharArray();\n            int l = -1, a = 0;\n            for (int i = 0; i < c.length; i++) {\n                if (c[i] != '0') {\n                    a = c[i] - '1';\n                    l = (l + 1) % k[a].length;\n                } else if (l >= 0) {\n                    System.out.print(k[a][l]);\n                    l = -1;\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n", "test_IO": {"input": ["5\n20\n220\n222220\n44033055505550666011011111090666077705550301110\n000555555550000330000444000080000200004440000\n"], "output": ["a\nb\nb\nhello, world!\nkeitai\n"]}, "modified_context": "import java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String[] s = \".,!? :abc:def:ghi:jkl:mno:pqrs:tuv:wxyz\".split(\":\");\n        char[][] k = new char[9][];\n        for (int i = 0; i < 9; i++) {\n            k[i] = s[i].toCharArray();\n        }\n        while (n-- > 0) {\n            char[] c = sc.next() .toCharArray();\n            int l = -1, a = 0;\n            for (int i = 0; i < c.length; i++) {\n                if (c[i] != '0') {\n                    a = c[i] - '1';\n                    l = (l + 1) % k[a].length;\n                } else if (l >= 0) {\n                    System.out.print(k[a][l]);\n                    l = -1;\n                }\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": "Java/42", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    private static final int BASE = 3;\n\n    public static void main(String[] args) {\n        System.out.println((int) Math.pow(new Scanner(System.in).nextInt(), BASE));\n    }\n}\n", "test_IO": {"input": ["2\n"], "output": ["8\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    private static final int BASE = 3;\n\n    public static void main(String[] args) {\n        System.out.println((int) Math.pow(new Scanner(System.in) .nextInt(), BASE));\n    }\n}\n"}
{"id": "Java/43", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        SampleSolution main = new SampleSolution();\n        main.solve();\n    }\n\n    private void solve() {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int[][] c = new int[10][10];\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                c[i][j] = sc.nextInt();\n            }\n        }\n        int[] min = new int[10];\n        for (int i = 0; i < 10; i++) {\n            min[i] = c[i][1];\n        }\n        for (int tc = 0; tc < 10; tc++) {\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    min[i] = Math.min(min[i], c[i][j] + min[j]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int h = 1; h <= H; h++) {\n            for (int w = 1; w <= W; w++) {\n                int A = sc.nextInt();\n                if (A >= 0) {\n                    ans += min[A];\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    class Scanner {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int index;\n        private int length;\n\n        public Scanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return '!' <= c && c <= '~';\n        }\n\n        private boolean isDigit(int c) {\n            return '0' <= c && c <= '9';\n        }\n\n        private boolean hasNextByte() {\n            if (index < length) {\n                return true;\n            } else {\n                try {\n                    length = in.read(buffer);\n                    index = 0;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return length > 0;\n            }\n        }\n\n        private boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[index])) {\n                index++;\n            }\n            return hasNextByte();\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[index++] : -1;\n        }\n\n        public String next() {\n            if (!hasNext()) {\n                throw new RuntimeException(\"no input\");\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) {\n                throw new RuntimeException(\"no input\");\n            }\n            long value = 0L;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (isPrintableChar(b)) {\n                if (isDigit(b)) {\n                    value = value * 10 + (b - '0');\n                }\n                b = readByte();\n            }\n            return minus ? -value : value;\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    interface CombCalculator {\n        long comb(int n, int m);\n    }\n\n    interface MobiusFunction {\n        int get(int n);\n    }\n\n    class SieveMobiusFunction implements MobiusFunction {\n        int size;\n        int[] mobiusFunctionValues;\n\n        public SieveMobiusFunction(int size) {\n            this.size = size;\n            mobiusFunctionValues = new int[size];\n\n            mobiusFunctionValues[0] = 0;\n            mobiusFunctionValues[1] = 1;\n            for (int i = 2; i < size; i++) {\n                mobiusFunctionValues[i] = 1;\n            }\n            for (int i = 2; i * i < size; i++) {\n                for (int k = 1; i * i * k < size; k++) {\n                    mobiusFunctionValues[i * i * k] *= 0;\n                }\n            }\n\n            for (int i = 2; i < size; i++) {\n                if (mobiusFunctionValues[i] == 1) {\n                    for (int k = 1; i * k < size; k++) {\n                        mobiusFunctionValues[i * k] *= -2;\n                    }\n                }\n                if (mobiusFunctionValues[i] > 1) {\n                    mobiusFunctionValues[i] = 1;\n                }\n                if (mobiusFunctionValues[i] < -1) {\n                    mobiusFunctionValues[i] = -1;\n                }\n            }\n        }\n\n        @Override\n        public int get(int n) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0) {\n                return 0;\n            }\n            return mobiusFunctionValues[n];\n        }\n    }\n\n    class PrimeFactorizationMobiusFunction implements MobiusFunction {\n        @Override\n        public int get(int n) {\n            if (n <= 0) {\n                return 0;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            int num = 0;\n            for (int i = 2; i < n; i++) {\n                if (n % i == 0) {\n                    n /= i;\n                    num++;\n                    if (n % i == 0) {\n                        return 0;\n                    }\n                }\n            }\n            return num % 2 == 0 ? -1 : 1;\n        }\n    }\n\n    class FactorialTableCombCalculator implements CombCalculator {\n        int size;\n        long[] factorialTable;\n        long[] inverseFactorialTable;\n        long mod;\n\n        public FactorialTableCombCalculator(int size, long mod) {\n            this.size = size;\n            factorialTable = new long[size + 1];\n            inverseFactorialTable = new long[size + 1];\n            this.mod = mod;\n\n            factorialTable[0] = 1L;\n            for (int i = 1; i <= size; i++) {\n                factorialTable[i] = (factorialTable[i - 1] * i) % mod;\n            }\n            inverseFactorialTable[size] = inverse(factorialTable[size], mod);\n            for (int i = size - 1; i >= 0; i--) {\n                inverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n            }\n        }\n\n        private long inverse(long n, long mod) {\n            return pow(n, mod - 2, mod);\n        }\n\n        private long pow(long n, long p, long mod) {\n            if (p == 0) {\n                return 1L;\n            }\n            long half = pow(n, p / 2, mod);\n            long ret = (half * half) % mod;\n            if (p % 2 == 1) {\n                ret = (ret * n) % mod;\n            }\n            return ret;\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return (((factorialTable[n] * inverseFactorialTable[m]) % mod)\n                            * inverseFactorialTable[n - m])\n                    % mod;\n        }\n    }\n\n    class TableCombCalculator implements CombCalculator {\n        long[][] table;\n        int size;\n\n        public TableCombCalculator(int size, long mod) {\n            this.size = size;\n            table = new long[size + 1][];\n\n            table[0] = new long[1];\n            table[0][0] = 1L;\n            for (int n = 1; n <= size; n++) {\n                table[n] = new long[n + 1];\n                table[n][0] = 1L;\n                for (int m = 1; m < n; m++) {\n                    table[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n                }\n                table[n][n] = 1L;\n            }\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return table[n][m];\n        }\n    }\n\n    interface Graph {\n        void link(int from, int to, long cost);\n\n        Optional<Long> getCost(int from, int to);\n\n        int getVertexNum();\n    }\n\n    interface FlowResolver {\n        long maxFlow(int from, int to);\n    }\n\n    class ArrayGraph implements Graph {\n        private Long[][] costArray;\n        private int vertexNum;\n\n        public ArrayGraph(int n) {\n            costArray = new Long[n][];\n            for (int i = 0; i < n; i++) {\n                costArray[i] = new Long[n];\n            }\n            vertexNum = n;\n        }\n\n        @Override\n        public void link(int from, int to, long cost) {\n            costArray[from][to] = new Long(cost);\n        }\n\n        @Override\n        public Optional<Long> getCost(int from, int to) {\n            return Optional.ofNullable(costArray[from][to]);\n        }\n\n        @Override\n        public int getVertexNum() {\n            return vertexNum;\n        }\n    }\n\n    class DfsFlowResolver implements FlowResolver {\n        private Graph graph;\n\n        public DfsFlowResolver(Graph graph) {\n            this.graph = graph;\n        }\n\n        public long maxFlow(int from, int to) {\n            long sum = 0L;\n            long currentFlow;\n            do {\n                currentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n                sum += currentFlow;\n            } while (currentFlow > 0);\n            return sum;\n        }\n\n        private long flow(int from, int to, long current_flow, boolean[] passed) {\n            passed[from] = true;\n            if (from == to) {\n                return current_flow;\n            }\n            for (int id = 0; id < graph.getVertexNum(); id++) {\n                if (passed[id]) {\n                    continue;\n                }\n                Optional<Long> cost = graph.getCost(from, id);\n                if (cost.orElse(0L) > 0) {\n                    long nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n                    long returnFlow = flow(id, to, nextFlow, passed);\n                    if (returnFlow > 0) {\n                        graph.link(from, id, cost.get() - returnFlow);\n                        graph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n                        return returnFlow;\n                    }\n                }\n            }\n            return 0L;\n        }\n    }\n\n    class BinaryIndexedTree {\n        private long[] array;\n\n        public BinaryIndexedTree(int size) {\n            this.array = new long[size + 1];\n        }\n\n        public void add(int index, long value) {\n            for (int i = index; i < array.length; i += (i & -i)) {\n                array[i] += value;\n            }\n        }\n\n        public long getSum(int index) {\n            long sum = 0L;\n            for (int i = index; i > 0; i -= (i & -i)) {\n                sum += array[i];\n            }\n            return sum;\n        }\n    }\n\n    class BinaryIndexedTree2D {\n        private long[][] array;\n\n        public BinaryIndexedTree2D(int size1, int size2) {\n            this.array = new long[size1 + 1][];\n            for (int i = 1; i <= size1; i++) {\n                this.array[i] = new long[size2 + 1];\n            }\n        }\n\n        public void add(int index1, int index2, long value) {\n            for (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n                for (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n                    array[i1][i2] += value;\n                }\n            }\n        }\n\n        public long getSum(int index1, int index2) {\n            long sum = 0L;\n            for (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n                for (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n                    sum += array[i1][i2];\n                }\n            }\n            return sum;\n        }\n    }\n\n    interface UnionFind {\n        void union(int A, int B);\n\n        boolean judge(int A, int B);\n\n        Set<Integer> getSet(int id);\n    }\n\n    class SetUnionFind extends ArrayUnionFind {\n        Map<Integer, Set<Integer>> map;\n\n        public SetUnionFind(int size) {\n            super(size);\n            map = new HashMap<>();\n            for (int i = 0; i < size; i++) {\n                map.put(i, new HashSet<>());\n                map.get(i).add(i);\n            }\n        }\n\n        @Override\n        protected void unionTo(int source, int dest) {\n            super.unionTo(source, dest);\n            map.get(dest).addAll(map.get(source));\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            return map.get(root(id));\n        }\n    }\n\n    class ArrayUnionFind implements UnionFind {\n        int[] parent;\n        int[] rank;\n        int size;\n\n        public ArrayUnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n            rank = new int[size];\n            this.size = size;\n        }\n\n        @Override\n        public void union(int A, int B) {\n            int rootA = root(A);\n            int rootB = root(B);\n            if (rootA != rootB) {\n                if (rank[rootA] < rank[rootB]) {\n                    unionTo(rootA, rootB);\n                } else {\n                    unionTo(rootB, rootA);\n                    if (rank[rootA] == rank[rootB]) {\n                        rank[rootA]++;\n                    }\n                }\n            }\n        }\n\n        protected void unionTo(int source, int dest) {\n            parent[source] = dest;\n        }\n\n        @Override\n        public boolean judge(int A, int B) {\n            return root(A) == root(B);\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n            return set;\n        }\n\n        protected int root(int id) {\n            if (parent[id] == id) {\n                return id;\n            }\n            parent[id] = root(parent[id]);\n            return parent[id];\n        }\n    }\n\n    class PrimeNumberUtils {\n        boolean[] isPrimeArray;\n        List<Integer> primes;\n\n        public PrimeNumberUtils(int limit) {\n            if (limit > 10000000) {\n                System.err.println(\"The upper limit value is too high, so there is a very high possibility that the prime number utility initialization will result in TLE (Time Limit Exceeded)\");\n            }\n            primes = new ArrayList<>();\n            isPrimeArray = new boolean[limit];\n            if (limit > 2) {\n                primes.add(2);\n                isPrimeArray[2] = true;\n            }\n\n            for (int i = 3; i < limit; i += 2) {\n                if (isPrime(i, primes)) {\n                    primes.add(i);\n                    isPrimeArray[i] = true;\n                }\n            }\n        }\n\n        public List<Integer> getPrimeNumberList() {\n            return primes;\n        }\n\n        public boolean isPrime(int n) {\n            return isPrimeArray[n];\n        }\n\n        private boolean isPrime(int n, List<Integer> primes) {\n            for (int prime : primes) {\n                if (n % prime == 0) {\n                    return false;\n                }\n                if (prime > Math.sqrt(n)) {\n                    break;\n                }\n            }\n            return true;\n        }\n    }\n\n    interface BitSet {\n        void set(int index, boolean bit);\n\n        boolean get(int index);\n\n        void shiftRight(int num);\n\n        void shiftLeft(int num);\n\n        void or(BitSet bitset);\n\n        void and(BitSet bitset);\n    }\n\n    class LongBit implements BitSet {\n        long[] bitArray;\n\n        public LongBit(int size) {\n            bitArray = new long[((size + 63) / 64)];\n        }\n\n        @Override\n        public void set(int index, boolean bit) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            if (bit) {\n                bitArray[segment] |= 1L << inIndex;\n            } else {\n                bitArray[segment] &= ~(1L << inIndex);\n            }\n        }\n\n        @Override\n        public boolean get(int index) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            return (bitArray[segment] & (1L << inIndex)) != 0L;\n        }\n\n        @Override\n        public void shiftRight(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                int sourceSeg = segment + shiftSeg;\n                if (sourceSeg < bitArray.length) {\n                    bitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n                    if (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n                        bitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        @Override\n        public void shiftLeft(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = bitArray.length - 1; segment >= 0; segment--) {\n                int sourceSeg = segment - shiftSeg;\n                if (sourceSeg >= 0) {\n                    bitArray[segment] = bitArray[sourceSeg] << shiftInI;\n                    if (shiftInI > 0 && sourceSeg > 0) {\n                        bitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        public long getLong(int segment) {\n            return bitArray[segment];\n        }\n\n        @Override\n        public void or(BitSet bitset) {\n            if (!(bitset instanceof LongBit)) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] |= ((LongBit) bitset).getLong(segment);\n            }\n        }\n\n        @Override\n        public void and(BitSet bitset) {\n            if (!(bitset instanceof LongBit)) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] &= ((LongBit) bitset).getLong(segment);\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["2 4\n0 9 9 9 9 9 9 9 9 9\n9 0 9 9 9 9 9 9 9 9\n9 9 0 9 9 9 9 9 9 9\n9 9 9 0 9 9 9 9 9 9\n9 9 9 9 0 9 9 9 9 2\n9 9 9 9 9 0 9 9 9 9\n9 9 9 9 9 9 0 9 9 9\n9 9 9 9 9 9 9 0 9 9\n9 9 9 9 2 9 9 9 0 9\n9 2 9 9 9 9 9 9 9 0\n-1 -1 -1 -1\n8 1 1 8\n"], "output": ["12\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        SampleSolution main = new SampleSolution();\n        main.solve();\n    }\n\n    private void solve() {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int[][] c = new int[10][10];\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                c[i][j] = sc.nextInt();\n            }\n        }\n        int[] min = new int[10];\n        for (int i = 0; i < 10; i++) {\n            min[i] = c[i][1];\n        }\n        for (int tc = 0; tc < 10; tc++) {\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    min[i] = Math.min(min[i], c[i][j] + min[j]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int h = 1; h <= H; h++) {\n            for (int w = 1; w <= W; w++) {\n                int A = sc.nextInt();\n                if (A >= 0) {\n                    ans += min[A];\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    class Scanner {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int index;\n        private int length;\n\n        public Scanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return '!' <= c && c <= '~';\n        }\n\n        private boolean isDigit(int c) {\n            return '0' <= c && c <= '9';\n        }\n\n        private boolean hasNextByte() {\n            if (index < length) {\n                return true;\n            } else {\n                try {\n                    length = in.read(buffer);\n                    index = 0;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return length > 0;\n            }\n        }\n\n        private boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[index])) {\n                index++;\n            }\n            return hasNextByte();\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[index++] : -1;\n        }\n\n        public String next() {\n            if (!hasNext()) {\n                throw new RuntimeException(\"no input\");\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) {\n                throw new RuntimeException(\"no input\");\n            }\n            long value = 0L;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (isPrintableChar(b)) {\n                if (isDigit(b)) {\n                    value = value * 10 + (b - '0');\n                }\n                b = readByte();\n            }\n            return minus ? -value : value;\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    interface CombCalculator {\n        long comb(int n, int m);\n    }\n\n    interface MobiusFunction {\n        int get(int n);\n    }\n\n    class SieveMobiusFunction implements MobiusFunction {\n        int size;\n        int[] mobiusFunctionValues;\n\n        public SieveMobiusFunction(int size) {\n            this.size = size;\n            mobiusFunctionValues = new int[size];\n\n            mobiusFunctionValues[0] = 0;\n            mobiusFunctionValues[1] = 1;\n            for (int i = 2; i < size; i++) {\n                mobiusFunctionValues[i] = 1;\n            }\n            for (int i = 2; i * i < size; i++) {\n                for (int k = 1; i * i * k < size; k++) {\n                    mobiusFunctionValues[i * i * k] *= 0;\n                }\n            }\n\n            for (int i = 2; i < size; i++) {\n                if (mobiusFunctionValues[i] == 1) {\n                    for (int k = 1; i * k < size; k++) {\n                        mobiusFunctionValues[i * k] *= -2;\n                    }\n                }\n                if (mobiusFunctionValues[i] > 1) {\n                    mobiusFunctionValues[i] = 1;\n                }\n                if (mobiusFunctionValues[i] < -1) {\n                    mobiusFunctionValues[i] = -1;\n                }\n            }\n        }\n\n        @Override\n        public int get(int n) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0) {\n                return 0;\n            }\n            return mobiusFunctionValues[n];\n        }\n    }\n\n    class PrimeFactorizationMobiusFunction implements MobiusFunction {\n        @Override\n        public int get(int n) {\n            if (n <= 0) {\n                return 0;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            int num = 0;\n            for (int i = 2; i < n; i++) {\n                if (n % i == 0) {\n                    n /= i;\n                    num++;\n                    if (n % i == 0) {\n                        return 0;\n                    }\n                }\n            }\n            return num % 2 == 0 ? -1 : 1;\n        }\n    }\n\n    class FactorialTableCombCalculator implements CombCalculator {\n        int size;\n        long[] factorialTable;\n        long[] inverseFactorialTable;\n        long mod;\n\n        public FactorialTableCombCalculator(int size, long mod) {\n            this.size = size;\n            factorialTable = new long[size + 1];\n            inverseFactorialTable = new long[size + 1];\n            this.mod = mod;\n\n            factorialTable[0] = 1L;\n            for (int i = 1; i <= size; i++) {\n                factorialTable[i] = (factorialTable[i - 1] * i) % mod;\n            }\n            inverseFactorialTable[size] = inverse(factorialTable[size], mod);\n            for (int i = size - 1; i >= 0; i--) {\n                inverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n            }\n        }\n\n        private long inverse(long n, long mod) {\n            return pow(n, mod - 2, mod);\n        }\n\n        private long pow(long n, long p, long mod) {\n            if (p == 0) {\n                return 1L;\n            }\n            long half = pow(n, p / 2, mod);\n            long ret = (half * half) % mod;\n            if (p % 2 == 1) {\n                ret = (ret * n) % mod;\n            }\n            return ret;\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return (((factorialTable[n] * inverseFactorialTable[m]) % mod)\n                            * inverseFactorialTable[n - m])\n                    % mod;\n        }\n    }\n\n    class TableCombCalculator implements CombCalculator {\n        long[][] table;\n        int size;\n\n        public TableCombCalculator(int size, long mod) {\n            this.size = size;\n            table = new long[size + 1][];\n\n            table[0] = new long[1];\n            table[0][0] = 1L;\n            for (int n = 1; n <= size; n++) {\n                table[n] = new long[n + 1];\n                table[n][0] = 1L;\n                for (int m = 1; m < n; m++) {\n                    table[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n                }\n                table[n][n] = 1L;\n            }\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return table[n][m];\n        }\n    }\n\n    interface Graph {\n        void link(int from, int to, long cost);\n\n        Optional<Long> getCost(int from, int to);\n\n        int getVertexNum();\n    }\n\n    interface FlowResolver {\n        long maxFlow(int from, int to);\n    }\n\n    class ArrayGraph implements Graph {\n        private Long[][] costArray;\n        private int vertexNum;\n\n        public ArrayGraph(int n) {\n            costArray = new Long[n][];\n            for (int i = 0; i < n; i++) {\n                costArray[i] = new Long[n];\n            }\n            vertexNum = n;\n        }\n\n        @Override\n        public void link(int from, int to, long cost) {\n            costArray[from][to] = new Long(cost);\n        }\n\n        @Override\n        public Optional<Long> getCost(int from, int to) {\n            return Optional.ofNullable(costArray[from][to]);\n        }\n\n        @Override\n        public int getVertexNum() {\n            return vertexNum;\n        }\n    }\n\n    class DfsFlowResolver implements FlowResolver {\n        private Graph graph;\n\n        public DfsFlowResolver(Graph graph) {\n            this.graph = graph;\n        }\n\n        public long maxFlow(int from, int to) {\n            long sum = 0L;\n            long currentFlow;\n            do {\n                currentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n                sum += currentFlow;\n            } while (currentFlow > 0);\n            return sum;\n        }\n\n        private long flow(int from, int to, long current_flow, boolean[] passed) {\n            passed[from] = true;\n            if (from == to) {\n                return current_flow;\n            }\n            for (int id = 0; id < graph.getVertexNum(); id++) {\n                if (passed[id]) {\n                    continue;\n                }\n                Optional<Long> cost = graph.getCost(from, id);\n                if (cost.orElse(0L) > 0) {\n                    long nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n                    long returnFlow = flow(id, to, nextFlow, passed);\n                    if (returnFlow > 0) {\n                        graph.link(from, id, cost.get() - returnFlow);\n                        graph.link(id, from, graph.getCost(id, from) .orElse(0L) + returnFlow);\n                        return returnFlow;\n                    }\n                }\n            }\n            return 0L;\n        }\n    }\n\n    class BinaryIndexedTree {\n        private long[] array;\n\n        public BinaryIndexedTree(int size) {\n            this.array = new long[size + 1];\n        }\n\n        public void add(int index, long value) {\n            for (int i = index; i < array.length; i += (i & -i)) {\n                array[i] += value;\n            }\n        }\n\n        public long getSum(int index) {\n            long sum = 0L;\n            for (int i = index; i > 0; i -= (i & -i)) {\n                sum += array[i];\n            }\n            return sum;\n        }\n    }\n\n    class BinaryIndexedTree2D {\n        private long[][] array;\n\n        public BinaryIndexedTree2D(int size1, int size2) {\n            this.array = new long[size1 + 1][];\n            for (int i = 1; i <= size1; i++) {\n                this.array[i] = new long[size2 + 1];\n            }\n        }\n\n        public void add(int index1, int index2, long value) {\n            for (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n                for (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n                    array[i1][i2] += value;\n                }\n            }\n        }\n\n        public long getSum(int index1, int index2) {\n            long sum = 0L;\n            for (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n                for (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n                    sum += array[i1][i2];\n                }\n            }\n            return sum;\n        }\n    }\n\n    interface UnionFind {\n        void union(int A, int B);\n\n        boolean judge(int A, int B);\n\n        Set<Integer> getSet(int id);\n    }\n\n    class SetUnionFind extends ArrayUnionFind {\n        Map<Integer, Set<Integer>> map;\n\n        public SetUnionFind(int size) {\n            super(size);\n            map = new HashMap<>();\n            for (int i = 0; i < size; i++) {\n                map.put(i, new HashSet<>());\n                map.get(i) .add(i);\n            }\n        }\n\n        @Override\n        protected void unionTo(int source, int dest) {\n            super.unionTo(source, dest);\n            map.get(dest) .addAll(map.get(source));\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            return map.get(root(id));\n        }\n    }\n\n    class ArrayUnionFind implements UnionFind {\n        int[] parent;\n        int[] rank;\n        int size;\n\n        public ArrayUnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n            rank = new int[size];\n            this.size = size;\n        }\n\n        @Override\n        public void union(int A, int B) {\n            int rootA = root(A);\n            int rootB = root(B);\n            if (rootA != rootB) {\n                if (rank[rootA] < rank[rootB]) {\n                    unionTo(rootA, rootB);\n                } else {\n                    unionTo(rootB, rootA);\n                    if (rank[rootA] == rank[rootB]) {\n                        rank[rootA]++;\n                    }\n                }\n            }\n        }\n\n        protected void unionTo(int source, int dest) {\n            parent[source] = dest;\n        }\n\n        @Override\n        public boolean judge(int A, int B) {\n            return root(A) == root(B);\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, size) .filter(i -> judge(i, id)) .forEach(set::add);\n            return set;\n        }\n\n        protected int root(int id) {\n            if (parent[id] == id) {\n                return id;\n            }\n            parent[id] = root(parent[id]);\n            return parent[id];\n        }\n    }\n\n    class PrimeNumberUtils {\n        boolean[] isPrimeArray;\n        List<Integer> primes;\n\n        public PrimeNumberUtils(int limit) {\n            if (limit > 10000000) {\n                System.err.println(\"The upper limit value is too high, so there is a very high possibility that the prime number utility initialization will result in TLE (Time Limit Exceeded)\");\n            }\n            primes = new ArrayList<>();\n            isPrimeArray = new boolean[limit];\n            if (limit > 2) {\n                primes.add(2);\n                isPrimeArray[2] = true;\n            }\n\n            for (int i = 3; i < limit; i += 2) {\n                if (isPrime(i, primes)) {\n                    primes.add(i);\n                    isPrimeArray[i] = true;\n                }\n            }\n        }\n\n        public List<Integer> getPrimeNumberList() {\n            return primes;\n        }\n\n        public boolean isPrime(int n) {\n            return isPrimeArray[n];\n        }\n\n        private boolean isPrime(int n, List<Integer> primes) {\n            for (int prime : primes) {\n                if (n % prime == 0) {\n                    return false;\n                }\n                if (prime > Math.sqrt(n)) {\n                    break;\n                }\n            }\n            return true;\n        }\n    }\n\n    interface BitSet {\n        void set(int index, boolean bit);\n\n        boolean get(int index);\n\n        void shiftRight(int num);\n\n        void shiftLeft(int num);\n\n        void or(BitSet bitset);\n\n        void and(BitSet bitset);\n    }\n\n    class LongBit implements BitSet {\n        long[] bitArray;\n\n        public LongBit(int size) {\n            bitArray = new long[((size + 63) / 64)];\n        }\n\n        @Override\n        public void set(int index, boolean bit) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            if (bit) {\n                bitArray[segment] |= 1L << inIndex;\n            } else {\n                bitArray[segment] &= ~(1L << inIndex);\n            }\n        }\n\n        @Override\n        public boolean get(int index) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            return (bitArray[segment] & (1L << inIndex)) != 0L;\n        }\n\n        @Override\n        public void shiftRight(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                int sourceSeg = segment + shiftSeg;\n                if (sourceSeg < bitArray.length) {\n                    bitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n                    if (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n                        bitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        @Override\n        public void shiftLeft(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = bitArray.length - 1; segment >= 0; segment--) {\n                int sourceSeg = segment - shiftSeg;\n                if (sourceSeg >= 0) {\n                    bitArray[segment] = bitArray[sourceSeg] << shiftInI;\n                    if (shiftInI > 0 && sourceSeg > 0) {\n                        bitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        public long getLong(int segment) {\n            return bitArray[segment];\n        }\n\n        @Override\n        public void or(BitSet bitset) {\n            if (!(bitset instanceof LongBit)) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] |= ((LongBit) bitset) .getLong(segment);\n            }\n        }\n\n        @Override\n        public void and(BitSet bitset) {\n            if (!(bitset instanceof LongBit)) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] &= ((LongBit) bitset) .getLong(segment);\n            }\n        }\n    }\n}\n"}
{"id": "Java/48", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        IntegralRect rects[] = new IntegralRect[40000];\n        for (int i = 0; i < 200; i++) {\n            for (int j = 0; j < 200; j++) {\n                rects[i * 200 + j] = new IntegralRect(i + 1, j + 1);\n            }\n        }\n        Arrays.sort(rects);\n\n        while (true) {\n            String[] tmpArray = br.readLine().split(\" \");\n\n            int h = Integer.parseInt(tmpArray[0]);\n            int w = Integer.parseInt(tmpArray[1]);\n\n            if (h == 0 && w == 0) {\n                break;\n            }\n\n            IntegralRect tmpRect = new IntegralRect(h, w);\n            int diag = tmpRect.diagonal();\n\n            for (int i = 0; i < rects.length; i++) {\n\n                if (rects[i].compareTo(tmpRect) > 0) {\n                    System.out.println(rects[i].height + \" \" + rects[i].width);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nclass IntegralRect implements Comparable<IntegralRect> {\n    int height;\n    int width;\n\n    public IntegralRect(int h, int w) {\n        this.height = h;\n        this.width = w;\n    }\n\n    public int diagonal() {\n        if (height >= width) {\n            return Integer.MAX_VALUE;\n        }\n        return this.height * this.height + this.width * this.width;\n    }\n\n    @Override\n    public int compareTo(IntegralRect o) {\n\n        int d1 = this.diagonal();\n        int d2 = o.diagonal();\n\n        return d1 == d2 ? this.height - o.height : d1 - d2;\n    }\n}\n", "test_IO": {"input": ["1 2\n1 3\n2 3\n1 4\n2 4\n5 6\n1 8\n4 7\n98 100\n99 100\n0 0\n"], "output": ["1 3\n2 3\n1 4\n2 4\n3 4\n1 8\n4 7\n2 8\n3 140\n89 109\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        IntegralRect rects[] = new IntegralRect[40000];\n        for (int i = 0; i < 200; i++) {\n            for (int j = 0; j < 200; j++) {\n                rects[i * 200 + j] = new IntegralRect(i + 1, j + 1);\n            }\n        }\n        Arrays.sort(rects);\n\n        while (true) {\n            String[] tmpArray = br.readLine() .split(\" \");\n\n            int h = Integer.parseInt(tmpArray[0]);\n            int w = Integer.parseInt(tmpArray[1]);\n\n            if (h == 0 && w == 0) {\n                break;\n            }\n\n            IntegralRect tmpRect = new IntegralRect(h, w);\n            int diag = tmpRect.diagonal();\n\n            for (int i = 0; i < rects.length; i++) {\n\n                if (rects[i].compareTo(tmpRect) > 0) {\n                    System.out.println(rects[i].height + \" \" + rects[i].width);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nclass IntegralRect implements Comparable<IntegralRect> {\n    int height;\n    int width;\n\n    public IntegralRect(int h, int w) {\n        this.height = h;\n        this.width = w;\n    }\n\n    public int diagonal() {\n        if (height >= width) {\n            return Integer.MAX_VALUE;\n        }\n        return this.height * this.height + this.width * this.width;\n    }\n\n    @Override\n    public int compareTo(IntegralRect o) {\n\n        int d1 = this.diagonal();\n        int d2 = o.diagonal();\n\n        return d1 == d2 ? this.height - o.height : d1 - d2;\n    }\n}\n"}
{"id": "Java/49", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\nclass SampleSolution {\n\n    static class Solver {\n        final FastScanner sc;\n        final PrintWriter writer;\n\n        Solver(final FastScanner sc, final PrintWriter writer) {\n            this.sc = sc;\n            this.writer = writer;\n        }\n\n        int n, m, q;\n        int max = 0;\n        int[] a, b, c, d;\n\n        void run() {\n            n = sc.nextInt();\n            m = sc.nextInt();\n            q = sc.nextInt();\n            a = new int[q];\n            b = new int[q];\n            c = new int[q];\n            d = new int[q];\n            for (int i = 0; i < q; i++) {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n                d[i] = sc.nextInt();\n            }\n            dfs(new int[] {1});\n            writer.println(max);\n        }\n\n        private void dfs(int[] array) {\n            if (array.length > n) {\n                int score = 0;\n                for (int i = 0; i < q; i++) {\n                    if (array[b[i]] - array[a[i]] == c[i]) {\n                        score += d[i];\n                    }\n                }\n                max = Math.max(max, score);\n                return;\n            }\n\n            int[] newArray = new int[array.length + 1];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            System.arraycopy(new int[] {array[array.length - 1]}, 0, newArray, array.length, 1);\n\n            while (newArray[newArray.length - 1] <= m) {\n                dfs(newArray);\n                newArray[newArray.length - 1] += 1;\n            }\n        }\n    }\n\n    public static void main(final String[] args) {\n        final FastScanner sc = new FastScanner();\n        try (final PrintWriter w = new PrintWriter(System.out)) {\n            new Solver(sc, w).run();\n            w.flush();\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner() {}\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (final IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(final int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            final StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            final long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(final int n) {\n            final long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n}\n", "test_IO": {"input": ["3 4 3\n1 3 3 100\n1 2 2 10\n2 3 2 10\n"], "output": ["110\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\nclass SampleSolution {\n\n    static class Solver {\n        final FastScanner sc;\n        final PrintWriter writer;\n\n        Solver(final FastScanner sc, final PrintWriter writer) {\n            this.sc = sc;\n            this.writer = writer;\n        }\n\n        int n, m, q;\n        int max = 0;\n        int[] a, b, c, d;\n\n        void run() {\n            n = sc.nextInt();\n            m = sc.nextInt();\n            q = sc.nextInt();\n            a = new int[q];\n            b = new int[q];\n            c = new int[q];\n            d = new int[q];\n            for (int i = 0; i < q; i++) {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n                d[i] = sc.nextInt();\n            }\n            dfs(new int[] {1});\n            writer.println(max);\n        }\n\n        private void dfs(int[] array) {\n            if (array.length > n) {\n                int score = 0;\n                for (int i = 0; i < q; i++) {\n                    if (array[b[i]] - array[a[i]] == c[i]) {\n                        score += d[i];\n                    }\n                }\n                max = Math.max(max, score);\n                return;\n            }\n\n            int[] newArray = new int[array.length + 1];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            System.arraycopy(new int[] {array[array.length - 1]}, 0, newArray, array.length, 1);\n\n            while (newArray[newArray.length - 1] <= m) {\n                dfs(newArray);\n                newArray[newArray.length - 1] += 1;\n            }\n        }\n    }\n\n    public static void main(final String[] args) {\n        final FastScanner sc = new FastScanner();\n        try (final PrintWriter w = new PrintWriter(System.out)) {\n            new Solver(sc, w) .run();\n            w.flush();\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner() {}\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (final IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(final int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            final StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            final long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(final int n) {\n            final long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n}\n"}
{"id": "Java/54", "code": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n\n        out.close();\n    }\n\n    static class Solver {\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int ans = 0;\n            int K = in.nextInt();\n            int S = in.nextInt();\n            int wk = 0;\n            for (int x = 0; x <= K; x++) {\n                for (int y = 0; y <= K; y++) {\n                    wk = S - x - y;\n                    if (wk >= 0 && wk <= K) {\n                        ans++;\n                    }\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar()).trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n", "test_IO": {"input": ["2 2\n"], "output": ["6\n"]}, "modified_context": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n\n        out.close();\n    }\n\n    static class Solver {\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int ans = 0;\n            int K = in.nextInt();\n            int S = in.nextInt();\n            int wk = 0;\n            for (int x = 0; x <= K; x++) {\n                for (int y = 0; y <= K; y++) {\n                    wk = S - x - y;\n                    if (wk >= 0 && wk <= K) {\n                        ans++;\n                    }\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar()) .trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n"}
{"id": "Java/62", "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    static class Task {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] countArr = new int[n + 1];\n            for (int x = 1; x <= 100; x++) {\n                for (int y = 1; y <= 100; y++) {\n                    for (int z = 1; z <= 100; z++) {\n                        int value = x * x + y * y + z * z + x * y + x * z + y * z;\n                        if (value > n) {\n                            break;\n                        }\n                        countArr[value]++;\n                    }\n                }\n            }\n\n            for (int i = 1; i <= n; i++) {\n                out.println(countArr[i]);\n            }\n        }\n    }\n\n    private static void sort(double[] arr) {\n        Double[] objArr = Arrays.stream(arr).boxed().toArray(Double[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(int[] arr) {\n        Integer[] objArr = Arrays.stream(arr).boxed().toArray(Integer[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(long[] arr) {\n        Long[] objArr = Arrays.stream(arr).boxed().toArray(Long[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task task = new Task();\n        task.solve(1, in, out);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, () -> solve(), \"1\", 1 << 26).start();\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "test_IO": {"input": ["20\n"], "output": ["0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n3\n0\n0\n0\n0\n0\n3\n3\n0\n0\n"]}, "modified_context": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    static class Task {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] countArr = new int[n + 1];\n            for (int x = 1; x <= 100; x++) {\n                for (int y = 1; y <= 100; y++) {\n                    for (int z = 1; z <= 100; z++) {\n                        int value = x * x + y * y + z * z + x * y + x * z + y * z;\n                        if (value > n) {\n                            break;\n                        }\n                        countArr[value]++;\n                    }\n                }\n            }\n\n            for (int i = 1; i <= n; i++) {\n                out.println(countArr[i]);\n            }\n        }\n    }\n\n    private static void sort(double[] arr) {\n        Double[] objArr = Arrays.stream(arr) .boxed() .toArray(Double[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(int[] arr) {\n        Integer[] objArr = Arrays.stream(arr) .boxed() .toArray(Integer[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(long[] arr) {\n        Long[] objArr = Arrays.stream(arr) .boxed() .toArray(Long[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task task = new Task();\n        task.solve(1, in, out);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, () -> solve(), \"1\", 1 << 26) .start();\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n"}
{"id": "Java/64", "code": "import java.util.*;\n\npublic class SampleSolution {\n    static int mapNum;\n    static int h;\n    static int w;\n    static char[][] battleTown;\n    static int bomberActNum;\n    static char[] bomberAct;\n\n    static int[] tank = new int[2];\n    static int xOfTank;\n    static int yOfTank;\n    static int xOfBomber;\n    static int yOfBomber;\n    static int s;\n    static int k;\n    static int a;\n    static int b;\n    static int x;\n    static int y;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        mapNum = sc.nextInt();\n\n        for (int i = 0; i < mapNum; i++) {\n            if (1 <= i && i < mapNum) {\n                System.out.println(\"\");\n            }\n            h = sc.nextInt();\n            w = sc.nextInt();\n\n            battleTown = new char[h][w];\n\n            for (int j = 0; j < h; j++) {\n                char[] c = sc.next().toCharArray();\n                for (int k = 0; k < w; k++) {\n                    battleTown[j][k] = c[k];\n\n                    if ('^' == battleTown[j][k]\n                            || 'v' == battleTown[j][k]\n                            || '<' == battleTown[j][k]\n                            || '>' == battleTown[j][k]) {\n\n                        x = j;\n                        y = k;\n                    }\n                }\n            }\n\n            bomberActNum = sc.nextInt();\n            bomberAct = sc.next().toCharArray();\n\n            if (0 <= x && x <= h && 0 <= y && y <= w) {\n                for (int l = 0; l < bomberActNum; l++) {\n\n                    if (bomberAct[l] == 'U') {\n\n                        battleTown[x][y] = '^';\n                        if (x - 1 >= 0 && battleTown[x - 1][y] == '.') {\n\n                            battleTown[x - 1][y] = '^';\n                            battleTown[x][y] = '.';\n                            x--;\n                        }\n                    }\n                    if (bomberAct[l] == 'D') {\n\n                        battleTown[x][y] = 'v';\n                        if (x + 1 < h && battleTown[x + 1][y] == '.') {\n\n                            battleTown[x + 1][y] = 'v';\n                            battleTown[x][y] = '.';\n                            x++;\n                        }\n                    }\n                    if (bomberAct[l] == 'L') {\n\n                        battleTown[x][y] = '<';\n                        if (y - 1 >= 0 && battleTown[x][y - 1] == '.') {\n\n                            battleTown[x][y - 1] = '<';\n                            battleTown[x][y] = '.';\n                            y--;\n                        }\n                    }\n                    if (bomberAct[l] == 'R') {\n\n                        battleTown[x][y] = '>';\n                        if (y + 1 < w && battleTown[x][y + 1] == '.') {\n\n                            battleTown[x][y + 1] = '>';\n                            battleTown[x][y] = '.';\n                            y++;\n                        }\n                    }\n\n                    if (bomberAct[l] == 'S') {\n\n                        xOfBomber = x;\n                        yOfBomber = y;\n                        moveBomber(xOfBomber, yOfBomber);\n                    }\n                }\n                for (s = 0; s < h; s++) {\n                    for (k = 0; k < w; k++) {\n                        System.out.print(battleTown[s][k]);\n                    }\n                    System.out.println();\n                }\n            }\n        }\n    }\n\n    public static void moveBomber(int a, int b) {\n\n        if (0 <= a && a <= h && 0 <= b && b <= w) {\n\n            if ('^' == battleTown[a][b]) {\n\n                for (int i = a - 1; i >= 0; i--) {\n                    if (a <= 0) {\n                        return;\n                    } else if (battleTown[a - 1][b] == '*') {\n\n                        battleTown[a - 1][b] = '.';\n\n                        return;\n                    } else if (battleTown[a - 1][b] == '#') {\n\n                        return;\n                    } else {\n\n                        a--;\n\n                        if (a == 0) {\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if ('v' == battleTown[a][b]) {\n                for (int i = a + 1; i < h; i++) {\n\n                    if (battleTown[a + 1][b] == '*') {\n                        battleTown[a + 1][b] = '.';\n\n                        return;\n                    } else if (battleTown[a + 1][b] == '#') {\n\n                        return;\n                    } else {\n                        a++;\n                        if (a == h) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if ('<' == battleTown[a][b]) {\n                for (int i = b - 1; i >= 0; i--) {\n\n                    if (battleTown[a][b - 1] == '*') {\n                        battleTown[a][b - 1] = '.';\n\n                        return;\n                    } else if (battleTown[a][b - 1] == '#') {\n\n                        return;\n                    } else {\n                        b--;\n                        if (b == 0) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if ('>' == battleTown[a][b]) {\n                for (int i = b + 1; i < w; i++) {\n\n                    if (battleTown[a][b + 1] == '*') {\n                        battleTown[a][b + 1] = '.';\n\n                        return;\n                    } else if (battleTown[a][b + 1] == '#') {\n\n                        return;\n                    } else {\n                        b++;\n                        if (b == w) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["4\n4 6\n*.*..*\n*.....\n..-...\n^.*#..\n10\nSRSSRRUSSR\n2 2\n<.\n..\n12\nDDSRRSUUSLLS\n3 5\n>-#**\n.-*#*\n.-**#\n15\nSSSDRSSSDRSSSUU\n5 5\nv****\n*****\n*****\n*****\n*****\n44\nSSSSDDRSDRSRDSULUURSSSSRRRRDSSSSDDLSDLSDLSSD\n"], "output": ["*....*\n......\n..-...\n..>#..\n\n<.\n..\n\n^-#**\n.-.#*\n.-..#\n\n.....\n.***.\n..*..\n..*..\n....v\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    static int mapNum;\n    static int h;\n    static int w;\n    static char[][] battleTown;\n    static int bomberActNum;\n    static char[] bomberAct;\n\n    static int[] tank = new int[2];\n    static int xOfTank;\n    static int yOfTank;\n    static int xOfBomber;\n    static int yOfBomber;\n    static int s;\n    static int k;\n    static int a;\n    static int b;\n    static int x;\n    static int y;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        mapNum = sc.nextInt();\n\n        for (int i = 0; i < mapNum; i++) {\n            if (1 <= i && i < mapNum) {\n                System.out.println(\"\");\n            }\n            h = sc.nextInt();\n            w = sc.nextInt();\n\n            battleTown = new char[h][w];\n\n            for (int j = 0; j < h; j++) {\n                char[] c = sc.next() .toCharArray();\n                for (int k = 0; k < w; k++) {\n                    battleTown[j][k] = c[k];\n\n                    if ('^' == battleTown[j][k]\n                            || 'v' == battleTown[j][k]\n                            || '<' == battleTown[j][k]\n                            || '>' == battleTown[j][k]) {\n\n                        x = j;\n                        y = k;\n                    }\n                }\n            }\n\n            bomberActNum = sc.nextInt();\n            bomberAct = sc.next() .toCharArray();\n\n            if (0 <= x && x <= h && 0 <= y && y <= w) {\n                for (int l = 0; l < bomberActNum; l++) {\n\n                    if (bomberAct[l] == 'U') {\n\n                        battleTown[x][y] = '^';\n                        if (x - 1 >= 0 && battleTown[x - 1][y] == '.') {\n\n                            battleTown[x - 1][y] = '^';\n                            battleTown[x][y] = '.';\n                            x--;\n                        }\n                    }\n                    if (bomberAct[l] == 'D') {\n\n                        battleTown[x][y] = 'v';\n                        if (x + 1 < h && battleTown[x + 1][y] == '.') {\n\n                            battleTown[x + 1][y] = 'v';\n                            battleTown[x][y] = '.';\n                            x++;\n                        }\n                    }\n                    if (bomberAct[l] == 'L') {\n\n                        battleTown[x][y] = '<';\n                        if (y - 1 >= 0 && battleTown[x][y - 1] == '.') {\n\n                            battleTown[x][y - 1] = '<';\n                            battleTown[x][y] = '.';\n                            y--;\n                        }\n                    }\n                    if (bomberAct[l] == 'R') {\n\n                        battleTown[x][y] = '>';\n                        if (y + 1 < w && battleTown[x][y + 1] == '.') {\n\n                            battleTown[x][y + 1] = '>';\n                            battleTown[x][y] = '.';\n                            y++;\n                        }\n                    }\n\n                    if (bomberAct[l] == 'S') {\n\n                        xOfBomber = x;\n                        yOfBomber = y;\n                        moveBomber(xOfBomber, yOfBomber);\n                    }\n                }\n                for (s = 0; s < h; s++) {\n                    for (k = 0; k < w; k++) {\n                        System.out.print(battleTown[s][k]);\n                    }\n                    System.out.println();\n                }\n            }\n        }\n    }\n\n    public static void moveBomber(int a, int b) {\n\n        if (0 <= a && a <= h && 0 <= b && b <= w) {\n\n            if ('^' == battleTown[a][b]) {\n\n                for (int i = a - 1; i >= 0; i--) {\n                    if (a <= 0) {\n                        return;\n                    } else if (battleTown[a - 1][b] == '*') {\n\n                        battleTown[a - 1][b] = '.';\n\n                        return;\n                    } else if (battleTown[a - 1][b] == '#') {\n\n                        return;\n                    } else {\n\n                        a--;\n\n                        if (a == 0) {\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if ('v' == battleTown[a][b]) {\n                for (int i = a + 1; i < h; i++) {\n\n                    if (battleTown[a + 1][b] == '*') {\n                        battleTown[a + 1][b] = '.';\n\n                        return;\n                    } else if (battleTown[a + 1][b] == '#') {\n\n                        return;\n                    } else {\n                        a++;\n                        if (a == h) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if ('<' == battleTown[a][b]) {\n                for (int i = b - 1; i >= 0; i--) {\n\n                    if (battleTown[a][b - 1] == '*') {\n                        battleTown[a][b - 1] = '.';\n\n                        return;\n                    } else if (battleTown[a][b - 1] == '#') {\n\n                        return;\n                    } else {\n                        b--;\n                        if (b == 0) {\n                            return;\n                        }\n                    }\n                }\n            }\n            if ('>' == battleTown[a][b]) {\n                for (int i = b + 1; i < w; i++) {\n\n                    if (battleTown[a][b + 1] == '*') {\n                        battleTown[a][b + 1] = '.';\n\n                        return;\n                    } else if (battleTown[a][b + 1] == '#') {\n\n                        return;\n                    } else {\n                        b++;\n                        if (b == w) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": "Java/71", "code": "import java.io.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unused\")\npublic class SampleSolution {\n    FastScanner in;\n    PrintWriter out;\n    static final int MOD = (int) 1e9 + 7;\n\n    void solve() {\n        int N = in.nextInt();\n        int[] A = in.nextIntArray(N);\n\n        long ans = 0, sum = A[N - 1];\n        for (int i = N - 2; i >= 0; i--) {\n            ans += (sum * A[i]) % MOD;\n            ans %= MOD;\n            sum += A[i];\n            sum %= MOD;\n        }\n        out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().m();\n    }\n\n    private void m() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    static class FastScanner {\n        private Reader input;\n\n        public FastScanner() {\n            this(System.in);\n        }\n\n        public FastScanner(InputStream stream) {\n            this.input = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public void close() {\n            try {\n                this.input.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long nextLong() {\n            try {\n                int sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                long ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) return ret * sign;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                return -1;\n            }\n        }\n\n        public double nextDouble() {\n            try {\n                double sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                double ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) break;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n                if (b != '.') return sign * ret;\n                double div = 1;\n                b = input.read();\n                while ('0' <= b && b <= '9') {\n                    ret *= 10;\n                    ret += b - '0';\n                    div *= 10;\n                    b = input.read();\n                }\n                return sign * ret / div;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return Double.NaN;\n            }\n        }\n\n        public char nextChar() {\n            try {\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                return (char) b;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return 0;\n            }\n        }\n\n        public String nextStr() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                while (b != -1 && !Character.isWhitespace(b)) {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public String nextLine() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (b != -1 && b != '\\n') {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public int[] nextIntArrayDec(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt() - 1;\n            }\n            return res;\n        }\n\n        public int[] nextIntArray1Index(int n) {\n            int[] res = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextInt();\n            }\n            return res;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongArrayDec(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong() - 1;\n            }\n            return res;\n        }\n\n        public long[] nextLongArray1Index(int n) {\n            long[] res = new long[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextLong();\n            }\n            return res;\n        }\n\n        public double[] nextDoubleArray(int n) {\n            double[] res = new double[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n    }\n}\n", "test_IO": {"input": ["3\n1 2 3\n"], "output": ["11\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unused\")\npublic class SampleSolution {\n    FastScanner in;\n    PrintWriter out;\n    static final int MOD = (int) 1e9 + 7;\n\n    void solve() {\n        int N = in.nextInt();\n        int[] A = in.nextIntArray(N);\n\n        long ans = 0, sum = A[N - 1];\n        for (int i = N - 2; i >= 0; i--) {\n            ans += (sum * A[i]) % MOD;\n            ans %= MOD;\n            sum += A[i];\n            sum %= MOD;\n        }\n        out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution() .m();\n    }\n\n    private void m() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    static class FastScanner {\n        private Reader input;\n\n        public FastScanner() {\n            this(System.in);\n        }\n\n        public FastScanner(InputStream stream) {\n            this.input = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public void close() {\n            try {\n                this.input.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long nextLong() {\n            try {\n                int sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                long ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) return ret * sign;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                return -1;\n            }\n        }\n\n        public double nextDouble() {\n            try {\n                double sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                double ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) break;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n                if (b != '.') return sign * ret;\n                double div = 1;\n                b = input.read();\n                while ('0' <= b && b <= '9') {\n                    ret *= 10;\n                    ret += b - '0';\n                    div *= 10;\n                    b = input.read();\n                }\n                return sign * ret / div;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return Double.NaN;\n            }\n        }\n\n        public char nextChar() {\n            try {\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                return (char) b;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return 0;\n            }\n        }\n\n        public String nextStr() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                while (b != -1 && !Character.isWhitespace(b)) {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public String nextLine() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (b != -1 && b != '\\n') {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public int[] nextIntArrayDec(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt() - 1;\n            }\n            return res;\n        }\n\n        public int[] nextIntArray1Index(int n) {\n            int[] res = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextInt();\n            }\n            return res;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongArrayDec(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong() - 1;\n            }\n            return res;\n        }\n\n        public long[] nextLongArray1Index(int n) {\n            long[] res = new long[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextLong();\n            }\n            return res;\n        }\n\n        public double[] nextDoubleArray(int n) {\n            double[] res = new double[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n    }\n}\n"}
{"id": "Java/72", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    long MOD = 1000000007;\n\n    void solve(BufferedReader in) throws Exception {\n        int[] xx = toInts(in.readLine());\n        int min = Math.min(xx[0], xx[1]);\n        int max = Math.max(xx[0], xx[1]);\n        long res;\n        if (min == max) {\n            long f = f(min);\n            res = (2 * f * f) % MOD;\n        } else if (min + 1 == max) {\n            long f = f(min);\n            res = (f * ((f * max) % MOD)) % MOD;\n        } else {\n            res = 0;\n        }\n        System.out.println(res);\n    }\n\n    long f(int n) {\n        long res = 1;\n        for (int i = 2; i <= n; i++) res = (res * i) % MOD;\n        return res;\n    }\n\n    int toInt(String s) {\n        return Integer.parseInt(s);\n    }\n\n    int[] toInts(String s) {\n        String[] a = s.split(\" \");\n        int[] o = new int[a.length];\n        for (int i = 0; i < a.length; i++) o[i] = toInt(a[i]);\n        return o;\n    }\n\n    void e(Object o) {\n        System.err.println(o);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        (new SampleSolution()).solve(in);\n    }\n}\n", "test_IO": {"input": ["2 2\n"], "output": ["8\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    long MOD = 1000000007;\n\n    void solve(BufferedReader in) throws Exception {\n        int[] xx = toInts(in.readLine());\n        int min = Math.min(xx[0], xx[1]);\n        int max = Math.max(xx[0], xx[1]);\n        long res;\n        if (min == max) {\n            long f = f(min);\n            res = (2 * f * f) % MOD;\n        } else if (min + 1 == max) {\n            long f = f(min);\n            res = (f * ((f * max) % MOD)) % MOD;\n        } else {\n            res = 0;\n        }\n        System.out.println(res);\n    }\n\n    long f(int n) {\n        long res = 1;\n        for (int i = 2; i <= n; i++) res = (res * i) % MOD;\n        return res;\n    }\n\n    int toInt(String s) {\n        return Integer.parseInt(s);\n    }\n\n    int[] toInts(String s) {\n        String[] a = s.split(\" \");\n        int[] o = new int[a.length];\n        for (int i = 0; i < a.length; i++) o[i] = toInt(a[i]);\n        return o;\n    }\n\n    void e(Object o) {\n        System.err.println(o);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        (new SampleSolution()) .solve(in);\n    }\n}\n"}
{"id": "Java/74", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int n, a[];\n    static double dp[][][];\n\n    static void solve() {\n        n = ni();\n        a = na(n);\n        dp = new double[n + 1][n + 1][n + 1];\n        for (int i = 0; i < n + 1; i++) fill(dp[i], -1);\n        dp[0][0][0] = 0;\n        int cnt[] = new int[3];\n        for (int i = 0; i < n; i++) {\n            cnt[a[i] - 1]++;\n        }\n        double ans = rec(cnt[0], cnt[1], cnt[2]);\n        out.println(ans);\n    }\n\n    static double rec(int i, int j, int k) {\n        if (dp[i][j][k] != -1) return dp[i][j][k];\n        double ret = 0;\n        double p = ((double) i + j + k) / n;\n        double pi = (double) i / n;\n        double pj = (double) j / n;\n        double pk = (double) k / n;\n        ret += 1 / p;\n        if (i > 0) ret += pi / p * rec(i - 1, j, k);\n        if (j > 0) ret += pj / p * rec(i + 1, j - 1, k);\n        if (k > 0) ret += pk / p * rec(i, j + 1, k - 1);\n        return dp[i][j][k] = ret;\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "test_IO": {"input": ["3\n1 1 1\n"], "output": ["5.5\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int n, a[];\n    static double dp[][][];\n\n    static void solve() {\n        n = ni();\n        a = na(n);\n        dp = new double[n + 1][n + 1][n + 1];\n        for (int i = 0; i < n + 1; i++) fill(dp[i], -1);\n        dp[0][0][0] = 0;\n        int cnt[] = new int[3];\n        for (int i = 0; i < n; i++) {\n            cnt[a[i] - 1]++;\n        }\n        double ans = rec(cnt[0], cnt[1], cnt[2]);\n        out.println(ans);\n    }\n\n    static double rec(int i, int j, int k) {\n        if (dp[i][j][k] != -1) return dp[i][j][k];\n        double ret = 0;\n        double p = ((double) i + j + k) / n;\n        double pi = (double) i / n;\n        double pj = (double) j / n;\n        double pk = (double) k / n;\n        ret += 1 / p;\n        if (i > 0) ret += pi / p * rec(i - 1, j, k);\n        if (j > 0) ret += pj / p * rec(i + 1, j - 1, k);\n        if (k > 0) ret += pk / p * rec(i, j + 1, k - 1);\n        return dp[i][j][k] = ret;\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n"}
{"id": "Java/78", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[][] a = new char[n][n];\n            long P = 37, Q = 47;\n            long[] powP = new long[n + 1], powQ = new long[n + 1];\n            powP[0] = powQ[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                powP[i] = powP[i - 1] * P;\n                powQ[i] = powQ[i - 1] * Q;\n            }\n            for (int i = 0; i < n; i++) {\n                a[i] = in.next().toCharArray();\n            }\n\n            long[][] hashRow = new long[n][n];\n            long[][] hashCol = new long[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        hashRow[i][k] += a[i][j] * powP[(j - k + n) % n];\n                        hashCol[j][k] += a[i][j] * powP[(i - k + n) % n];\n                    }\n                }\n            }\n\n            int ans = 0;\n            for (int A = 0; A < n; A++) {\n                for (int B = 0; B < n; B++) {\n                    boolean ok = true;\n                    for (int i = 0; i < n; i++) {\n                        ok &= hashRow[(i + A) % n][B] == hashCol[(i + B) % n][A];\n                    }\n                    ans += ok ? 1 : 0;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n    }\n}\n", "test_IO": {"input": ["2\nab\nca\n"], "output": ["2\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[][] a = new char[n][n];\n            long P = 37, Q = 47;\n            long[] powP = new long[n + 1], powQ = new long[n + 1];\n            powP[0] = powQ[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                powP[i] = powP[i - 1] * P;\n                powQ[i] = powQ[i - 1] * Q;\n            }\n            for (int i = 0; i < n; i++) {\n                a[i] = in.next() .toCharArray();\n            }\n\n            long[][] hashRow = new long[n][n];\n            long[][] hashCol = new long[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        hashRow[i][k] += a[i][j] * powP[(j - k + n) % n];\n                        hashCol[j][k] += a[i][j] * powP[(i - k + n) % n];\n                    }\n                }\n            }\n\n            int ans = 0;\n            for (int A = 0; A < n; A++) {\n                for (int B = 0; B < n; B++) {\n                    boolean ok = true;\n                    for (int i = 0; i < n; i++) {\n                        ok &= hashRow[(i + A) % n][B] == hashCol[(i + B) % n][A];\n                    }\n                    ans += ok ? 1 : 0;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n    }\n}\n"}
{"id": "Java/83", "code": "import static java.lang.Integer.parseInt;\n\nimport java.awt.geom.Point2D.Double;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    public void run() {\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n            Point2D p0, p1, p2;\n            String[] line = br.readLine().split(\" \");\n            p0 = new Point2D(parseInt(line[0]), parseInt(line[1]));\n            p1 = new Point2D(parseInt(line[2]), parseInt(line[3]));\n            int q = parseInt(br.readLine());\n\n            StringBuilder buf = new StringBuilder();\n            for (int i = 0; i < q; i++) {\n                line = br.readLine().split(\" \");\n                p2 = new Point2D(parseInt(line[0]), parseInt(line[1]));\n                buf.append(jadgeClockwise(p0, p1, p2)).append(\"\\n\");\n            }\n\n            System.out.print(buf);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    public String jadgeClockwise(Point2D p0, Point2D p1, Point2D p2) {\n        Vector v = new Vector();\n        Point2D a = p1.diff(p0);\n        Point2D b = p2.diff(p0);\n\n        if (v.cross(a, b) > v.EPS) {\n            return \"COUNTER_CLOCKWISE\";\n        }\n        if (v.cross(a, b) < -v.EPS) {\n            return \"CLOCKWISE\";\n        }\n        if (v.dot(a, b) < -v.EPS) {\n            return \"ONLINE_BACK\";\n        }\n        if (a.norm() < b.norm()) {\n            return \"ONLINE_FRONT\";\n        }\n\n        return \"ON_SEGMENT\";\n    }\n\n    private class Point2D extends Double {\n        private static final long serialVersionUID = 1L;\n        double EPS = 1e-10;\n\n        public Point2D() {\n            super();\n        }\n\n        public Point2D(double x, double y) {\n            super(x, y);\n        }\n\n        public boolean equals(double a, double b) {\n            return Math.abs(a - b) < EPS;\n        }\n\n        public Point2D sum(Point2D b) {\n            return new Point2D(x + b.x, y + b.y);\n        }\n\n        public Point2D diff(Point2D b) {\n            return new Point2D(x - b.x, y - b.y);\n        }\n\n        public Point2D multiple(double k) {\n            return new Point2D(x * k, y * k);\n        }\n\n        public double norm() {\n            return x * x + y * y;\n        }\n\n        public double abs(Point2D a) {\n            return Math.sqrt(a.norm());\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%.10f %.10f\", x, y);\n        }\n    }\n\n    private class Vector extends Point2D {\n\n        private static final long serialVersionUID = 1L;\n\n        public Vector() {\n            super();\n        }\n\n        public Vector(double x, double y) {\n            super(x, y);\n        }\n\n        public Vector(Point2D p) {\n            super(p.x, p.y);\n        }\n\n        public double dot(Point2D a, Point2D b) {\n            return a.x * b.x + a.y * b.y;\n        }\n\n        public double cross(Point2D a, Point2D b) {\n            return a.x * b.y - a.y * b.x;\n        }\n\n        public boolean isOrthogonal(Point2D a, Point2D b) {\n            return equals(dot(a, b), 0.0);\n        }\n\n        public boolean isOrthogonal(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isOrthogonal(a1.diff(a2), b1.diff(b2));\n        }\n\n        public boolean isParallel(Point2D a, Point2D b) {\n            return equals(cross(a, b), 0.0);\n        }\n\n        public boolean isParallel(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isParallel(a1.diff(a2), b1.diff(b2));\n        }\n\n        public Point2D project(Point2D sp1, Point2D sp2, Point2D p) {\n            Vector base = new Vector(sp2.diff(sp1));\n            double r = dot(p.diff(sp1), base) / base.norm();\n\n            return sp1.sum(base.multiple(r));\n        }\n\n        public Point2D reflect(Point2D sp1, Point2D sp2, Point2D p) {\n            return p.sum(project(sp1, sp2, p).diff(p).multiple(2.0));\n        }\n    }\n}\n", "test_IO": {"input": ["0 0 2 0\n2\n-1 1\n-1 -1\n"], "output": ["COUNTER_CLOCKWISE\nCLOCKWISE\n"]}, "modified_context": "import static java.lang.Integer.parseInt;\n\nimport java.awt.geom.Point2D.Double;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        new SampleSolution() .run();\n    }\n\n    public void run() {\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n            Point2D p0, p1, p2;\n            String[] line = br.readLine() .split(\" \");\n            p0 = new Point2D(parseInt(line[0]), parseInt(line[1]));\n            p1 = new Point2D(parseInt(line[2]), parseInt(line[3]));\n            int q = parseInt(br.readLine());\n\n            StringBuilder buf = new StringBuilder();\n            for (int i = 0; i < q; i++) {\n                line = br.readLine() .split(\" \");\n                p2 = new Point2D(parseInt(line[0]), parseInt(line[1]));\n                buf.append(jadgeClockwise(p0, p1, p2)) .append(\"\\n\");\n            }\n\n            System.out.print(buf);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    public String jadgeClockwise(Point2D p0, Point2D p1, Point2D p2) {\n        Vector v = new Vector();\n        Point2D a = p1.diff(p0);\n        Point2D b = p2.diff(p0);\n\n        if (v.cross(a, b) > v.EPS) {\n            return \"COUNTER_CLOCKWISE\";\n        }\n        if (v.cross(a, b) < -v.EPS) {\n            return \"CLOCKWISE\";\n        }\n        if (v.dot(a, b) < -v.EPS) {\n            return \"ONLINE_BACK\";\n        }\n        if (a.norm() < b.norm()) {\n            return \"ONLINE_FRONT\";\n        }\n\n        return \"ON_SEGMENT\";\n    }\n\n    private class Point2D extends Double {\n        private static final long serialVersionUID = 1L;\n        double EPS = 1e-10;\n\n        public Point2D() {\n            super();\n        }\n\n        public Point2D(double x, double y) {\n            super(x, y);\n        }\n\n        public boolean equals(double a, double b) {\n            return Math.abs(a - b) < EPS;\n        }\n\n        public Point2D sum(Point2D b) {\n            return new Point2D(x + b.x, y + b.y);\n        }\n\n        public Point2D diff(Point2D b) {\n            return new Point2D(x - b.x, y - b.y);\n        }\n\n        public Point2D multiple(double k) {\n            return new Point2D(x * k, y * k);\n        }\n\n        public double norm() {\n            return x * x + y * y;\n        }\n\n        public double abs(Point2D a) {\n            return Math.sqrt(a.norm());\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%.10f %.10f\", x, y);\n        }\n    }\n\n    private class Vector extends Point2D {\n\n        private static final long serialVersionUID = 1L;\n\n        public Vector() {\n            super();\n        }\n\n        public Vector(double x, double y) {\n            super(x, y);\n        }\n\n        public Vector(Point2D p) {\n            super(p.x, p.y);\n        }\n\n        public double dot(Point2D a, Point2D b) {\n            return a.x * b.x + a.y * b.y;\n        }\n\n        public double cross(Point2D a, Point2D b) {\n            return a.x * b.y - a.y * b.x;\n        }\n\n        public boolean isOrthogonal(Point2D a, Point2D b) {\n            return equals(dot(a, b), 0.0);\n        }\n\n        public boolean isOrthogonal(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isOrthogonal(a1.diff(a2), b1.diff(b2));\n        }\n\n        public boolean isParallel(Point2D a, Point2D b) {\n            return equals(cross(a, b), 0.0);\n        }\n\n        public boolean isParallel(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isParallel(a1.diff(a2), b1.diff(b2));\n        }\n\n        public Point2D project(Point2D sp1, Point2D sp2, Point2D p) {\n            Vector base = new Vector(sp2.diff(sp1));\n            double r = dot(p.diff(sp1), base) / base.norm();\n\n            return sp1.sum(base.multiple(r));\n        }\n\n        public Point2D reflect(Point2D sp1, Point2D sp2, Point2D p) {\n            return p.sum(project(sp1, sp2, p) .diff(p) .multiple(2.0));\n        }\n    }\n}\n"}
{"id": "Java/88", "code": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static int[] counter;\n    static List<List<Integer>> graph;\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int n = fs.nextInt();\n        int q = fs.nextInt();\n        graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) graph.add(new LinkedList<>());\n\n        counter = new int[n];\n        Integer a, b;\n        for (int i = 0; i < n - 1; i++) {\n            a = fs.nextInt() - 1;\n            b = fs.nextInt() - 1;\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n        for (int i = 0; i < q; i++) {\n            counter[fs.nextInt() - 1] += fs.nextInt();\n        }\n        dfs(0, -1, 0);\n        StringJoiner sj = new StringJoiner(\" \");\n        for (int i = 0; i < n; i++) {\n            sj.add(String.valueOf(counter[i]));\n        }\n        System.out.println(sj.toString());\n    }\n\n    static void dfs(int v, int par, long val) {\n\n        for (Integer i : graph.get(v)) {\n            if (i != par) {\n                dfs(i, v, val + counter[v]);\n            }\n        }\n        counter[v] += val;\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "test_IO": {"input": ["4 3\n1 2\n2 3\n2 4\n2 10\n1 100\n3 1\n"], "output": ["100 110 111 110\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static int[] counter;\n    static List<List<Integer>> graph;\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int n = fs.nextInt();\n        int q = fs.nextInt();\n        graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) graph.add(new LinkedList<>());\n\n        counter = new int[n];\n        Integer a, b;\n        for (int i = 0; i < n - 1; i++) {\n            a = fs.nextInt() - 1;\n            b = fs.nextInt() - 1;\n            graph.get(a) .add(b);\n            graph.get(b) .add(a);\n        }\n        for (int i = 0; i < q; i++) {\n            counter[fs.nextInt() - 1] += fs.nextInt();\n        }\n        dfs(0, -1, 0);\n        StringJoiner sj = new StringJoiner(\" \");\n        for (int i = 0; i < n; i++) {\n            sj.add(String.valueOf(counter[i]));\n        }\n        System.out.println(sj.toString());\n    }\n\n    static void dfs(int v, int par, long val) {\n\n        for (Integer i : graph.get(v)) {\n            if (i != par) {\n                dfs(i, v, val + counter[v]);\n            }\n        }\n        counter[v] += val;\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n"}
{"id": "Java/92", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws java.lang.Exception {\n        new Solution();\n    }\n}\n\nclass Solution {\n    Scanner scanner;\n\n    public Solution() {\n        scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            run_case();\n        }\n    }\n\n    private void run_case() {\n\n        String line = scanner.nextLine();\n        int N = Integer.parseInt(line.split(\"\\\\s+\")[0]);\n        int K = Integer.parseInt(line.split(\"\\\\s+\")[1]);\n\n        int len = 0;\n        while (N > 0) {\n            N /= K;\n            len++;\n        }\n\n        System.out.println(len);\n        return;\n    }\n\n    private int[] strToIntArray(String str) {\n        String[] vals = str.split(\"\\\\s+\");\n        int sz = vals.length;\n        int[] res = new int[sz];\n        for (int i = 0; i < sz; i++) {\n            res[i] = Integer.parseInt(vals[i]);\n        }\n        return res;\n    }\n}\n\nclass LCS {\n    int[][] dp;\n\n    public int lcs(String A, String B) {\n        int sz_a = A.length(), sz_b = B.length();\n        dp = new int[sz_a + 1][sz_b + 1];\n\n        for (int i = 0; i <= sz_a; i++) dp[i][0] = 0;\n        for (int j = 0; j <= sz_b; j++) dp[0][j] = 0;\n\n        for (int i = 1; i <= sz_a; i++) {\n            for (int j = 1; j <= sz_b; j++) {\n                if (A.charAt(i - 1) == B.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[sz_a][sz_b];\n    }\n\n    public String getLCS(String X, String Y) {\n        int m = X.length();\n        int n = Y.length();\n\n        int index = dp[m][n];\n        int temp = index;\n\n        char[] lcs = new char[index + 1];\n        lcs[index] = '\\0';\n\n        int i = m;\n        int j = n;\n        while (i > 0 && j > 0) {\n\n            if (X.charAt(i - 1) == Y.charAt(j - 1)) {\n\n                lcs[index - 1] = X.charAt(i - 1);\n\n                i--;\n                j--;\n                index--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) i--;\n            else j--;\n        }\n\n        return String.valueOf(lcs).substring(0, temp + 2);\n    }\n}\n", "test_IO": {"input": ["11 2\n"], "output": ["4\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws java.lang.Exception {\n        new Solution();\n    }\n}\n\nclass Solution {\n    Scanner scanner;\n\n    public Solution() {\n        scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            run_case();\n        }\n    }\n\n    private void run_case() {\n\n        String line = scanner.nextLine();\n        int N = Integer.parseInt(line.split(\"\\\\s+\")[0]);\n        int K = Integer.parseInt(line.split(\"\\\\s+\")[1]);\n\n        int len = 0;\n        while (N > 0) {\n            N /= K;\n            len++;\n        }\n\n        System.out.println(len);\n        return;\n    }\n\n    private int[] strToIntArray(String str) {\n        String[] vals = str.split(\"\\\\s+\");\n        int sz = vals.length;\n        int[] res = new int[sz];\n        for (int i = 0; i < sz; i++) {\n            res[i] = Integer.parseInt(vals[i]);\n        }\n        return res;\n    }\n}\n\nclass LCS {\n    int[][] dp;\n\n    public int lcs(String A, String B) {\n        int sz_a = A.length(), sz_b = B.length();\n        dp = new int[sz_a + 1][sz_b + 1];\n\n        for (int i = 0; i <= sz_a; i++) dp[i][0] = 0;\n        for (int j = 0; j <= sz_b; j++) dp[0][j] = 0;\n\n        for (int i = 1; i <= sz_a; i++) {\n            for (int j = 1; j <= sz_b; j++) {\n                if (A.charAt(i - 1) == B.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[sz_a][sz_b];\n    }\n\n    public String getLCS(String X, String Y) {\n        int m = X.length();\n        int n = Y.length();\n\n        int index = dp[m][n];\n        int temp = index;\n\n        char[] lcs = new char[index + 1];\n        lcs[index] = '\\0';\n\n        int i = m;\n        int j = n;\n        while (i > 0 && j > 0) {\n\n            if (X.charAt(i - 1) == Y.charAt(j - 1)) {\n\n                lcs[index - 1] = X.charAt(i - 1);\n\n                i--;\n                j--;\n                index--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) i--;\n            else j--;\n        }\n\n        return String.valueOf(lcs) .substring(0, temp + 2);\n    }\n}\n"}
{"id": "Java/96", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int mod = (int) 1e9 + 7;\n    static List<ArrayList<Integer>> to;\n    static int dp[];\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner(System.in);\n        int N = fs.nextInt();\n        to = new ArrayList<>();\n        for (int i = 0; i < N; i++) to.add(new ArrayList<Integer>());\n        int edges[][] = new int[N - 1][2];\n        for (int i = 0; i < N - 1; i++) {\n            int A = fs.nextInt() - 1, B = fs.nextInt() - 1;\n            to.get(A).add(B);\n            to.get(B).add(A);\n            edges[i][0] = B;\n            edges[i][1] = A;\n        }\n        dp = new int[N];\n        rec(0, -1);\n        long mulsum = 0;\n        for (int e[] : edges) {\n\n            int candidate1 = e[0];\n            int candidate2 = e[1];\n            int child = candidate1;\n            if (dp[candidate1] > dp[candidate2]) child = candidate2;\n\n            long a = dp[child];\n            long b = N - a;\n\n            long mul = (modpow(2, a) - 1) * (modpow(2, b) - 1) % mod;\n            mulsum += mul;\n            mulsum %= mod;\n        }\n        long cases = modpow(2, N);\n\n        long PN = (mulsum + (cases - 1 + mod) % mod) % mod;\n\n        long BN = N * modpow(2, N - 1) % mod;\n\n        long WN = (PN - BN + mod) % mod;\n        long ans = WN * modpow(cases, mod - 2);\n        ans %= mod;\n\n        System.out.println(ans);\n    }\n\n    static int rec(int v, int parent) {\n        int res = 1;\n        for (int next : to.get(v)) {\n            if (next == parent) continue;\n            res += rec(next, v);\n        }\n        return dp[v] = res;\n    }\n\n    static long modpow(long x, long y) {\n        if (y == 0) return 1;\n        if (y % 2 != 0) return x * modpow(x, y - 1) % mod;\n        long tmp = modpow(x, y / 2);\n        return tmp * tmp % mod;\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    public long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n}\n", "test_IO": {"input": ["3\n1 2\n2 3\n"], "output": ["125000001\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int mod = (int) 1e9 + 7;\n    static List<ArrayList<Integer>> to;\n    static int dp[];\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner(System.in);\n        int N = fs.nextInt();\n        to = new ArrayList<>();\n        for (int i = 0; i < N; i++) to.add(new ArrayList<Integer>());\n        int edges[][] = new int[N - 1][2];\n        for (int i = 0; i < N - 1; i++) {\n            int A = fs.nextInt() - 1, B = fs.nextInt() - 1;\n            to.get(A) .add(B);\n            to.get(B) .add(A);\n            edges[i][0] = B;\n            edges[i][1] = A;\n        }\n        dp = new int[N];\n        rec(0, -1);\n        long mulsum = 0;\n        for (int e[] : edges) {\n\n            int candidate1 = e[0];\n            int candidate2 = e[1];\n            int child = candidate1;\n            if (dp[candidate1] > dp[candidate2]) child = candidate2;\n\n            long a = dp[child];\n            long b = N - a;\n\n            long mul = (modpow(2, a) - 1) * (modpow(2, b) - 1) % mod;\n            mulsum += mul;\n            mulsum %= mod;\n        }\n        long cases = modpow(2, N);\n\n        long PN = (mulsum + (cases - 1 + mod) % mod) % mod;\n\n        long BN = N * modpow(2, N - 1) % mod;\n\n        long WN = (PN - BN + mod) % mod;\n        long ans = WN * modpow(cases, mod - 2);\n        ans %= mod;\n\n        System.out.println(ans);\n    }\n\n    static int rec(int v, int parent) {\n        int res = 1;\n        for (int next : to.get(v)) {\n            if (next == parent) continue;\n            res += rec(next, v);\n        }\n        return dp[v] = res;\n    }\n\n    static long modpow(long x, long y) {\n        if (y == 0) return 1;\n        if (y % 2 != 0) return x * modpow(x, y - 1) % mod;\n        long tmp = modpow(x, y / 2);\n        return tmp * tmp % mod;\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    public long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n}\n"}
{"id": "Java/100", "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 1; i < N + 1; i++) map.put(i, sc.nextInt());\n        System.out.println(\n                String.join(\n                        \" \",\n                        map.entrySet().stream()\n                                .sorted(Entry.<Integer, Integer>comparingByValue())\n                                .map(Map.Entry::getKey)\n                                .map(String::valueOf)\n                                .collect(Collectors.toList())));\n    }\n}\n", "test_IO": {"input": ["3\n2 3 1\n"], "output": ["3 1 2\n"]}, "modified_context": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 1; i < N + 1; i++) map.put(i, sc.nextInt());\n        System.out.println(\n                String.join(\n                        \" \",\n                        map.entrySet() .stream()\n                                .sorted(Entry.<Integer, Integer>comparingByValue())\n                                .map(Map.Entry::getKey)\n                                .map(String::valueOf)\n                                .collect(Collectors.toList())));\n    }\n}\n"}
{"id": "Java/105", "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        DLazyFaith solver = new DLazyFaith();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DLazyFaith {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            int a = in.ints(), b = in.ints(), q = in.ints();\n            long[] s = new long[a + 2], t = new long[b + 2];\n            s[0] = t[0] = -10_000_000_000L;\n            for (int i = 0; i < a; i++) {\n                s[i + 1] = in.longs();\n            }\n            for (int i = 0; i < b; i++) {\n                t[i + 1] = in.longs();\n            }\n            s[a + 1] = t[b + 1] = 20_000_000_000L;\n            for (int i = 0; i < q; i++) {\n                long x = in.longs();\n                long sl = x - s[Math.max(0, ArrayUtil.lowerBound(s, x + 1) - 1)];\n                long tl = x - t[Math.max(0, ArrayUtil.lowerBound(t, x + 1) - 1)];\n                long sr = s[ArrayUtil.lowerBound(s, x)] - x;\n                long tr = t[ArrayUtil.lowerBound(t, x)] - x;\n                out.ansln(\n                        IntMath.min(\n                                Math.max(sl, tl),\n                                Math.max(sr, tr),\n                                2 * sl + tr,\n                                2 * tl + sr,\n                                sl + 2 * tr,\n                                tl + 2 * sr));\n            }\n        }\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n        public long longs() {\n            return Long.parseLong(string());\n        }\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ansln(long... n) {\n            for (long n1 : n) {\n                ans(n1).ln();\n            }\n            return this;\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n    }\n\n    static final class IntMath {\n        private IntMath() {}\n\n        public static long min(long... v) {\n            return Arrays.stream(v).min().orElseThrow(NoSuchElementException::new);\n        }\n    }\n\n    static final class ArrayUtil {\n        private ArrayUtil() {}\n\n        public static int lowerBound(long[] a, long t) {\n            return lowerBound(a, t, 0);\n        }\n\n        public static int lowerBound(long[] a, long t, int min) {\n            int max = a.length;\n            while (min < max) {\n                int mid = (min + max) / 2;\n                if (t <= a[mid]) {\n                    max = mid;\n                } else {\n                    min = mid + 1;\n                }\n            }\n            return min;\n        }\n    }\n}\n", "test_IO": {"input": ["2 3 4\n100\n600\n400\n900\n1000\n150\n2000\n899\n799\n"], "output": ["350\n1400\n301\n399\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        DLazyFaith solver = new DLazyFaith();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DLazyFaith {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            int a = in.ints(), b = in.ints(), q = in.ints();\n            long[] s = new long[a + 2], t = new long[b + 2];\n            s[0] = t[0] = -10_000_000_000L;\n            for (int i = 0; i < a; i++) {\n                s[i + 1] = in.longs();\n            }\n            for (int i = 0; i < b; i++) {\n                t[i + 1] = in.longs();\n            }\n            s[a + 1] = t[b + 1] = 20_000_000_000L;\n            for (int i = 0; i < q; i++) {\n                long x = in.longs();\n                long sl = x - s[Math.max(0, ArrayUtil.lowerBound(s, x + 1) - 1)];\n                long tl = x - t[Math.max(0, ArrayUtil.lowerBound(t, x + 1) - 1)];\n                long sr = s[ArrayUtil.lowerBound(s, x)] - x;\n                long tr = t[ArrayUtil.lowerBound(t, x)] - x;\n                out.ansln(\n                        IntMath.min(\n                                Math.max(sl, tl),\n                                Math.max(sr, tr),\n                                2 * sl + tr,\n                                2 * tl + sr,\n                                sl + 2 * tr,\n                                tl + 2 * sr));\n            }\n        }\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n        public long longs() {\n            return Long.parseLong(string());\n        }\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ansln(long... n) {\n            for (long n1 : n) {\n                ans(n1) .ln();\n            }\n            return this;\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n    }\n\n    static final class IntMath {\n        private IntMath() {}\n\n        public static long min(long... v) {\n            return Arrays.stream(v) .min() .orElseThrow(NoSuchElementException::new);\n        }\n    }\n\n    static final class ArrayUtil {\n        private ArrayUtil() {}\n\n        public static int lowerBound(long[] a, long t) {\n            return lowerBound(a, t, 0);\n        }\n\n        public static int lowerBound(long[] a, long t, int min) {\n            int max = a.length;\n            while (min < max) {\n                int mid = (min + max) / 2;\n                if (t <= a[mid]) {\n                    max = mid;\n                } else {\n                    min = mid + 1;\n                }\n            }\n            return min;\n        }\n    }\n}\n"}
{"id": "Java/111", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n        long MOD = 1000000007;\n        long dp[][] = new long[S.length() + 1][13];\n        dp[0][0] = 1;\n        for (int i = 0; i < S.length(); i++) {\n            if (S.substring(i, i + 1).equals(\"?\")) {\n                for (int j = 0; j < 10; j++) {\n                    for (int k = 0; k < 13; k++) {\n                        dp[i + 1][(k * 10 + j) % 13] += dp[i][k];\n                        dp[i + 1][(k * 10 + j) % 13] %= MOD;\n                    }\n                }\n            } else {\n                for (int k = 0; k < 13; k++) {\n                    int x = Integer.parseInt(S.substring(i, i + 1));\n                    dp[i + 1][(k * 10 + x) % 13] += dp[i][k];\n                    dp[i + 1][(k * 10 + x) % 13] %= MOD;\n                }\n            }\n        }\n        System.out.println(dp[S.length()][5]);\n    }\n}\n", "test_IO": {"input": ["??2??5\n"], "output": ["768\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n        long MOD = 1000000007;\n        long dp[][] = new long[S.length() + 1][13];\n        dp[0][0] = 1;\n        for (int i = 0; i < S.length(); i++) {\n            if (S.substring(i, i + 1) .equals(\"?\")) {\n                for (int j = 0; j < 10; j++) {\n                    for (int k = 0; k < 13; k++) {\n                        dp[i + 1][(k * 10 + j) % 13] += dp[i][k];\n                        dp[i + 1][(k * 10 + j) % 13] %= MOD;\n                    }\n                }\n            } else {\n                for (int k = 0; k < 13; k++) {\n                    int x = Integer.parseInt(S.substring(i, i + 1));\n                    dp[i + 1][(k * 10 + x) % 13] += dp[i][k];\n                    dp[i + 1][(k * 10 + x) % 13] %= MOD;\n                }\n            }\n        }\n        System.out.println(dp[S.length()][5]);\n    }\n}\n"}
{"id": "Java/117", "code": "import java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    static final Scanner sc = new Scanner(System.in);\n    static final PrintStream so = System.out;\n\n    public static void main(String[] args) {\n        int N = nint();\n        int W = nint();\n\n        int[] v = new int[N + 1];\n        int[] w = new int[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            v[i] = nint();\n            w[i] = nint();\n        }\n\n        int[][] sumV = new int[N + 1][W + 1];\n\n        for (int i = 1; i <= N; i++) {\n            for (int i_sum = 0; i_sum < w[i]; i_sum++) {\n                sumV[i][i_sum] = sumV[i - 1][i_sum];\n            }\n\n            for (int i_sum = w[i]; i_sum <= W; i_sum++) {\n                sumV[i][i_sum] = Math.max(sumV[i - 1][i_sum], sumV[i - 1][i_sum - w[i]] + v[i]);\n            }\n        }\n\n        so.println(sumV[N][W]);\n    }\n\n    private static long nlong() {\n        return sc.nextLong();\n    }\n\n    private static int nint() {\n        return sc.nextInt();\n    }\n\n    private static String nstr() {\n        return sc.next();\n    }\n\n    private static char[] nsToChars() {\n        return sc.next().toCharArray();\n    }\n\n    private static long[] nlongs(int n) {\n        return nlongs(n, 0, 0);\n    }\n\n    private static int[] nints(int n) {\n        return nints(n, 0, 0);\n    }\n\n    private static int[] nints(int n, int padL, int padR) {\n        int[] a = new int[padL + n + padR];\n        for (int i = 0; i < n; i++) a[padL + i] = nint();\n        return a;\n    }\n\n    private static long[] nlongs(int n, int padL, int padR) {\n        long[] a = new long[padL + n + padR];\n        for (int i = 0; i < n; i++) a[padL + i] = nlong();\n        return a;\n    }\n\n    private static String[] nstrs(int n) {\n        String[] a = new String[n];\n        for (int i = 0; i < n; i++) a[i] = nstr();\n        return a;\n    }\n\n    private static char[][] nsToChars2D(int h, int w) {\n        return nsToChars2D(h, w, 0);\n    }\n\n    private static char[][] nsToChars2D(int h, int w, int pad) {\n        char[][] a2 = new char[h + pad * 2][w + pad * 2];\n        for (int i = 0; i < h; i++) System.arraycopy(nsToChars(), 0, a2[pad + i], pad, w);\n        return a2;\n    }\n}\n", "test_IO": {"input": ["4 5\n4 2\n5 2\n2 1\n8 3\n"], "output": ["13\n"]}, "modified_context": "import java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    static final Scanner sc = new Scanner(System.in);\n    static final PrintStream so = System.out;\n\n    public static void main(String[] args) {\n        int N = nint();\n        int W = nint();\n\n        int[] v = new int[N + 1];\n        int[] w = new int[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            v[i] = nint();\n            w[i] = nint();\n        }\n\n        int[][] sumV = new int[N + 1][W + 1];\n\n        for (int i = 1; i <= N; i++) {\n            for (int i_sum = 0; i_sum < w[i]; i_sum++) {\n                sumV[i][i_sum] = sumV[i - 1][i_sum];\n            }\n\n            for (int i_sum = w[i]; i_sum <= W; i_sum++) {\n                sumV[i][i_sum] = Math.max(sumV[i - 1][i_sum], sumV[i - 1][i_sum - w[i]] + v[i]);\n            }\n        }\n\n        so.println(sumV[N][W]);\n    }\n\n    private static long nlong() {\n        return sc.nextLong();\n    }\n\n    private static int nint() {\n        return sc.nextInt();\n    }\n\n    private static String nstr() {\n        return sc.next();\n    }\n\n    private static char[] nsToChars() {\n        return sc.next() .toCharArray();\n    }\n\n    private static long[] nlongs(int n) {\n        return nlongs(n, 0, 0);\n    }\n\n    private static int[] nints(int n) {\n        return nints(n, 0, 0);\n    }\n\n    private static int[] nints(int n, int padL, int padR) {\n        int[] a = new int[padL + n + padR];\n        for (int i = 0; i < n; i++) a[padL + i] = nint();\n        return a;\n    }\n\n    private static long[] nlongs(int n, int padL, int padR) {\n        long[] a = new long[padL + n + padR];\n        for (int i = 0; i < n; i++) a[padL + i] = nlong();\n        return a;\n    }\n\n    private static String[] nstrs(int n) {\n        String[] a = new String[n];\n        for (int i = 0; i < n; i++) a[i] = nstr();\n        return a;\n    }\n\n    private static char[][] nsToChars2D(int h, int w) {\n        return nsToChars2D(h, w, 0);\n    }\n\n    private static char[][] nsToChars2D(int h, int w, int pad) {\n        char[][] a2 = new char[h + pad * 2][w + pad * 2];\n        for (int i = 0; i < h; i++) System.arraycopy(nsToChars(), 0, a2[pad + i], pad, w);\n        return a2;\n    }\n}\n"}
{"id": "Java/119", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static final void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    private final Scanner sc = new Scanner(System.in);\n\n    void solve() {\n        int N = sc.nextInt();\n        int max, min;\n        max = min = sc.nextInt();\n        for (int i = 1; i < N; i++) {\n            int in = sc.nextInt();\n            max = Math.max(max, in);\n            min = Math.min(min, in);\n        }\n        System.out.println(max - min);\n    }\n}\n", "test_IO": {"input": ["4\n2 3 7 9\n"], "output": ["7\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static final void main(String[] args) {\n        new SampleSolution() .solve();\n    }\n\n    private final Scanner sc = new Scanner(System.in);\n\n    void solve() {\n        int N = sc.nextInt();\n        int max, min;\n        max = min = sc.nextInt();\n        for (int i = 1; i < N; i++) {\n            int in = sc.nextInt();\n            max = Math.max(max, in);\n            min = Math.min(min, in);\n        }\n        System.out.println(max - min);\n    }\n}\n"}
{"id": "Java/120", "code": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver(in, out);\n        solver.solve();\n\n        out.close();\n    }\n\n    static class Solver {\n        MyInput in;\n        PrintWriter out;\n\n        public Solver(MyInput in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n        }\n\n        public void solve() {\n            int H = ni();\n            int W = ni();\n            char[][] C = new char[H + 2][W + 2];\n            char[] c;\n            for (int i = 0; i < H; i++) {\n                c = ns().toCharArray();\n                for (int j = 0; j < W; j++) {\n                    C[i + 1][j + 1] = c[j];\n                }\n            }\n            if (H == 1 && W == 1) {\n                prn(\"No\");\n                return;\n            }\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (C[i][j] == '#'\n                            && C[i - 1][j] != '#'\n                            && C[i + 1][j] != '#'\n                            && C[i][j - 1] != '#'\n                            && C[i][j + 1] != '#') {\n                        prn(\"No\");\n                        return;\n                    }\n                }\n            }\n            prn(\"Yes\");\n        }\n\n        static class MapCounter {\n            private TreeMap<Integer, Integer> map;\n\n            public MapCounter() {\n                map = new TreeMap<>();\n            }\n\n            public MapCounter(boolean reverse) {\n                if (reverse) {\n                    map = new TreeMap<Integer, Integer>(Collections.reverseOrder());\n                } else {\n                    map = new TreeMap<>();\n                }\n            }\n\n            public void add(Integer key) {\n                add(key, 1);\n            }\n\n            public void add(Integer key, int cnt) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    map.put(key, cnt);\n                } else {\n                    map.put(key, val + cnt);\n                }\n            }\n\n            public void remove(Integer key) {\n                sub(key, 1, false);\n            }\n\n            public void sub(Integer key) {\n                sub(key, 1);\n            }\n\n            public void sub(Integer key, int cnt) {\n                sub(key, cnt, true);\n            }\n\n            public void sub(Integer key, int cnt, boolean minus) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    if (minus) {\n                        map.put(key, -cnt);\n                    }\n                } else if (val > cnt || minus) {\n                    map.put(key, val - cnt);\n                } else {\n                    map.remove(key);\n                }\n            }\n\n            public void set(Integer key, int cnt) {\n                map.put(key, cnt);\n            }\n\n            public Integer getCountwithNull(Integer key) {\n                return map.get(key);\n            }\n\n            public Integer getCount(Integer key) {\n                Integer val = map.get(key);\n                if (val == null) return 0;\n                else return val;\n            }\n\n            public Set<Integer> getKey() {\n                return map.keySet();\n            }\n\n            public int getKeyCount() {\n                return map.keySet().size();\n            }\n\n            public Integer getFirstKey() {\n                return map.firstKey();\n            }\n\n            public Integer getLastKey() {\n                return map.lastKey();\n            }\n\n            public void clear() {\n                map.clear();\n            }\n        }\n\n        boolean isRightMin(int[] a, boolean f, int index, int key) {\n            if (f && a[index] >= key) return true;\n            else if (!f && a[index] > key) return true;\n            else return false;\n        }\n\n        int binarySearchRightMin(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isRightMin(a, f, mid, key)) ok = mid;\n                else ng = mid;\n            }\n            return ok;\n        }\n\n        boolean isLeftMax(int[] a, boolean f, int index, int key) {\n            if (f && a[index] <= key) return true;\n            else if (!f && a[index] < key) return true;\n            else return false;\n        }\n\n        int binarySearchLeftMax(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isLeftMax(a, f, mid, key)) ng = mid;\n                else ok = mid;\n            }\n            return ng;\n        }\n\n        static class EulerTour {\n            Graph g;\n            List<Integer> euler_tour = new ArrayList<>();\n            int[] begin, end;\n            int k = 0, root = 0;\n\n            void dfs(int v, int p, PrintWriter out) {\n                out.println(\"v = \" + v + \"  p = \" + p);\n                begin[v] = k;\n                euler_tour.add(v);\n                k++;\n                if (!g.contains(v)) {\n                    return;\n                }\n                for (int i : g.get(v)) {\n                    if (i != p) {\n                        dfs(i, v, out);\n                        euler_tour.add(v);\n                        k++;\n                    }\n                }\n                end[v] = k;\n            }\n\n            public void init(int p_cnt, int root, Graph g, PrintWriter out) {\n                begin = new int[p_cnt + 1];\n                end = new int[p_cnt + 1];\n                this.root = root;\n                this.g = g;\n                dfs(root, -1, out);\n            }\n\n            public List getPartTour(int v) {\n                return euler_tour.subList(begin[v], end[v]);\n            }\n\n            public List<Integer> getPartList(int v) {\n                Set<Integer> set = new TreeSet<>();\n                set.addAll(getPartTour(v));\n                List<Integer> ans = new ArrayList<>();\n                for (Integer p : set) {\n                    ans.add(p);\n                }\n                return ans;\n            }\n        }\n\n        class Graph {\n\n            private Map<Integer, List<Integer>> data = new HashMap<Integer, List<Integer>>();\n\n            void add(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    list = new ArrayList<Integer>();\n                    data.put(from, list);\n                }\n                list.add(to);\n            }\n\n            void del(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    return;\n                }\n                if (list.contains(to)) {\n                    list.remove((Object) to);\n                }\n            }\n\n            List<Integer> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<Integer> list = data.get(key_1);\n                if (list == null) return false;\n                else return list.contains(key_2);\n            }\n\n            List<PP> distList(int key) {\n                List<PP> dist = new ArrayList<>();\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0));\n                while (!stack.isEmpty()) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist.add(new PP(pp, dd));\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next)) continue;\n                        stack.push(new PP(next, dd + 1));\n                    }\n                }\n                return dist;\n            }\n\n            int[] distV(int key) {\n                int[] dist = new int[data.keySet().size() + 1];\n                Arrays.fill(dist, -1);\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0));\n                while (!stack.isEmpty()) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist[pp] = dd;\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next)) continue;\n                        stack.push(new PP(next, dd + 1));\n                    }\n                }\n                return dist;\n            }\n\n            Map<Integer, Integer> mapCnt = new HashMap<>();\n            Map<Integer, Integer> mapLow = new HashMap<>();\n\n            Set<Integer> mark = new HashSet<>();\n            int number;\n\n            int bridgeDfs(int now, int pre) {\n\n                mark.add(now);\n                mapCnt.put(now, number);\n                mapLow.put(now, number);\n                int low;\n                for (int next : get(now)) {\n                    if (next == pre) continue;\n                    if (mark.contains(next)) {\n                        if (mapLow.get(now) > mapLow.get(next)) {\n\n                            mapLow.put(now, mapLow.get(next));\n                        }\n                        continue;\n                    }\n                    number++;\n                    low = bridgeDfs(next, now);\n                    if (mapLow.get(now) > low) {\n                        mapLow.put(now, low);\n                    }\n                }\n                return mapLow.get(now);\n            }\n\n            int bridgeCnt(int start) {\n                mapCnt.clear();\n                mapLow.clear();\n                mark.clear();\n                number = 0;\n                bridgeDfs(start, start);\n                int ans = 0;\n                for (int key : mapCnt.keySet()) {\n                    if (mapCnt.get(key) == mapLow.get(key)) {\n                        ans++;\n                    }\n                }\n                return ans - 1;\n            }\n\n            void dump(PrintWriter out) {\n                for (int key : data.keySet()) {\n                    out.print(key + \" : \");\n                    for (int val : data.get(key)) {\n                        out.print(val + \" \");\n                    }\n                    out.println(\"\");\n                }\n            }\n        }\n\n        static class GraphWith {\n\n            private Map<Integer, List<PP>> data = new HashMap<Integer, List<PP>>();\n\n            void add(int key, PP p) {\n                List<PP> list = data.get(key);\n                if (list == null) {\n                    list = new ArrayList<PP>();\n                    data.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PP> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<PP> list = data.get(key_1);\n                if (list == null) return false;\n                boolean ans = false;\n                for (PP p : list) {\n                    if (p.getKey() == key_2) {\n                        ans = true;\n                        break;\n                    }\n                }\n                return ans;\n            }\n\n            int distance(int key_1, int key_2) {\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key_1, 0));\n                PP wk;\n                int key, val;\n                List<PP> list;\n                while (!stack.isEmpty()) {\n                    wk = stack.pop();\n                    key = wk.getKey();\n                    val = wk.getVal();\n                    mark.add(key);\n                    if (key == key_2) return val;\n\n                    list = get(key);\n                    if (list == null) continue;\n                    for (PP pp : list) {\n                        if (mark.contains(pp.getKey())) continue;\n                        stack.push(new PP(pp.getKey(), val + pp.getVal()));\n                    }\n                }\n                return Integer.MAX_VALUE;\n            }\n        }\n\n        static class GraphLong {\n            private Map<Long, List<Long>> G = new HashMap<Long, List<Long>>();\n\n            void add(long key, long value) {\n                List<Long> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<Long>();\n                    G.put(key, list);\n                }\n                list.add(value);\n            }\n\n            List<Long> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        static class GraphLongWith {\n            private Map<Long, List<PPL>> G = new HashMap<Long, List<PPL>>();\n\n            void add(long key, PPL p) {\n                List<PPL> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<PPL>();\n                    G.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PPL> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        void prn(String s) {\n            out.println(s);\n        }\n\n        void prn(int i) {\n            out.println(i);\n        }\n\n        void prn(long i) {\n            out.println(i);\n        }\n\n        void prr(String s) {\n            out.print(s);\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        double nd() {\n            return in.nextDouble();\n        }\n\n        String ns() {\n            return in.nextString();\n        }\n\n        int[] ndi(int n) {\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ni();\n            }\n            return ans;\n        }\n\n        long[] ndl(int n) {\n            long[] ans = new long[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nl();\n            }\n            return ans;\n        }\n\n        double[] ndd(int n) {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nd();\n            }\n            return ans;\n        }\n\n        String[] nds(int n) {\n            String[] ans = new String[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ns();\n            }\n            return ans;\n        }\n\n        int[][] nddi(int n, int m) {\n            int[][] ans = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = ni();\n                }\n            }\n            return ans;\n        }\n\n        long[][] nddl(int n, int m) {\n            long[][] ans = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = nl();\n                }\n            }\n            return ans;\n        }\n    }\n\n    static class PP {\n        public int key, val;\n\n        public PP(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        public void setVal(int val) {\n            this.val = val;\n        }\n    }\n\n    static class PPP {\n        public int key, val1, val2;\n\n        public PPP(int key, int val1, int val2) {\n            this.key = key;\n            this.val1 = val1;\n            this.val2 = val2;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal1() {\n            return val1;\n        }\n\n        public void setVal1(int val1) {\n            this.val1 = val1;\n        }\n\n        public int getVal2() {\n            return val2;\n        }\n\n        public void setVal2(int val2) {\n            this.val2 = val2;\n        }\n    }\n\n    static class PPL {\n        public long key, val;\n\n        public PPL(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        public void setVal(long val) {\n            this.val = val;\n        }\n    }\n\n    static class PPDL {\n        public long key;\n        public long[] val;\n\n        public PPDL(long key, long[] val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long[] getVal() {\n            return val;\n        }\n\n        public void setVal(long[] val) {\n            this.val = val;\n        }\n\n        public void dump(PrintWriter out) {\n            out.print(\"key = \" + key + \"  val \");\n            for (int i = 0; i < val.length; i++) {\n                out.print(\"[\" + val[i] + \"] \");\n            }\n            out.println(\"\");\n        }\n    }\n\n    static final class PPKEY {\n        private final int key, val;\n\n        public PPKEY(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static final class PPLKEY {\n        private final long key, val;\n\n        public PPLKEY(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            double ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            int cnt = 0;\n            for (; i < len; i++) {\n                if (str[i] == '.') {\n                    cnt = 10;\n                    continue;\n                }\n                if (cnt == 0) {\n                    ret = ret * 10 + str[i] - '0';\n                } else {\n                    ret = ret + ((double) (str[i] - '0') / cnt);\n                    cnt *= 10;\n                }\n            }\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar()).trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n", "test_IO": {"input": ["3 3\n.#.\n###\n.#.\n"], "output": ["Yes\n"]}, "modified_context": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver(in, out);\n        solver.solve();\n\n        out.close();\n    }\n\n    static class Solver {\n        MyInput in;\n        PrintWriter out;\n\n        public Solver(MyInput in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n        }\n\n        public void solve() {\n            int H = ni();\n            int W = ni();\n            char[][] C = new char[H + 2][W + 2];\n            char[] c;\n            for (int i = 0; i < H; i++) {\n                c = ns() .toCharArray();\n                for (int j = 0; j < W; j++) {\n                    C[i + 1][j + 1] = c[j];\n                }\n            }\n            if (H == 1 && W == 1) {\n                prn(\"No\");\n                return;\n            }\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (C[i][j] == '#'\n                            && C[i - 1][j] != '#'\n                            && C[i + 1][j] != '#'\n                            && C[i][j - 1] != '#'\n                            && C[i][j + 1] != '#') {\n                        prn(\"No\");\n                        return;\n                    }\n                }\n            }\n            prn(\"Yes\");\n        }\n\n        static class MapCounter {\n            private TreeMap<Integer, Integer> map;\n\n            public MapCounter() {\n                map = new TreeMap<>();\n            }\n\n            public MapCounter(boolean reverse) {\n                if (reverse) {\n                    map = new TreeMap<Integer, Integer>(Collections.reverseOrder());\n                } else {\n                    map = new TreeMap<>();\n                }\n            }\n\n            public void add(Integer key) {\n                add(key, 1);\n            }\n\n            public void add(Integer key, int cnt) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    map.put(key, cnt);\n                } else {\n                    map.put(key, val + cnt);\n                }\n            }\n\n            public void remove(Integer key) {\n                sub(key, 1, false);\n            }\n\n            public void sub(Integer key) {\n                sub(key, 1);\n            }\n\n            public void sub(Integer key, int cnt) {\n                sub(key, cnt, true);\n            }\n\n            public void sub(Integer key, int cnt, boolean minus) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    if (minus) {\n                        map.put(key, -cnt);\n                    }\n                } else if (val > cnt || minus) {\n                    map.put(key, val - cnt);\n                } else {\n                    map.remove(key);\n                }\n            }\n\n            public void set(Integer key, int cnt) {\n                map.put(key, cnt);\n            }\n\n            public Integer getCountwithNull(Integer key) {\n                return map.get(key);\n            }\n\n            public Integer getCount(Integer key) {\n                Integer val = map.get(key);\n                if (val == null) return 0;\n                else return val;\n            }\n\n            public Set<Integer> getKey() {\n                return map.keySet();\n            }\n\n            public int getKeyCount() {\n                return map.keySet() .size();\n            }\n\n            public Integer getFirstKey() {\n                return map.firstKey();\n            }\n\n            public Integer getLastKey() {\n                return map.lastKey();\n            }\n\n            public void clear() {\n                map.clear();\n            }\n        }\n\n        boolean isRightMin(int[] a, boolean f, int index, int key) {\n            if (f && a[index] >= key) return true;\n            else if (!f && a[index] > key) return true;\n            else return false;\n        }\n\n        int binarySearchRightMin(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isRightMin(a, f, mid, key)) ok = mid;\n                else ng = mid;\n            }\n            return ok;\n        }\n\n        boolean isLeftMax(int[] a, boolean f, int index, int key) {\n            if (f && a[index] <= key) return true;\n            else if (!f && a[index] < key) return true;\n            else return false;\n        }\n\n        int binarySearchLeftMax(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isLeftMax(a, f, mid, key)) ng = mid;\n                else ok = mid;\n            }\n            return ng;\n        }\n\n        static class EulerTour {\n            Graph g;\n            List<Integer> euler_tour = new ArrayList<>();\n            int[] begin, end;\n            int k = 0, root = 0;\n\n            void dfs(int v, int p, PrintWriter out) {\n                out.println(\"v = \" + v + \"  p = \" + p);\n                begin[v] = k;\n                euler_tour.add(v);\n                k++;\n                if (!g.contains(v)) {\n                    return;\n                }\n                for (int i : g.get(v)) {\n                    if (i != p) {\n                        dfs(i, v, out);\n                        euler_tour.add(v);\n                        k++;\n                    }\n                }\n                end[v] = k;\n            }\n\n            public void init(int p_cnt, int root, Graph g, PrintWriter out) {\n                begin = new int[p_cnt + 1];\n                end = new int[p_cnt + 1];\n                this.root = root;\n                this.g = g;\n                dfs(root, -1, out);\n            }\n\n            public List getPartTour(int v) {\n                return euler_tour.subList(begin[v], end[v]);\n            }\n\n            public List<Integer> getPartList(int v) {\n                Set<Integer> set = new TreeSet<>();\n                set.addAll(getPartTour(v));\n                List<Integer> ans = new ArrayList<>();\n                for (Integer p : set) {\n                    ans.add(p);\n                }\n                return ans;\n            }\n        }\n\n        class Graph {\n\n            private Map<Integer, List<Integer>> data = new HashMap<Integer, List<Integer>>();\n\n            void add(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    list = new ArrayList<Integer>();\n                    data.put(from, list);\n                }\n                list.add(to);\n            }\n\n            void del(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    return;\n                }\n                if (list.contains(to)) {\n                    list.remove((Object) to);\n                }\n            }\n\n            List<Integer> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<Integer> list = data.get(key_1);\n                if (list == null) return false;\n                else return list.contains(key_2);\n            }\n\n            List<PP> distList(int key) {\n                List<PP> dist = new ArrayList<>();\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0));\n                while (!stack.isEmpty()) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist.add(new PP(pp, dd));\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next)) continue;\n                        stack.push(new PP(next, dd + 1));\n                    }\n                }\n                return dist;\n            }\n\n            int[] distV(int key) {\n                int[] dist = new int[data.keySet() .size() + 1];\n                Arrays.fill(dist, -1);\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0));\n                while (!stack.isEmpty()) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist[pp] = dd;\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next)) continue;\n                        stack.push(new PP(next, dd + 1));\n                    }\n                }\n                return dist;\n            }\n\n            Map<Integer, Integer> mapCnt = new HashMap<>();\n            Map<Integer, Integer> mapLow = new HashMap<>();\n\n            Set<Integer> mark = new HashSet<>();\n            int number;\n\n            int bridgeDfs(int now, int pre) {\n\n                mark.add(now);\n                mapCnt.put(now, number);\n                mapLow.put(now, number);\n                int low;\n                for (int next : get(now)) {\n                    if (next == pre) continue;\n                    if (mark.contains(next)) {\n                        if (mapLow.get(now) > mapLow.get(next)) {\n\n                            mapLow.put(now, mapLow.get(next));\n                        }\n                        continue;\n                    }\n                    number++;\n                    low = bridgeDfs(next, now);\n                    if (mapLow.get(now) > low) {\n                        mapLow.put(now, low);\n                    }\n                }\n                return mapLow.get(now);\n            }\n\n            int bridgeCnt(int start) {\n                mapCnt.clear();\n                mapLow.clear();\n                mark.clear();\n                number = 0;\n                bridgeDfs(start, start);\n                int ans = 0;\n                for (int key : mapCnt.keySet()) {\n                    if (mapCnt.get(key) == mapLow.get(key)) {\n                        ans++;\n                    }\n                }\n                return ans - 1;\n            }\n\n            void dump(PrintWriter out) {\n                for (int key : data.keySet()) {\n                    out.print(key + \" : \");\n                    for (int val : data.get(key)) {\n                        out.print(val + \" \");\n                    }\n                    out.println(\"\");\n                }\n            }\n        }\n\n        static class GraphWith {\n\n            private Map<Integer, List<PP>> data = new HashMap<Integer, List<PP>>();\n\n            void add(int key, PP p) {\n                List<PP> list = data.get(key);\n                if (list == null) {\n                    list = new ArrayList<PP>();\n                    data.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PP> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<PP> list = data.get(key_1);\n                if (list == null) return false;\n                boolean ans = false;\n                for (PP p : list) {\n                    if (p.getKey() == key_2) {\n                        ans = true;\n                        break;\n                    }\n                }\n                return ans;\n            }\n\n            int distance(int key_1, int key_2) {\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key_1, 0));\n                PP wk;\n                int key, val;\n                List<PP> list;\n                while (!stack.isEmpty()) {\n                    wk = stack.pop();\n                    key = wk.getKey();\n                    val = wk.getVal();\n                    mark.add(key);\n                    if (key == key_2) return val;\n\n                    list = get(key);\n                    if (list == null) continue;\n                    for (PP pp : list) {\n                        if (mark.contains(pp.getKey())) continue;\n                        stack.push(new PP(pp.getKey(), val + pp.getVal()));\n                    }\n                }\n                return Integer.MAX_VALUE;\n            }\n        }\n\n        static class GraphLong {\n            private Map<Long, List<Long>> G = new HashMap<Long, List<Long>>();\n\n            void add(long key, long value) {\n                List<Long> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<Long>();\n                    G.put(key, list);\n                }\n                list.add(value);\n            }\n\n            List<Long> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        static class GraphLongWith {\n            private Map<Long, List<PPL>> G = new HashMap<Long, List<PPL>>();\n\n            void add(long key, PPL p) {\n                List<PPL> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<PPL>();\n                    G.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PPL> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        void prn(String s) {\n            out.println(s);\n        }\n\n        void prn(int i) {\n            out.println(i);\n        }\n\n        void prn(long i) {\n            out.println(i);\n        }\n\n        void prr(String s) {\n            out.print(s);\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        double nd() {\n            return in.nextDouble();\n        }\n\n        String ns() {\n            return in.nextString();\n        }\n\n        int[] ndi(int n) {\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ni();\n            }\n            return ans;\n        }\n\n        long[] ndl(int n) {\n            long[] ans = new long[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nl();\n            }\n            return ans;\n        }\n\n        double[] ndd(int n) {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nd();\n            }\n            return ans;\n        }\n\n        String[] nds(int n) {\n            String[] ans = new String[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ns();\n            }\n            return ans;\n        }\n\n        int[][] nddi(int n, int m) {\n            int[][] ans = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = ni();\n                }\n            }\n            return ans;\n        }\n\n        long[][] nddl(int n, int m) {\n            long[][] ans = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = nl();\n                }\n            }\n            return ans;\n        }\n    }\n\n    static class PP {\n        public int key, val;\n\n        public PP(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        public void setVal(int val) {\n            this.val = val;\n        }\n    }\n\n    static class PPP {\n        public int key, val1, val2;\n\n        public PPP(int key, int val1, int val2) {\n            this.key = key;\n            this.val1 = val1;\n            this.val2 = val2;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal1() {\n            return val1;\n        }\n\n        public void setVal1(int val1) {\n            this.val1 = val1;\n        }\n\n        public int getVal2() {\n            return val2;\n        }\n\n        public void setVal2(int val2) {\n            this.val2 = val2;\n        }\n    }\n\n    static class PPL {\n        public long key, val;\n\n        public PPL(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        public void setVal(long val) {\n            this.val = val;\n        }\n    }\n\n    static class PPDL {\n        public long key;\n        public long[] val;\n\n        public PPDL(long key, long[] val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long[] getVal() {\n            return val;\n        }\n\n        public void setVal(long[] val) {\n            this.val = val;\n        }\n\n        public void dump(PrintWriter out) {\n            out.print(\"key = \" + key + \"  val \");\n            for (int i = 0; i < val.length; i++) {\n                out.print(\"[\" + val[i] + \"] \");\n            }\n            out.println(\"\");\n        }\n    }\n\n    static final class PPKEY {\n        private final int key, val;\n\n        public PPKEY(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static final class PPLKEY {\n        private final long key, val;\n\n        public PPLKEY(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            double ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            int cnt = 0;\n            for (; i < len; i++) {\n                if (str[i] == '.') {\n                    cnt = 10;\n                    continue;\n                }\n                if (cnt == 0) {\n                    ret = ret * 10 + str[i] - '0';\n                } else {\n                    ret = ret + ((double) (str[i] - '0') / cnt);\n                    cnt *= 10;\n                }\n            }\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar()) .trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n"}
{"id": "Java/124", "code": "import java.util.*;\n\npublic class SampleSolution {\n    static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] $) {\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        String[] ans = new String[h];\n        for (int i = 0; i < h; i++) {\n            ans[i] = \"#\" + scanner.next() + \"#\";\n        }\n        System.out.println(String.valueOf(new char[w + 2]).replace('\\0', '#'));\n        for (String s : ans) {\n            System.out.println(s);\n        }\n        System.out.println(String.valueOf(new char[w + 2]).replace('\\0', '#'));\n    }\n}\n", "test_IO": {"input": ["2 3\nabc\narc\n"], "output": ["#####\n#abc#\n#arc#\n#####\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] $) {\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        String[] ans = new String[h];\n        for (int i = 0; i < h; i++) {\n            ans[i] = \"#\" + scanner.next() + \"#\";\n        }\n        System.out.println(String.valueOf(new char[w + 2]) .replace('\\0', '#'));\n        for (String s : ans) {\n            System.out.println(s);\n        }\n        System.out.println(String.valueOf(new char[w + 2]) .replace('\\0', '#'));\n    }\n}\n"}
{"id": "Java/125", "code": "import java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        char c[] = sc.next().toCharArray();\n        for (int i = 0; i < c.length; i++) {\n            c[i] = (char) ((c[i] - 'A' + N) % 26 + 'A');\n        }\n        System.out.println(c);\n    }\n}\n", "test_IO": {"input": ["2\nABCXYZ\n"], "output": ["CDEZAB\n"]}, "modified_context": "import java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        char c[] = sc.next() .toCharArray();\n        for (int i = 0; i < c.length; i++) {\n            c[i] = (char) ((c[i] - 'A' + N) % 26 + 'A');\n        }\n        System.out.println(c);\n    }\n}\n"}
{"id": "Java/128", "code": "import java.util.*;\n\nclass SampleSolution {\n    final Scanner sc = new Scanner(System.in);\n    final long DEVISOR = 1000000000 + 7;\n\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    private void run() {\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        long ans = 0;\n        for (long i = k; i <= n + 1; i++) {\n            long max = i * (2 * n - i + 1) / 2;\n            long min = i * (i - 1) / 2;\n            ans += (max - min + 1) % DEVISOR;\n        }\n        System.out.println(ans % DEVISOR);\n    }\n}\n", "test_IO": {"input": ["3 2\n"], "output": ["10\n"]}, "modified_context": "import java.util.*;\n\nclass SampleSolution {\n    final Scanner sc = new Scanner(System.in);\n    final long DEVISOR = 1000000000 + 7;\n\n    public static void main(String[] args) {\n        new SampleSolution() .run();\n    }\n\n    private void run() {\n        long n = sc.nextLong();\n        long k = sc.nextLong();\n\n        long ans = 0;\n        for (long i = k; i <= n + 1; i++) {\n            long max = i * (2 * n - i + 1) / 2;\n            long min = i * (i - 1) / 2;\n            ans += (max - min + 1) % DEVISOR;\n        }\n        System.out.println(ans % DEVISOR);\n    }\n}\n"}
{"id": "Java/133", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        int count = new Scanner(System.in).nextInt();\n\n        int total = 0;\n        for (int ix = 1; ix <= count; ix++) {\n            total += ix;\n        }\n\n        System.out.println(total);\n    }\n}\n", "test_IO": {"input": ["3\n"], "output": ["6\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        int count = new Scanner(System.in) .nextInt();\n\n        int total = 0;\n        for (int ix = 1; ix <= count; ix++) {\n            total += ix;\n        }\n\n        System.out.println(total);\n    }\n}\n"}
{"id": "Java/134", "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    void tr(Object... os) {\n        System.err.println(deepToString(os));\n    }\n\n    Scanner sc = new Scanner(System.in);\n\n    public void run() {\n        for (; sc.hasNext(); ) {\n            int my1 = sc.nextInt();\n            int my2 = sc.nextInt();\n            int enemy1 = sc.nextInt();\n            boolean[] used = new boolean[11];\n            used[my1] = true;\n            used[my2] = true;\n            used[enemy1] = true;\n            int all = 0;\n            int safe = 0;\n            for (int i = 1; i <= 10; i++)\n                if (!used[i]) {\n                    all++;\n                    if (my1 + my2 + i <= 20) safe++;\n                }\n            if (safe * 2 >= all) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n    }\n\n    char solve(int[][] a) {\n        char[] s = {'d', 'o', 'x'};\n        for (int side = 1; side <= 2; side++) {\n            for (int i = 0; i < 3; i++) {\n                if (a[i][0] == side && a[i][1] == side && a[i][2] == side) return s[side];\n                if (a[0][i] == side && a[1][i] == side && a[2][i] == side) return s[side];\n            }\n            if (a[0][0] == side && a[1][1] == side && a[2][2] == side) return s[side];\n            if (a[0][2] == side && a[1][1] == side && a[2][0] == side) return s[side];\n        }\n        return 'd';\n    }\n}\n", "test_IO": {"input": ["1 2 3\n5 6 9\n8 9 10\n"], "output": ["YES\nYES\nNO\n"]}, "modified_context": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        new SampleSolution() .run();\n    }\n\n    void tr(Object... os) {\n        System.err.println(deepToString(os));\n    }\n\n    Scanner sc = new Scanner(System.in);\n\n    public void run() {\n        for (; sc.hasNext(); ) {\n            int my1 = sc.nextInt();\n            int my2 = sc.nextInt();\n            int enemy1 = sc.nextInt();\n            boolean[] used = new boolean[11];\n            used[my1] = true;\n            used[my2] = true;\n            used[enemy1] = true;\n            int all = 0;\n            int safe = 0;\n            for (int i = 1; i <= 10; i++)\n                if (!used[i]) {\n                    all++;\n                    if (my1 + my2 + i <= 20) safe++;\n                }\n            if (safe * 2 >= all) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n    }\n\n    char solve(int[][] a) {\n        char[] s = {'d', 'o', 'x'};\n        for (int side = 1; side <= 2; side++) {\n            for (int i = 0; i < 3; i++) {\n                if (a[i][0] == side && a[i][1] == side && a[i][2] == side) return s[side];\n                if (a[0][i] == side && a[1][i] == side && a[2][i] == side) return s[side];\n            }\n            if (a[0][0] == side && a[1][1] == side && a[2][2] == side) return s[side];\n            if (a[0][2] == side && a[1][1] == side && a[2][0] == side) return s[side];\n        }\n        return 'd';\n    }\n}\n"}
{"id": "Java/136", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static void solve() {\n        String tmp = ns();\n        char s[] = tmp.toCharArray();\n        int n = s.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'S') {\n                cnt++;\n            } else {\n                if (cnt == 0) continue;\n                ans++;\n                cnt--;\n            }\n        }\n        out.println(n - 2 * ans);\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "test_IO": {"input": ["TSTTSS\n"], "output": ["4\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static void solve() {\n        String tmp = ns();\n        char s[] = tmp.toCharArray();\n        int n = s.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'S') {\n                cnt++;\n            } else {\n                if (cnt == 0) continue;\n                ans++;\n                cnt--;\n            }\n        }\n        out.println(n - 2 * ans);\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1) .compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1) .compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1) .compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread() .getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n"}
{"id": "Java/151", "code": "import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution implements Runnable {\n    @Override\n    public void run() {\n        try {\n            new Solver().solve();\n            System.exit(0);\n        } catch (Exception | Error e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        new SampleSolution().run();\n    }\n}\n\nclass Solver {\n    final Helper hp;\n    final int MAXN = 1000_006;\n    final long MOD = (long) 1e9 + 7;\n\n    final Timer timer;\n    final TimerTask task;\n\n    Solver() {\n        hp = new Helper(MOD, MAXN);\n        hp.initIO(System.in, System.out);\n\n        timer = new Timer();\n        task =\n                new TimerTask() {\n                    @Override\n                    public void run() {\n                        try {\n                            hp.flush();\n                            System.exit(0);\n                        } catch (Exception e) {\n                        }\n                    }\n                };\n    }\n\n    void solve() throws Exception {\n        int tc = TESTCASES ? hp.getNextInt() : 1;\n        for (int tce = 1; tce <= tc; ++tce) solve(tce);\n        timer.cancel();\n        hp.flush();\n    }\n\n    boolean TESTCASES = false;\n\n    void solve(int tc) throws Exception {\n        int i, j, k;\n\n        int N = hp.getNextInt();\n        long K = hp.nextLong();\n        int[] A = hp.getIntArray(N);\n\n        ArrayList<Integer> straight = new ArrayList<>(), cycle = new ArrayList<>();\n        boolean[] vis = new boolean[N];\n        int curr = 0;\n        while (!vis[curr]) {\n            vis[curr] = true;\n            curr = A[curr] - 1;\n        }\n\n        int st = 0;\n        while (st != curr) {\n            straight.add(st);\n            st = A[st] - 1;\n        }\n\n        cycle.add(curr);\n        curr = A[curr] - 1;\n        while (curr != cycle.get(0)) {\n            cycle.add(curr);\n            curr = A[curr] - 1;\n        }\n\n        if (K < straight.size()) {\n            hp.println(straight.get((int) K) + 1);\n        } else {\n            K -= straight.size();\n            hp.println(cycle.get((int) (K % cycle.size())) + 1);\n        }\n    }\n}\n\nclass Helper {\n    final long MOD;\n    final int MAXN;\n    final Random rnd;\n\n    public Helper(long mod, int maxn) {\n        MOD = mod;\n        MAXN = maxn;\n        rnd = new Random();\n    }\n\n    public static int[] sieve;\n    public static ArrayList<Integer> primes;\n\n    public void setSieve() {\n        primes = new ArrayList<>();\n        sieve = new int[MAXN];\n        int i, j;\n        for (i = 2; i < MAXN; ++i)\n            if (sieve[i] == 0) {\n                primes.add(i);\n                for (j = i; j < MAXN; j += i) {\n                    sieve[j] = i;\n                }\n            }\n    }\n\n    public static long[] factorial;\n\n    public void setFactorial() {\n        factorial = new long[MAXN];\n        factorial[0] = 1;\n        for (int i = 1; i < MAXN; ++i) factorial[i] = factorial[i - 1] * i % MOD;\n    }\n\n    public long getFactorial(int n) {\n        if (factorial == null) setFactorial();\n        return factorial[n];\n    }\n\n    public long ncr(int n, int r) {\n        if (r > n) return 0;\n        if (factorial == null) setFactorial();\n        long numerator = factorial[n];\n        long denominator = factorial[r] * factorial[n - r] % MOD;\n        return numerator * pow(denominator, MOD - 2, MOD) % MOD;\n    }\n\n    public long[] getLongArray(int size) throws Exception {\n        long[] ar = new long[size];\n        for (int i = 0; i < size; ++i) ar[i] = nextLong();\n        return ar;\n    }\n\n    public int[] getIntArray(int size) throws Exception {\n        int[] ar = new int[size];\n        for (int i = 0; i < size; ++i) ar[i] = getNextInt();\n        return ar;\n    }\n\n    public String[] getStringArray(int size) throws Exception {\n        String[] ar = new String[size];\n        for (int i = 0; i < size; ++i) ar[i] = next();\n        return ar;\n    }\n\n    public String joinElements(long... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (long itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(int... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (int itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(String... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (String itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(Object... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (Object itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public long max(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public int max(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public long min(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public int min(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public long sum(long... ar) {\n        long sum = 0;\n        for (long itr : ar) sum += itr;\n        return sum;\n    }\n\n    public long sum(int... ar) {\n        long sum = 0;\n        for (int itr : ar) sum += itr;\n        return sum;\n    }\n\n    public void shuffle(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void shuffle(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public long pow(long base, long exp, long MOD) {\n        base %= MOD;\n        long ret = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) ret = ret * base % MOD;\n            base = base * base % MOD;\n            exp >>= 1;\n        }\n        return ret;\n    }\n\n    static final int BUFSIZE = 1 << 20;\n    static byte[] buf;\n    static int index, total;\n    static InputStream in;\n    static BufferedWriter bw;\n\n    public void initIO(InputStream is, OutputStream os) {\n        try {\n            in = is;\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    public void initIO(String inputFile, String outputFile) {\n        try {\n            in = new FileInputStream(inputFile);\n            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    private int scan() throws Exception {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) return -1;\n        }\n        return buf[index++];\n    }\n\n    public String next() throws Exception {\n        int c;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) sb.append((char) c);\n        return sb.toString();\n    }\n\n    public int getNextInt() throws Exception {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan()) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public long nextLong() throws Exception {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan()) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public void print(Object a) throws Exception {\n        bw.write(a.toString());\n    }\n\n    public void printsp(Object a) throws Exception {\n        print(a);\n        print(\" \");\n    }\n\n    public void println() throws Exception {\n        bw.write(\"\\n\");\n    }\n\n    public void println(Object a) throws Exception {\n        print(a);\n        println();\n    }\n\n    public void flush() throws Exception {\n        bw.flush();\n    }\n}\n", "test_IO": {"input": ["4 5\n3 2 4 1\n"], "output": ["4\n"]}, "modified_context": "import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution implements Runnable {\n    @Override\n    public void run() {\n        try {\n            new Solver() .solve();\n            System.exit(0);\n        } catch (Exception | Error e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        new SampleSolution() .run();\n    }\n}\n\nclass Solver {\n    final Helper hp;\n    final int MAXN = 1000_006;\n    final long MOD = (long) 1e9 + 7;\n\n    final Timer timer;\n    final TimerTask task;\n\n    Solver() {\n        hp = new Helper(MOD, MAXN);\n        hp.initIO(System.in, System.out);\n\n        timer = new Timer();\n        task =\n                new TimerTask() {\n                    @Override\n                    public void run() {\n                        try {\n                            hp.flush();\n                            System.exit(0);\n                        } catch (Exception e) {\n                        }\n                    }\n                };\n    }\n\n    void solve() throws Exception {\n        int tc = TESTCASES ? hp.getNextInt() : 1;\n        for (int tce = 1; tce <= tc; ++tce) solve(tce);\n        timer.cancel();\n        hp.flush();\n    }\n\n    boolean TESTCASES = false;\n\n    void solve(int tc) throws Exception {\n        int i, j, k;\n\n        int N = hp.getNextInt();\n        long K = hp.nextLong();\n        int[] A = hp.getIntArray(N);\n\n        ArrayList<Integer> straight = new ArrayList<>(), cycle = new ArrayList<>();\n        boolean[] vis = new boolean[N];\n        int curr = 0;\n        while (!vis[curr]) {\n            vis[curr] = true;\n            curr = A[curr] - 1;\n        }\n\n        int st = 0;\n        while (st != curr) {\n            straight.add(st);\n            st = A[st] - 1;\n        }\n\n        cycle.add(curr);\n        curr = A[curr] - 1;\n        while (curr != cycle.get(0)) {\n            cycle.add(curr);\n            curr = A[curr] - 1;\n        }\n\n        if (K < straight.size()) {\n            hp.println(straight.get((int) K) + 1);\n        } else {\n            K -= straight.size();\n            hp.println(cycle.get((int) (K % cycle.size())) + 1);\n        }\n    }\n}\n\nclass Helper {\n    final long MOD;\n    final int MAXN;\n    final Random rnd;\n\n    public Helper(long mod, int maxn) {\n        MOD = mod;\n        MAXN = maxn;\n        rnd = new Random();\n    }\n\n    public static int[] sieve;\n    public static ArrayList<Integer> primes;\n\n    public void setSieve() {\n        primes = new ArrayList<>();\n        sieve = new int[MAXN];\n        int i, j;\n        for (i = 2; i < MAXN; ++i)\n            if (sieve[i] == 0) {\n                primes.add(i);\n                for (j = i; j < MAXN; j += i) {\n                    sieve[j] = i;\n                }\n            }\n    }\n\n    public static long[] factorial;\n\n    public void setFactorial() {\n        factorial = new long[MAXN];\n        factorial[0] = 1;\n        for (int i = 1; i < MAXN; ++i) factorial[i] = factorial[i - 1] * i % MOD;\n    }\n\n    public long getFactorial(int n) {\n        if (factorial == null) setFactorial();\n        return factorial[n];\n    }\n\n    public long ncr(int n, int r) {\n        if (r > n) return 0;\n        if (factorial == null) setFactorial();\n        long numerator = factorial[n];\n        long denominator = factorial[r] * factorial[n - r] % MOD;\n        return numerator * pow(denominator, MOD - 2, MOD) % MOD;\n    }\n\n    public long[] getLongArray(int size) throws Exception {\n        long[] ar = new long[size];\n        for (int i = 0; i < size; ++i) ar[i] = nextLong();\n        return ar;\n    }\n\n    public int[] getIntArray(int size) throws Exception {\n        int[] ar = new int[size];\n        for (int i = 0; i < size; ++i) ar[i] = getNextInt();\n        return ar;\n    }\n\n    public String[] getStringArray(int size) throws Exception {\n        String[] ar = new String[size];\n        for (int i = 0; i < size; ++i) ar[i] = next();\n        return ar;\n    }\n\n    public String joinElements(long... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (long itr : ar) sb.append(itr) .append(\" \");\n        return sb.toString() .trim();\n    }\n\n    public String joinElements(int... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (int itr : ar) sb.append(itr) .append(\" \");\n        return sb.toString() .trim();\n    }\n\n    public String joinElements(String... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (String itr : ar) sb.append(itr) .append(\" \");\n        return sb.toString() .trim();\n    }\n\n    public String joinElements(Object... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (Object itr : ar) sb.append(itr) .append(\" \");\n        return sb.toString() .trim();\n    }\n\n    public long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public long max(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public int max(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public long min(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public int min(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public long sum(long... ar) {\n        long sum = 0;\n        for (long itr : ar) sum += itr;\n        return sum;\n    }\n\n    public long sum(int... ar) {\n        long sum = 0;\n        for (int itr : ar) sum += itr;\n        return sum;\n    }\n\n    public void shuffle(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void shuffle(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public long pow(long base, long exp, long MOD) {\n        base %= MOD;\n        long ret = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) ret = ret * base % MOD;\n            base = base * base % MOD;\n            exp >>= 1;\n        }\n        return ret;\n    }\n\n    static final int BUFSIZE = 1 << 20;\n    static byte[] buf;\n    static int index, total;\n    static InputStream in;\n    static BufferedWriter bw;\n\n    public void initIO(InputStream is, OutputStream os) {\n        try {\n            in = is;\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    public void initIO(String inputFile, String outputFile) {\n        try {\n            in = new FileInputStream(inputFile);\n            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    private int scan() throws Exception {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) return -1;\n        }\n        return buf[index++];\n    }\n\n    public String next() throws Exception {\n        int c;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) sb.append((char) c);\n        return sb.toString();\n    }\n\n    public int getNextInt() throws Exception {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan()) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public long nextLong() throws Exception {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan()) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public void print(Object a) throws Exception {\n        bw.write(a.toString());\n    }\n\n    public void printsp(Object a) throws Exception {\n        print(a);\n        print(\" \");\n    }\n\n    public void println() throws Exception {\n        bw.write(\"\\n\");\n    }\n\n    public void println(Object a) throws Exception {\n        print(a);\n        println();\n    }\n\n    public void flush() throws Exception {\n        bw.flush();\n    }\n}\n"}
{"id": "Java/160", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder s, t;\n        s = new StringBuilder(sc.next());\n        t = new StringBuilder(sc.next());\n        boolean flag = false;\n        for (int i = 0; i < s.length(); i++) {\n            s = new StringBuilder(Rotate(s));\n            if (t.toString().equals(s.toString())) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag == true) System.out.println(\"Yes\");\n        else System.out.println(\"No\");\n    }\n\n    public static StringBuilder Rotate(StringBuilder str) {\n        int len = str.length();\n        char t = str.charAt(0);\n        for (int i = 0; i < len - 1; i++) {\n            str.setCharAt(i, str.charAt(i + 1));\n        }\n        str.setCharAt(len - 1, t);\n        return str;\n    }\n}\n", "test_IO": {"input": ["kyoto\ntokyo\n"], "output": ["Yes\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder s, t;\n        s = new StringBuilder(sc.next());\n        t = new StringBuilder(sc.next());\n        boolean flag = false;\n        for (int i = 0; i < s.length(); i++) {\n            s = new StringBuilder(Rotate(s));\n            if (t.toString() .equals(s.toString())) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag == true) System.out.println(\"Yes\");\n        else System.out.println(\"No\");\n    }\n\n    public static StringBuilder Rotate(StringBuilder str) {\n        int len = str.length();\n        char t = str.charAt(0);\n        for (int i = 0; i < len - 1; i++) {\n            str.setCharAt(i, str.charAt(i + 1));\n        }\n        str.setCharAt(len - 1, t);\n        return str;\n    }\n}\n"}
{"id": "Java/161", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class Graph0n {\n        private ArrayList<Node0n> dt = new ArrayList<>();\n\n        Graph0n(int sz) {\n            for (int i = 0; i < sz; i++) {\n                Node0n node1 = new Node0n();\n                dt.add(node1);\n            }\n        }\n\n        public void add(int vn, int val) {\n            dt.get(vn).add(val);\n        }\n\n        public void add2(int vn, int val) {\n            dt.get(vn).add(val);\n            dt.get(val).add(vn);\n        }\n\n        public int get(int vn, int index) {\n            return dt.get(vn).get(index);\n        }\n\n        public ArrayList<Integer> get(int vn) {\n            return dt.get(vn).getAll();\n        }\n\n        public int sizeOf(int vn) {\n            return dt.get(vn).size();\n        }\n\n        public void clear() {\n            for (int i = 0; i < dt.size(); i++) {\n                dt.get(i).clear();\n            }\n        }\n    }\n\n    static class Node0n {\n        private ArrayList<Integer> next_vs = new ArrayList<>();\n\n        public void add(int val) {\n            next_vs.add(val);\n        }\n\n        public int get(int ad) {\n            return next_vs.get(ad);\n        }\n\n        public ArrayList<Integer> getAll() {\n            return next_vs;\n        }\n\n        public int size() {\n            return next_vs.size();\n        }\n\n        public void clear() {\n            next_vs.clear();\n        }\n    }\n\n    static class Edge {\n        int from = -1, v2 = -1;\n        long weight;\n\n        public Edge(int vn, long w) {\n            this.v2 = vn;\n            this.weight = w;\n        }\n\n        public Edge(int cm, int vn, long w) {\n            this.from = cm;\n            this.v2 = vn;\n            this.weight = w;\n        }\n    }\n\n    static class Edge2 {\n        int v2;\n        long cost1, cost2;\n\n        public Edge2(int vn, long w1, long w2) {\n            this.v2 = vn;\n            this.cost1 = w1;\n            this.cost2 = w2;\n        }\n    }\n\n    static class Comparator_Edge implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return b.v2 - a.v2;\n        }\n    }\n\n    static class V2Comp implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return -1;\n            else if (a.v2 < b.v2) return 1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class antiV2 implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return 1;\n            else if (a.v2 < b.v2) return -1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class Vector {\n        int x, y;\n\n        public Vector(int sx, int sy) {\n            this.x = sx;\n            this.y = sy;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nexI();\n        String s = sc.next();\n        boolean[] flaged = new boolean[n];\n        fill(flaged, false);\n\n        long pop1st = 0L;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                flaged[i] = true;\n                pop1st++;\n            }\n        }\n\n        long surp1 = 0;\n\n        for (int i = 0; i < n; i++) {\n            surp1 *= 2L;\n            if (flaged[i]) surp1++;\n            surp1 %= (pop1st + 1L);\n        }\n\n        long surp9 = 0L;\n        if (pop1st > 1) {\n            for (int i = 0; i < n; i++) {\n                surp9 *= 2L;\n                if (flaged[i]) surp9++;\n                surp9 %= (pop1st - 1L);\n            }\n        }\n\n        for (int p = 0; p < n; p++) {\n            if (flaged[p]) {\n                if (pop1st == 1) {\n                    out.println(0);\n                    continue;\n                }\n                long dw = surp9;\n\n                long dif = pow10E97(2, n - p - 1, pop1st - 1);\n                dw -= dif;\n                dw += (pop1st - 1L);\n                dw %= (pop1st - 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            } else {\n                long dw = surp1;\n\n                long dif = pow10E97(2, n - p - 1, pop1st + 1);\n                dw += dif;\n                dw %= (pop1st + 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            }\n        }\n\n        out.flush();\n    }\n\n    private static int INF = (int) 1e8;\n    private static long INFL = (long) 1e17;\n    private static long e97 = (long) 1e9 + 7;\n\n    void assertion(boolean b) {\n        if (!b) throw new AssertionError();\n    }\n\n    private static int abs(int a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static long abs(long a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static double abs(double a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static int min(int a, int b) {\n        return (a > b) ? b : a;\n    }\n\n    private static long min(long a, long b) {\n        return (a > b) ? b : a;\n    }\n\n    private static double min(double a, double b) {\n        return (a > b) ? b : a;\n    }\n\n    private static int max(int a, int b) {\n        return (a > b) ? a : b;\n    }\n\n    private static long max(long a, long b) {\n        return (a > b) ? a : b;\n    }\n\n    private static double max(double a, double b) {\n        return (a > b) ? a : b;\n    }\n\n    private static int minN(int... ins) {\n        int min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static int maxN(int... ins) {\n        int max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static long minN(long... ins) {\n        long min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static long maxN(long... ins) {\n        long max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static int minExAd(int[] dt, int ad) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExAd(long[] dt, int ad) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int minExVal(int[] dt, int ex_val) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExVal(long[] dt, long ex_val) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int maxExAd(int[] dt, int ad) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExAd(long[] dt, int ad) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int maxExVal(int[] dt, int ex_val) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExVal(long[] dt, long ex_val) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int sumA(int[] dt) {\n        int sum = 0;\n        for (int e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static long sumA(long[] dt) {\n        long sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static int sumA(List<Integer> dt) {\n        int sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static boolean same3(long a, long b, long c) {\n        if (a != b) return false;\n        if (b != c) return false;\n        if (c != a) return false;\n        return true;\n    }\n\n    private static boolean dif3(long a, long b, long c) {\n        if (a == b) return false;\n        if (b == c) return false;\n        if (c == a) return false;\n        return true;\n    }\n\n    private static boolean triangle_inequality(int a, int b, int c) {\n        if ((a + b) < c) return false;\n        if ((b + c) < a) return false;\n        if ((c + a) < b) return false;\n        return true;\n    }\n\n    private static double hypod(double a, double b) {\n        return Math.sqrt(a * a + b * b);\n    }\n\n    private static long factorial(int n) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n        }\n        return ans;\n    }\n\n    private static long facP(int n, long p) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n            ans %= p;\n        }\n        return ans;\n    }\n\n    private static long lcm(long m, long n) {\n        long ans = m / gcd(m, n);\n        ans *= n;\n        return ans;\n    }\n\n    private static long gcd(long m, long n) {\n        if (m < n) return gcd(n, m);\n        if (n == 0) return m;\n        return gcd(n, m % n);\n    }\n\n    private static boolean is_prime(long a) {\n        if (a == 1) return false;\n        for (long i = 2L; i <= Math.sqrt(a); i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    private static long modinv(long a, long p) {\n        long b = p, u = 1L, v = 0L;\n        while (b > 0) {\n            long t = a / b;\n            long pe = a % b;\n            a = b;\n            b = pe;\n            pe = u - t * v;\n            u = v;\n            v = pe;\n        }\n        u %= p;\n        if (u < 0) u += p;\n        return u;\n    }\n\n    private static int pow(int n, int k) {\n        int ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static long pow(long n, int k) {\n        long ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static int pow2(int in) {\n        return in * in;\n    }\n\n    private static long pow2(long in) {\n        return in * in;\n    }\n\n    private static double pow2(double in) {\n        return in * in;\n    }\n\n    private static int getDigit2(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf = (1L << d);\n        }\n\n        return d;\n    }\n\n    private static int getDigit10(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf *= 10;\n        }\n        return d;\n    }\n\n    private static boolean isINF(int in) {\n        if (((long) in * 20) > INF) return true;\n        else return false;\n    }\n\n    private static boolean isINFL(long in) {\n        if ((in * 10000) > INFL) return true;\n        else return false;\n    }\n\n    private static long pow10E97(long ob, long soeji, long p) {\n        if (ob == 0) return 0;\n        if (soeji == 0) return 1;\n        if (soeji == 2) return (ob * ob) % p;\n\n        int d = getDigit2(soeji);\n        long[] ob_pow_2pow = new long[d];\n\n        ob_pow_2pow[0] = ob;\n        for (int i = 1; i < d; i++) {\n            ob_pow_2pow[i] = (ob_pow_2pow[i - 1] * ob_pow_2pow[i - 1]) % p;\n        }\n\n        long ans = 1;\n        for (int i = d - 1; i >= 0; i--) {\n            if (soeji >= (long) (1 << i)) {\n                soeji -= (long) (1 << i);\n                ans = (ans * ob_pow_2pow[i]) % p;\n            }\n        }\n        return ans % p;\n    }\n\n    private static long flag(long pos) {\n        return (1L << pos);\n    }\n\n    private static boolean isFlaged(int bit, int pos) {\n        if ((bit & (1 << pos)) > 0) return true;\n        else return false;\n    }\n\n    private static boolean isFlaged(long bit, int pos) {\n        if ((bit & (1L << pos)) > 0) return true;\n        else return false;\n    }\n\n    private static int deflag(int bit, int pos) {\n        return bit & ~(1 << pos);\n    }\n\n    private static int countFlaged(int bit) {\n        int ans = 0;\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1 << i)) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static int countFlaged(long bit) {\n        int ans = 0;\n        for (long i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1L << i)) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static void showflag(int bit) {\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if (isFlaged(bit, i)) System.out.print(\"O\");\n            else System.out.print(\".\");\n        }\n        System.out.println();\n    }\n\n    public static int biSearch(int[] dt, int target) {\n        int left = 0, right = dt.length - 1;\n        int mid = -1;\n        while (left <= right) {\n            mid = (right + left) / 2;\n            if (dt[mid] == target) return mid;\n            if (dt[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return -1;\n    }\n\n    public static int biSearchMax(long[] dt, long target) {\n        int left = -1, right = dt.length;\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt[mid] <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    public static int biSearchMaxAL(ArrayList<Integer> dt, long target) {\n        int left = -1, right = dt.size();\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt.get(mid) <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    private static void fill_parent(int[] ob) {\n        for (int i = 0; i < ob.length; i++) ob[i] = i;\n    }\n\n    private static int get_root_uf(int[] parent, int index) {\n        if (parent[index] == index) return index;\n        int root = get_root_uf(parent, parent[index]);\n        parent[index] = root;\n        return root;\n    }\n\n    private static boolean is_same_uf(int[] parent, int x, int y) {\n        if (get_root_uf(parent, x) == get_root_uf(parent, y)) return true;\n        else return false;\n    }\n\n    private static void unite_uf(int[] parent, int receiver, int attacker) {\n        parent[get_root_uf(parent, attacker)] = get_root_uf(parent, receiver);\n    }\n\n    private static int[] Xdir4 = {1, 0, 0, -1};\n    private static int[] Ydir4 = {0, 1, -1, 0};\n\n    private static int[] Xdir8 = {1, 1, 1, 0, 0, -1, -1, -1};\n    private static int[] Ydir8 = {1, 0, -1, 1, -1, 1, 0, -1};\n\n    private static boolean is_in_area(int y, int x, int h, int w) {\n        if (y < 0) return false;\n        if (x < 0) return false;\n        if (y >= h) return false;\n        if (x >= w) return false;\n        return true;\n    }\n\n    static void show2(boolean[][] dt, int lit_x, int lit_y) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int j = 0; j < dt.length; j++) {\n            for (int i = 0; i < dt[j].length; i++) {\n                if ((i == lit_y) && (j == lit_x)) out.print(\"X\");\n                else if (dt[j][i]) out.print(\"O\");\n                else out.print(\".\");\n            }\n            out.println();\n        }\n        out.flush();\n    }\n\n    static void show2(int[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void show2(long[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void disp_que(ArrayDeque<Long> dt) {\n        long a = 0;\n        while (dt.size() > 0) {\n            a = dt.removeFirst();\n            System.out.print(a);\n        }\n        System.out.println(\"\\n\");\n    }\n\n    static void disp_list(List dt) {\n        for (int i = 0; i < dt.size(); i++) {\n            System.out.print(dt.get(i) + \",\");\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void prtlnas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtlnas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtspas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(List as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as.get(0));\n        for (int i = 1; i < as.size(); i++) {\n            out.print(\" \" + as.get(i));\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void fill(boolean[] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(int[] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(long[] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(char[] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(double[] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(boolean[][] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(long[][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(char[][] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(double[][] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    private static void fill(long[][][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nexL() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b) || b == ':') {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nexI() {\n            long nl = nexL();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nexD() {\n            return Double.parseDouble(next());\n        }\n\n        public void ni(long[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(long[] as, long[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexL();\n                bs[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs, int[] cs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n                cs[i] = nexI();\n            }\n            return;\n        }\n\n        public void nisan(int[][] as) {\n            for (int i = 0; i < as.length; i++) {\n                for (int j = 0; j < as[0].length; j++) {\n                    as[i][j] = nexI();\n                }\n            }\n            return;\n        }\n    }\n}\n", "test_IO": {"input": ["3\n011\n"], "output": ["2\n1\n1\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class Graph0n {\n        private ArrayList<Node0n> dt = new ArrayList<>();\n\n        Graph0n(int sz) {\n            for (int i = 0; i < sz; i++) {\n                Node0n node1 = new Node0n();\n                dt.add(node1);\n            }\n        }\n\n        public void add(int vn, int val) {\n            dt.get(vn) .add(val);\n        }\n\n        public void add2(int vn, int val) {\n            dt.get(vn) .add(val);\n            dt.get(val) .add(vn);\n        }\n\n        public int get(int vn, int index) {\n            return dt.get(vn) .get(index);\n        }\n\n        public ArrayList<Integer> get(int vn) {\n            return dt.get(vn) .getAll();\n        }\n\n        public int sizeOf(int vn) {\n            return dt.get(vn) .size();\n        }\n\n        public void clear() {\n            for (int i = 0; i < dt.size(); i++) {\n                dt.get(i) .clear();\n            }\n        }\n    }\n\n    static class Node0n {\n        private ArrayList<Integer> next_vs = new ArrayList<>();\n\n        public void add(int val) {\n            next_vs.add(val);\n        }\n\n        public int get(int ad) {\n            return next_vs.get(ad);\n        }\n\n        public ArrayList<Integer> getAll() {\n            return next_vs;\n        }\n\n        public int size() {\n            return next_vs.size();\n        }\n\n        public void clear() {\n            next_vs.clear();\n        }\n    }\n\n    static class Edge {\n        int from = -1, v2 = -1;\n        long weight;\n\n        public Edge(int vn, long w) {\n            this.v2 = vn;\n            this.weight = w;\n        }\n\n        public Edge(int cm, int vn, long w) {\n            this.from = cm;\n            this.v2 = vn;\n            this.weight = w;\n        }\n    }\n\n    static class Edge2 {\n        int v2;\n        long cost1, cost2;\n\n        public Edge2(int vn, long w1, long w2) {\n            this.v2 = vn;\n            this.cost1 = w1;\n            this.cost2 = w2;\n        }\n    }\n\n    static class Comparator_Edge implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return b.v2 - a.v2;\n        }\n    }\n\n    static class V2Comp implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return -1;\n            else if (a.v2 < b.v2) return 1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class antiV2 implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return 1;\n            else if (a.v2 < b.v2) return -1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class Vector {\n        int x, y;\n\n        public Vector(int sx, int sy) {\n            this.x = sx;\n            this.y = sy;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nexI();\n        String s = sc.next();\n        boolean[] flaged = new boolean[n];\n        fill(flaged, false);\n\n        long pop1st = 0L;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                flaged[i] = true;\n                pop1st++;\n            }\n        }\n\n        long surp1 = 0;\n\n        for (int i = 0; i < n; i++) {\n            surp1 *= 2L;\n            if (flaged[i]) surp1++;\n            surp1 %= (pop1st + 1L);\n        }\n\n        long surp9 = 0L;\n        if (pop1st > 1) {\n            for (int i = 0; i < n; i++) {\n                surp9 *= 2L;\n                if (flaged[i]) surp9++;\n                surp9 %= (pop1st - 1L);\n            }\n        }\n\n        for (int p = 0; p < n; p++) {\n            if (flaged[p]) {\n                if (pop1st == 1) {\n                    out.println(0);\n                    continue;\n                }\n                long dw = surp9;\n\n                long dif = pow10E97(2, n - p - 1, pop1st - 1);\n                dw -= dif;\n                dw += (pop1st - 1L);\n                dw %= (pop1st - 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            } else {\n                long dw = surp1;\n\n                long dif = pow10E97(2, n - p - 1, pop1st + 1);\n                dw += dif;\n                dw %= (pop1st + 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            }\n        }\n\n        out.flush();\n    }\n\n    private static int INF = (int) 1e8;\n    private static long INFL = (long) 1e17;\n    private static long e97 = (long) 1e9 + 7;\n\n    void assertion(boolean b) {\n        if (!b) throw new AssertionError();\n    }\n\n    private static int abs(int a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static long abs(long a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static double abs(double a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static int min(int a, int b) {\n        return (a > b) ? b : a;\n    }\n\n    private static long min(long a, long b) {\n        return (a > b) ? b : a;\n    }\n\n    private static double min(double a, double b) {\n        return (a > b) ? b : a;\n    }\n\n    private static int max(int a, int b) {\n        return (a > b) ? a : b;\n    }\n\n    private static long max(long a, long b) {\n        return (a > b) ? a : b;\n    }\n\n    private static double max(double a, double b) {\n        return (a > b) ? a : b;\n    }\n\n    private static int minN(int... ins) {\n        int min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static int maxN(int... ins) {\n        int max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static long minN(long... ins) {\n        long min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static long maxN(long... ins) {\n        long max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static int minExAd(int[] dt, int ad) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExAd(long[] dt, int ad) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int minExVal(int[] dt, int ex_val) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExVal(long[] dt, long ex_val) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int maxExAd(int[] dt, int ad) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExAd(long[] dt, int ad) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int maxExVal(int[] dt, int ex_val) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExVal(long[] dt, long ex_val) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int sumA(int[] dt) {\n        int sum = 0;\n        for (int e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static long sumA(long[] dt) {\n        long sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static int sumA(List<Integer> dt) {\n        int sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static boolean same3(long a, long b, long c) {\n        if (a != b) return false;\n        if (b != c) return false;\n        if (c != a) return false;\n        return true;\n    }\n\n    private static boolean dif3(long a, long b, long c) {\n        if (a == b) return false;\n        if (b == c) return false;\n        if (c == a) return false;\n        return true;\n    }\n\n    private static boolean triangle_inequality(int a, int b, int c) {\n        if ((a + b) < c) return false;\n        if ((b + c) < a) return false;\n        if ((c + a) < b) return false;\n        return true;\n    }\n\n    private static double hypod(double a, double b) {\n        return Math.sqrt(a * a + b * b);\n    }\n\n    private static long factorial(int n) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n        }\n        return ans;\n    }\n\n    private static long facP(int n, long p) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n            ans %= p;\n        }\n        return ans;\n    }\n\n    private static long lcm(long m, long n) {\n        long ans = m / gcd(m, n);\n        ans *= n;\n        return ans;\n    }\n\n    private static long gcd(long m, long n) {\n        if (m < n) return gcd(n, m);\n        if (n == 0) return m;\n        return gcd(n, m % n);\n    }\n\n    private static boolean is_prime(long a) {\n        if (a == 1) return false;\n        for (long i = 2L; i <= Math.sqrt(a); i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    private static long modinv(long a, long p) {\n        long b = p, u = 1L, v = 0L;\n        while (b > 0) {\n            long t = a / b;\n            long pe = a % b;\n            a = b;\n            b = pe;\n            pe = u - t * v;\n            u = v;\n            v = pe;\n        }\n        u %= p;\n        if (u < 0) u += p;\n        return u;\n    }\n\n    private static int pow(int n, int k) {\n        int ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static long pow(long n, int k) {\n        long ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static int pow2(int in) {\n        return in * in;\n    }\n\n    private static long pow2(long in) {\n        return in * in;\n    }\n\n    private static double pow2(double in) {\n        return in * in;\n    }\n\n    private static int getDigit2(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf = (1L << d);\n        }\n\n        return d;\n    }\n\n    private static int getDigit10(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf *= 10;\n        }\n        return d;\n    }\n\n    private static boolean isINF(int in) {\n        if (((long) in * 20) > INF) return true;\n        else return false;\n    }\n\n    private static boolean isINFL(long in) {\n        if ((in * 10000) > INFL) return true;\n        else return false;\n    }\n\n    private static long pow10E97(long ob, long soeji, long p) {\n        if (ob == 0) return 0;\n        if (soeji == 0) return 1;\n        if (soeji == 2) return (ob * ob) % p;\n\n        int d = getDigit2(soeji);\n        long[] ob_pow_2pow = new long[d];\n\n        ob_pow_2pow[0] = ob;\n        for (int i = 1; i < d; i++) {\n            ob_pow_2pow[i] = (ob_pow_2pow[i - 1] * ob_pow_2pow[i - 1]) % p;\n        }\n\n        long ans = 1;\n        for (int i = d - 1; i >= 0; i--) {\n            if (soeji >= (long) (1 << i)) {\n                soeji -= (long) (1 << i);\n                ans = (ans * ob_pow_2pow[i]) % p;\n            }\n        }\n        return ans % p;\n    }\n\n    private static long flag(long pos) {\n        return (1L << pos);\n    }\n\n    private static boolean isFlaged(int bit, int pos) {\n        if ((bit & (1 << pos)) > 0) return true;\n        else return false;\n    }\n\n    private static boolean isFlaged(long bit, int pos) {\n        if ((bit & (1L << pos)) > 0) return true;\n        else return false;\n    }\n\n    private static int deflag(int bit, int pos) {\n        return bit & ~(1 << pos);\n    }\n\n    private static int countFlaged(int bit) {\n        int ans = 0;\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1 << i)) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static int countFlaged(long bit) {\n        int ans = 0;\n        for (long i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1L << i)) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static void showflag(int bit) {\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if (isFlaged(bit, i)) System.out.print(\"O\");\n            else System.out.print(\".\");\n        }\n        System.out.println();\n    }\n\n    public static int biSearch(int[] dt, int target) {\n        int left = 0, right = dt.length - 1;\n        int mid = -1;\n        while (left <= right) {\n            mid = (right + left) / 2;\n            if (dt[mid] == target) return mid;\n            if (dt[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return -1;\n    }\n\n    public static int biSearchMax(long[] dt, long target) {\n        int left = -1, right = dt.length;\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt[mid] <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    public static int biSearchMaxAL(ArrayList<Integer> dt, long target) {\n        int left = -1, right = dt.size();\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt.get(mid) <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    private static void fill_parent(int[] ob) {\n        for (int i = 0; i < ob.length; i++) ob[i] = i;\n    }\n\n    private static int get_root_uf(int[] parent, int index) {\n        if (parent[index] == index) return index;\n        int root = get_root_uf(parent, parent[index]);\n        parent[index] = root;\n        return root;\n    }\n\n    private static boolean is_same_uf(int[] parent, int x, int y) {\n        if (get_root_uf(parent, x) == get_root_uf(parent, y)) return true;\n        else return false;\n    }\n\n    private static void unite_uf(int[] parent, int receiver, int attacker) {\n        parent[get_root_uf(parent, attacker)] = get_root_uf(parent, receiver);\n    }\n\n    private static int[] Xdir4 = {1, 0, 0, -1};\n    private static int[] Ydir4 = {0, 1, -1, 0};\n\n    private static int[] Xdir8 = {1, 1, 1, 0, 0, -1, -1, -1};\n    private static int[] Ydir8 = {1, 0, -1, 1, -1, 1, 0, -1};\n\n    private static boolean is_in_area(int y, int x, int h, int w) {\n        if (y < 0) return false;\n        if (x < 0) return false;\n        if (y >= h) return false;\n        if (x >= w) return false;\n        return true;\n    }\n\n    static void show2(boolean[][] dt, int lit_x, int lit_y) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int j = 0; j < dt.length; j++) {\n            for (int i = 0; i < dt[j].length; i++) {\n                if ((i == lit_y) && (j == lit_x)) out.print(\"X\");\n                else if (dt[j][i]) out.print(\"O\");\n                else out.print(\".\");\n            }\n            out.println();\n        }\n        out.flush();\n    }\n\n    static void show2(int[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void show2(long[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void disp_que(ArrayDeque<Long> dt) {\n        long a = 0;\n        while (dt.size() > 0) {\n            a = dt.removeFirst();\n            System.out.print(a);\n        }\n        System.out.println(\"\\n\");\n    }\n\n    static void disp_list(List dt) {\n        for (int i = 0; i < dt.size(); i++) {\n            System.out.print(dt.get(i) + \",\");\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void prtlnas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtlnas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtspas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(List as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as.get(0));\n        for (int i = 1; i < as.size(); i++) {\n            out.print(\" \" + as.get(i));\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void fill(boolean[] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(int[] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(long[] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(char[] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(double[] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(boolean[][] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(long[][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(char[][] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(double[][] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    private static void fill(long[][][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nexL() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b) || b == ':') {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nexI() {\n            long nl = nexL();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nexD() {\n            return Double.parseDouble(next());\n        }\n\n        public void ni(long[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(long[] as, long[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexL();\n                bs[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs, int[] cs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n                cs[i] = nexI();\n            }\n            return;\n        }\n\n        public void nisan(int[][] as) {\n            for (int i = 0; i < as.length; i++) {\n                for (int j = 0; j < as[0].length; j++) {\n                    as[i][j] = nexI();\n                }\n            }\n            return;\n        }\n    }\n}\n"}
{"id": "Java/164", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int N = Integer.parseInt(sc.next());\n        String s[] = new String[N];\n        int a_num = 0;\n        int b_num = 0;\n        boolean flag = true;\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            s[i] = sc.next();\n            if (s[i].substring(0, 1).equals(\"B\")) {\n                b_num++;\n            }\n            if (s[i].substring(s[i].length() - 1, s[i].length()).equals(\"A\")) {\n                a_num++;\n            }\n            if (s[i].substring(0, 1).equals(\"B\")\n                    || s[i].substring(s[i].length() - 1, s[i].length()).equals(\"A\")) {\n                if (!(s[i].substring(0, 1).equals(\"B\")\n                        && s[i].substring(s[i].length() - 1, s[i].length()).equals(\"A\"))) {\n                    flag = false;\n                }\n            }\n            for (int j = 0; j < s[i].length() - 1; j++) {\n                if (s[i].substring(j, j + 2).equals(\"AB\")) ans++;\n            }\n        }\n        ans += Math.min(a_num, b_num);\n        if (Math.min(a_num, b_num) != 0 && flag) {\n            ans--;\n        }\n        System.out.println(ans);\n    }\n}\n", "test_IO": {"input": ["3\nABCA\nXBAZ\nBAD\n"], "output": ["2\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int N = Integer.parseInt(sc.next());\n        String s[] = new String[N];\n        int a_num = 0;\n        int b_num = 0;\n        boolean flag = true;\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            s[i] = sc.next();\n            if (s[i].substring(0, 1) .equals(\"B\")) {\n                b_num++;\n            }\n            if (s[i].substring(s[i].length() - 1, s[i].length()) .equals(\"A\")) {\n                a_num++;\n            }\n            if (s[i].substring(0, 1) .equals(\"B\")\n                    || s[i].substring(s[i].length() - 1, s[i].length()) .equals(\"A\")) {\n                if (!(s[i].substring(0, 1) .equals(\"B\")\n                        && s[i].substring(s[i].length() - 1, s[i].length()) .equals(\"A\"))) {\n                    flag = false;\n                }\n            }\n            for (int j = 0; j < s[i].length() - 1; j++) {\n                if (s[i].substring(j, j + 2) .equals(\"AB\")) ans++;\n            }\n        }\n        ans += Math.min(a_num, b_num);\n        if (Math.min(a_num, b_num) != 0 && flag) {\n            ans--;\n        }\n        System.out.println(ans);\n    }\n}\n"}
{"id": "Java/167", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    String[][] colorMtr;\n    int h;\n    int w;\n    int k;\n\n    public static void main(String[] args) throws IOException {\n        SampleSolution mainObj = new SampleSolution();\n        mainObj.solve();\n    }\n\n    public void solve() throws IOException {\n        FastScanner fs = new FastScanner();\n\n        h = fs.nextInt();\n        w = fs.nextInt();\n        k = fs.nextInt();\n\n        colorMtr = new String[h][];\n        for (int i = 0; i < h; i++) {\n            colorMtr[i] = fs.next().split(\"\");\n        }\n\n        int hPattern = pow(2, h);\n        int wPattern = pow(2, w);\n\n        int ans = 0;\n\n        for (int i = 0; i < hPattern; i++) {\n            for (int j = 0; j < wPattern; j++) {\n                if (judge(i, j)) {\n                    ans++;\n                }\n            }\n        }\n\n        System.out.println(ans);\n    }\n\n    boolean judge(int hPattern, int wPattern) {\n\n        int[] hBitArr = new int[h];\n        int[] wBitArr = new int[w];\n\n        for (int i = 0; i < h; i++) {\n            if (((hPattern >> i) & 1) == 1) {\n                hBitArr[i] = 1;\n            }\n        }\n\n        for (int i = 0; i < w; i++) {\n            if (((wPattern >> i) & 1) == 1) {\n                wBitArr[i] = 1;\n            }\n        }\n\n        int black = 0;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (hBitArr[i] == 1 || wBitArr[j] == 1) {\n                    continue;\n                }\n\n                if (colorMtr[i][j].equals(\"#\")) {\n                    black++;\n                }\n            }\n        }\n\n        if (black == k) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public int pow(int base, int n) {\n        int retVal = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                retVal *= base;\n            }\n            n >>= 1;\n            base *= base;\n        }\n        return retVal;\n    }\n\n    public class FastScanner {\n\n        BufferedReader reader;\n        private StringTokenizer st;\n\n        public FastScanner() {\n            st = null;\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(reader.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            st = null;\n            String readLine = null;\n            readLine = reader.readLine();\n            return readLine;\n        }\n\n        public int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws NumberFormatException, IOException {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextIntArr(int n) throws NumberFormatException, IOException {\n            int[] retArr = new int[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextInt();\n            }\n            return retArr;\n        }\n\n        public long[] nextLongArr(int n) throws NumberFormatException, IOException {\n            long[] retArr = new long[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextLong();\n            }\n            return retArr;\n        }\n\n        public void close() throws IOException {\n            reader.close();\n        }\n    }\n}\n", "test_IO": {"input": ["2 3 2\n..#\n###\n"], "output": ["5\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    String[][] colorMtr;\n    int h;\n    int w;\n    int k;\n\n    public static void main(String[] args) throws IOException {\n        SampleSolution mainObj = new SampleSolution();\n        mainObj.solve();\n    }\n\n    public void solve() throws IOException {\n        FastScanner fs = new FastScanner();\n\n        h = fs.nextInt();\n        w = fs.nextInt();\n        k = fs.nextInt();\n\n        colorMtr = new String[h][];\n        for (int i = 0; i < h; i++) {\n            colorMtr[i] = fs.next() .split(\"\");\n        }\n\n        int hPattern = pow(2, h);\n        int wPattern = pow(2, w);\n\n        int ans = 0;\n\n        for (int i = 0; i < hPattern; i++) {\n            for (int j = 0; j < wPattern; j++) {\n                if (judge(i, j)) {\n                    ans++;\n                }\n            }\n        }\n\n        System.out.println(ans);\n    }\n\n    boolean judge(int hPattern, int wPattern) {\n\n        int[] hBitArr = new int[h];\n        int[] wBitArr = new int[w];\n\n        for (int i = 0; i < h; i++) {\n            if (((hPattern >> i) & 1) == 1) {\n                hBitArr[i] = 1;\n            }\n        }\n\n        for (int i = 0; i < w; i++) {\n            if (((wPattern >> i) & 1) == 1) {\n                wBitArr[i] = 1;\n            }\n        }\n\n        int black = 0;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (hBitArr[i] == 1 || wBitArr[j] == 1) {\n                    continue;\n                }\n\n                if (colorMtr[i][j].equals(\"#\")) {\n                    black++;\n                }\n            }\n        }\n\n        if (black == k) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public int pow(int base, int n) {\n        int retVal = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                retVal *= base;\n            }\n            n >>= 1;\n            base *= base;\n        }\n        return retVal;\n    }\n\n    public class FastScanner {\n\n        BufferedReader reader;\n        private StringTokenizer st;\n\n        public FastScanner() {\n            st = null;\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(reader.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            st = null;\n            String readLine = null;\n            readLine = reader.readLine();\n            return readLine;\n        }\n\n        public int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws NumberFormatException, IOException {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextIntArr(int n) throws NumberFormatException, IOException {\n            int[] retArr = new int[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextInt();\n            }\n            return retArr;\n        }\n\n        public long[] nextLongArr(int n) throws NumberFormatException, IOException {\n            long[] retArr = new long[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextLong();\n            }\n            return retArr;\n        }\n\n        public void close() throws IOException {\n            reader.close();\n        }\n    }\n}\n"}
{"id": "Java/168", "code": "import static java.lang.System.*;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\nclass SampleSolution {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand = new Random();\n\n    public void run() {\n        TCase:\n        while (true) {\n            int W = sc.nextInt(), H = sc.nextInt();\n            if (W == 0 && H == 0) return;\n            char[][] map = new char[H][W];\n\n            for (int h = 0; h < H; h++) {\n                map[h] = sc.next().toCharArray();\n            }\n\n            BigInteger[][] dp = new BigInteger[H][W];\n\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    BigInteger hprev = BigInteger.ZERO;\n                    if (h >= 1) {\n                        hprev = dp[h - 1][w];\n                    }\n                    BigInteger wprev = BigInteger.ZERO;\n                    if (w >= 1) {\n                        wprev = dp[h][w - 1];\n                    }\n                    if (Character.isDigit(map[h][w])) {\n                        BigInteger max;\n                        if (hprev.compareTo(wprev) > 0) {\n                            max = hprev;\n                        } else {\n                            max = wprev;\n                        }\n                        dp[h][w] = max.multiply(BigInteger.TEN).add(new BigInteger(map[h][w] + \"\"));\n                    } else {\n                        dp[h][w] = BigInteger.ZERO;\n                    }\n                }\n            BigInteger max = BigInteger.ZERO;\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    if (dp[h][w].compareTo(max) > 0) max = dp[h][w];\n                }\n            ln(max);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = sc.nextInt();\n        }\n        return res;\n    }\n\n    public static void pr(Object o) {\n        out.print(o);\n    }\n\n    public static void ln(Object o) {\n        out.println(o);\n    }\n\n    public static void ln() {\n        out.println();\n    }\n}\n", "test_IO": {"input": ["7 4\n9R2A993\n0E314A0\n8A900DE\n820R037\n6 7\nJH03HE\nID7722\n0DA1AH\n30C9G5\n99971A\nCA7EAI\nAHLBEM\n20 2\nA1234567891234CBDEGH\nBDEDF908034265091499\n0 0\n"], "output": ["23900037\n771971\n12345908034265091499\n"]}, "modified_context": "import static java.lang.System.*;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\nclass SampleSolution {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand = new Random();\n\n    public void run() {\n        TCase:\n        while (true) {\n            int W = sc.nextInt(), H = sc.nextInt();\n            if (W == 0 && H == 0) return;\n            char[][] map = new char[H][W];\n\n            for (int h = 0; h < H; h++) {\n                map[h] = sc.next() .toCharArray();\n            }\n\n            BigInteger[][] dp = new BigInteger[H][W];\n\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    BigInteger hprev = BigInteger.ZERO;\n                    if (h >= 1) {\n                        hprev = dp[h - 1][w];\n                    }\n                    BigInteger wprev = BigInteger.ZERO;\n                    if (w >= 1) {\n                        wprev = dp[h][w - 1];\n                    }\n                    if (Character.isDigit(map[h][w])) {\n                        BigInteger max;\n                        if (hprev.compareTo(wprev) > 0) {\n                            max = hprev;\n                        } else {\n                            max = wprev;\n                        }\n                        dp[h][w] = max.multiply(BigInteger.TEN) .add(new BigInteger(map[h][w] + \"\"));\n                    } else {\n                        dp[h][w] = BigInteger.ZERO;\n                    }\n                }\n            BigInteger max = BigInteger.ZERO;\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    if (dp[h][w].compareTo(max) > 0) max = dp[h][w];\n                }\n            ln(max);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution() .run();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = sc.nextInt();\n        }\n        return res;\n    }\n\n    public static void pr(Object o) {\n        out.print(o);\n    }\n\n    public static void ln(Object o) {\n        out.println(o);\n    }\n\n    public static void ln() {\n        out.println();\n    }\n}\n"}
{"id": "Java/169", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        try (Scanner sc = new Scanner(System.in); ) {\n            solve(sc);\n        }\n    }\n\n    public static void solve(Scanner sc) {\n        char[] a = sc.next().toCharArray();\n        if (a[0] == a[1] || a[1] == a[2] || a[2] == a[0]) {\n            System.out.println(\"No\");\n        } else {\n            System.out.println(\"Yes\");\n        }\n    }\n}\n", "test_IO": {"input": ["bac\n"], "output": ["Yes\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        try (Scanner sc = new Scanner(System.in); ) {\n            solve(sc);\n        }\n    }\n\n    public static void solve(Scanner sc) {\n        char[] a = sc.next() .toCharArray();\n        if (a[0] == a[1] || a[1] == a[2] || a[2] == a[0]) {\n            System.out.println(\"No\");\n        } else {\n            System.out.println(\"Yes\");\n        }\n    }\n}\n"}
{"id": "Java/172", "code": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static final long INF = Long.MAX_VALUE / 2;\n    static final int MOD = 1_000_000_007;\n    static final int SIZE = 1_000_000;\n    long[] fac = new long[SIZE];\n    long[] inv = new long[SIZE];\n    long[] finv = new long[SIZE];\n    FastScanner sc = new FastScanner();\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    void solve() {\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            int s = sc.nextInt();\n            int c = sc.nextInt();\n            if (map.get(s) != null && map.get(s) != c) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n            map.put(s, c);\n        }\n\n        for (int i = 0; i < 1000; i++) {\n            String s = \"\" + i;\n            boolean flag = true;\n            if (s.length() < n) continue;\n            for (int j = 0; j < n; j++) {\n                if ((map.get(j + 1) != null\n                                && map.get(j + 1) != Character.getNumericValue(s.charAt(j)))\n                        || (map.get(j + 1) == null\n                                && Character.getNumericValue(s.charAt(j)) != 0)) {\n                    if (map.get(j + 1) == null\n                            && j == 0\n                            && Character.getNumericValue(s.charAt(j)) == 1) {\n                        continue;\n                    }\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag && s.length() == n) {\n                System.out.println(s);\n                System.exit(0);\n            }\n        }\n\n        System.out.println(-1);\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    long inv(long a) {\n        return pow(a, MOD - 2);\n    }\n\n    long pow(long a, long r) {\n        long sum = 1;\n        while (r > 0) {\n            if ((r & 1) == 1) {\n                sum *= a;\n                sum %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            r >>= 1;\n        }\n        return sum;\n    }\n\n    long modFact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * modFact(n - 1) % MOD;\n    }\n\n    long fact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * fact(n - 1);\n    }\n\n    void initCOMB() {\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for (int i = 2; i < SIZE; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    long modComb(int n, int r) {\n        if (n < r || n < 0 || r < 0) return 0;\n        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;\n    }\n\n    long comb(long n, long r) {\n        long num = 1;\n        for (long i = 1; i <= r; i++) {\n            num = num * (n - i + 1) / i;\n        }\n        return num;\n    }\n\n    boolean isPrime(long a) {\n        if (a <= 1) return false;\n        for (int i = 2; i * i <= a; i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    String nextPermutation(String s) {\n        ArrayList<Character> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) list.add(s.charAt(i));\n\n        int pivotPos = -1;\n        char pivot = 0;\n        for (int i = list.size() - 2; i >= 0; i--) {\n            if (list.get(i) < list.get(i + 1)) {\n                pivotPos = i;\n                pivot = list.get(i);\n                break;\n            }\n        }\n\n        if (pivotPos == -1 && pivot == 0) return null;\n\n        int L = pivotPos + 1;\n        int R = list.size() - 1;\n        int minPos = -1;\n        char min = Character.MAX_VALUE;\n        for (int i = R; i >= L; i--) {\n            if (pivot < list.get(i)) {\n                if (list.get(i) < min) {\n                    min = list.get(i);\n                    minPos = i;\n                }\n            }\n        }\n\n        Collections.swap(list, pivotPos, minPos);\n        Collections.sort(list.subList(L, R + 1));\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i));\n\n        return sb.toString();\n    }\n\n    boolean nextPermutation(long[] a) {\n        for (int i = a.length - 1; i > 0; i--) {\n            if (a[i - 1] < a[i]) {\n                int swapIndex = find(a[i - 1], a, i, a.length - 1);\n                long temp = a[swapIndex];\n                a[swapIndex] = a[i - 1];\n                a[i - 1] = temp;\n                Arrays.sort(a, i, a.length);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int find(long dest, long[] a, int s, int e) {\n        if (s == e) {\n            return s;\n        }\n        int m = (s + e + 1) / 2;\n        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n    }\n\n    void elimination(int[][] a, int[] b) {\n        int n = a.length;\n        double f;\n        for (int k = 0; k < n - 1; k++) {\n            for (int i = k + 1; i < n; i++) {\n                f = -a[i][k] / a[k][k];\n                for (int j = k + 1; j < n; j++) {\n                    a[i][j] += f * a[k][j];\n                }\n                b[i] += f * b[k];\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i + 1; j < n; j++) {\n                    b[i] -= a[i][j] * b[j];\n                }\n                b[i] = b[i] / a[i][i];\n            }\n        }\n    }\n}\n\nclass Pair implements Comparable<Pair> {\n    long a, b;\n\n    public Pair(long i, long j) {\n        a = i;\n        b = j;\n    }\n\n    @Override\n    public int compareTo(Pair p) {\n        if (this.b < p.b) return -1;\n        else if (this.b > p.b) return 1;\n        else return 0;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "test_IO": {"input": ["3 3\n1 7\n3 2\n1 7\n"], "output": ["702\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static final long INF = Long.MAX_VALUE / 2;\n    static final int MOD = 1_000_000_007;\n    static final int SIZE = 1_000_000;\n    long[] fac = new long[SIZE];\n    long[] inv = new long[SIZE];\n    long[] finv = new long[SIZE];\n    FastScanner sc = new FastScanner();\n\n    public static void main(String[] args) {\n        new SampleSolution() .solve();\n    }\n\n    void solve() {\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            int s = sc.nextInt();\n            int c = sc.nextInt();\n            if (map.get(s) != null && map.get(s) != c) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n            map.put(s, c);\n        }\n\n        for (int i = 0; i < 1000; i++) {\n            String s = \"\" + i;\n            boolean flag = true;\n            if (s.length() < n) continue;\n            for (int j = 0; j < n; j++) {\n                if ((map.get(j + 1) != null\n                                && map.get(j + 1) != Character.getNumericValue(s.charAt(j)))\n                        || (map.get(j + 1) == null\n                                && Character.getNumericValue(s.charAt(j)) != 0)) {\n                    if (map.get(j + 1) == null\n                            && j == 0\n                            && Character.getNumericValue(s.charAt(j)) == 1) {\n                        continue;\n                    }\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag && s.length() == n) {\n                System.out.println(s);\n                System.exit(0);\n            }\n        }\n\n        System.out.println(-1);\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    long inv(long a) {\n        return pow(a, MOD - 2);\n    }\n\n    long pow(long a, long r) {\n        long sum = 1;\n        while (r > 0) {\n            if ((r & 1) == 1) {\n                sum *= a;\n                sum %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            r >>= 1;\n        }\n        return sum;\n    }\n\n    long modFact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * modFact(n - 1) % MOD;\n    }\n\n    long fact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * fact(n - 1);\n    }\n\n    void initCOMB() {\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for (int i = 2; i < SIZE; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    long modComb(int n, int r) {\n        if (n < r || n < 0 || r < 0) return 0;\n        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;\n    }\n\n    long comb(long n, long r) {\n        long num = 1;\n        for (long i = 1; i <= r; i++) {\n            num = num * (n - i + 1) / i;\n        }\n        return num;\n    }\n\n    boolean isPrime(long a) {\n        if (a <= 1) return false;\n        for (int i = 2; i * i <= a; i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    String nextPermutation(String s) {\n        ArrayList<Character> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) list.add(s.charAt(i));\n\n        int pivotPos = -1;\n        char pivot = 0;\n        for (int i = list.size() - 2; i >= 0; i--) {\n            if (list.get(i) < list.get(i + 1)) {\n                pivotPos = i;\n                pivot = list.get(i);\n                break;\n            }\n        }\n\n        if (pivotPos == -1 && pivot == 0) return null;\n\n        int L = pivotPos + 1;\n        int R = list.size() - 1;\n        int minPos = -1;\n        char min = Character.MAX_VALUE;\n        for (int i = R; i >= L; i--) {\n            if (pivot < list.get(i)) {\n                if (list.get(i) < min) {\n                    min = list.get(i);\n                    minPos = i;\n                }\n            }\n        }\n\n        Collections.swap(list, pivotPos, minPos);\n        Collections.sort(list.subList(L, R + 1));\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i));\n\n        return sb.toString();\n    }\n\n    boolean nextPermutation(long[] a) {\n        for (int i = a.length - 1; i > 0; i--) {\n            if (a[i - 1] < a[i]) {\n                int swapIndex = find(a[i - 1], a, i, a.length - 1);\n                long temp = a[swapIndex];\n                a[swapIndex] = a[i - 1];\n                a[i - 1] = temp;\n                Arrays.sort(a, i, a.length);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int find(long dest, long[] a, int s, int e) {\n        if (s == e) {\n            return s;\n        }\n        int m = (s + e + 1) / 2;\n        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n    }\n\n    void elimination(int[][] a, int[] b) {\n        int n = a.length;\n        double f;\n        for (int k = 0; k < n - 1; k++) {\n            for (int i = k + 1; i < n; i++) {\n                f = -a[i][k] / a[k][k];\n                for (int j = k + 1; j < n; j++) {\n                    a[i][j] += f * a[k][j];\n                }\n                b[i] += f * b[k];\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i + 1; j < n; j++) {\n                    b[i] -= a[i][j] * b[j];\n                }\n                b[i] = b[i] / a[i][i];\n            }\n        }\n    }\n}\n\nclass Pair implements Comparable<Pair> {\n    long a, b;\n\n    public Pair(long i, long j) {\n        a = i;\n        b = j;\n    }\n\n    @Override\n    public int compareTo(Pair p) {\n        if (this.b < p.b) return -1;\n        else if (this.b > p.b) return 1;\n        else return 0;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n"}
{"id": "Java/182", "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        String[] s = parseLine().split(\" \");\n        int a = Integer.parseInt(s[0]);\n        int b = Integer.parseInt(s[1]);\n        if (b % a == 0) {\n            System.out.println(a + b);\n        } else {\n            System.out.println(b - a);\n        }\n        return;\n    }\n\n    private static String parseLine() {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            return reader.readLine();\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n}\n", "test_IO": {"input": ["4 12\n"], "output": ["16\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        String[] s = parseLine() .split(\" \");\n        int a = Integer.parseInt(s[0]);\n        int b = Integer.parseInt(s[1]);\n        if (b % a == 0) {\n            System.out.println(a + b);\n        } else {\n            System.out.println(b - a);\n        }\n        return;\n    }\n\n    private static String parseLine() {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            return reader.readLine();\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n}\n"}
{"id": "Java/183", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        char[] s = scanner.next().toCharArray(), t = scanner.next().toCharArray();\n        boolean check = false;\n        for (int i = s.length - t.length; i >= 0; i--) {\n            boolean check2 = true;\n            for (int j = 0; j < t.length; j++) {\n                if (s[i + j] != '?' && s[i + j] != t[j]) {\n                    check2 = false;\n                }\n            }\n            if (check2) {\n                check = true;\n                for (int j = 0; j < t.length; j++) {\n                    s[i + j] = t[j];\n                }\n            }\n            if (check) {\n                break;\n            }\n        }\n        if (check) {\n            for (int i = 0; i < s.length; i++) {\n                if (s[i] == '?') {\n                    System.out.print(\"a\");\n                } else {\n                    System.out.print(s[i]);\n                }\n            }\n            System.out.println();\n        } else {\n            System.out.println(\"UNRESTORABLE\");\n        }\n    }\n}\n", "test_IO": {"input": ["?tc????\ncoder\n"], "output": ["atcoder\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        char[] s = scanner.next() .toCharArray(), t = scanner.next() .toCharArray();\n        boolean check = false;\n        for (int i = s.length - t.length; i >= 0; i--) {\n            boolean check2 = true;\n            for (int j = 0; j < t.length; j++) {\n                if (s[i + j] != '?' && s[i + j] != t[j]) {\n                    check2 = false;\n                }\n            }\n            if (check2) {\n                check = true;\n                for (int j = 0; j < t.length; j++) {\n                    s[i + j] = t[j];\n                }\n            }\n            if (check) {\n                break;\n            }\n        }\n        if (check) {\n            for (int i = 0; i < s.length; i++) {\n                if (s[i] == '?') {\n                    System.out.print(\"a\");\n                } else {\n                    System.out.print(s[i]);\n                }\n            }\n            System.out.println();\n        } else {\n            System.out.println(\"UNRESTORABLE\");\n        }\n    }\n}\n"}
{"id": "Java/190", "code": "import java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String sa = sc.next();\n        String sb = sc.next();\n        BigDecimal A = new BigDecimal(sa);\n        BigDecimal B = new BigDecimal(sb);\n        System.out.println(A.multiply(B).setScale(0, BigDecimal.ROUND_DOWN));\n    }\n}\n", "test_IO": {"input": ["198 1.10\n"], "output": ["217\n"]}, "modified_context": "import java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String sa = sc.next();\n        String sb = sc.next();\n        BigDecimal A = new BigDecimal(sa);\n        BigDecimal B = new BigDecimal(sb);\n        System.out.println(A.multiply(B) .setScale(0, BigDecimal.ROUND_DOWN));\n    }\n}\n"}
{"id": "Java/198", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public SampleSolution(FastScanner in, PrintWriter out, int test) {\n        int N = in.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) A[i] = in.nextInt();\n        Arrays.sort(A);\n\n        long res = 0;\n\n        PriorityQueue<int[]> q =\n                new PriorityQueue<>(\n                        Comparator.comparingInt((int[] e) -> Math.min(e[0], e[1])).reversed());\n        q.add(new int[] {A[N - 1], A[N - 1]});\n\n        for (int i = N - 2; i >= 0; i--) {\n            int a = A[i];\n            int[] place = q.remove();\n            res += Math.min(place[0], place[1]);\n            q.add(new int[] {place[0], a});\n            q.add(new int[] {a, place[1]});\n        }\n        out.println(res);\n    }\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        FastScanner in = new FastScanner(System.in);\n\n        for (int t = 1; t <= 1; t++) {\n            SampleSolution sol = new SampleSolution(in, out, t);\n        }\n\n        out.close();\n    }\n}\n\nclass FastScanner {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public FastScanner(InputStream stream) {\n        this.stream = stream;\n    }\n\n    int read() {\n        if (numChars == -1) throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) return -1;\n        }\n        return buf[curChar++];\n    }\n\n    boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    boolean isEndline(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String next() {\n        int c = read();\n        while (isSpaceChar(c)) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    String nextLine() {\n        int c = read();\n        while (isEndline(c)) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndline(c));\n        return res.toString();\n    }\n}\n", "test_IO": {"input": ["4\n2 2 1 3\n"], "output": ["7\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public SampleSolution(FastScanner in, PrintWriter out, int test) {\n        int N = in.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) A[i] = in.nextInt();\n        Arrays.sort(A);\n\n        long res = 0;\n\n        PriorityQueue<int[]> q =\n                new PriorityQueue<>(\n                        Comparator.comparingInt((int[] e) -> Math.min(e[0], e[1])) .reversed());\n        q.add(new int[] {A[N - 1], A[N - 1]});\n\n        for (int i = N - 2; i >= 0; i--) {\n            int a = A[i];\n            int[] place = q.remove();\n            res += Math.min(place[0], place[1]);\n            q.add(new int[] {place[0], a});\n            q.add(new int[] {a, place[1]});\n        }\n        out.println(res);\n    }\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        FastScanner in = new FastScanner(System.in);\n\n        for (int t = 1; t <= 1; t++) {\n            SampleSolution sol = new SampleSolution(in, out, t);\n        }\n\n        out.close();\n    }\n}\n\nclass FastScanner {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public FastScanner(InputStream stream) {\n        this.stream = stream;\n    }\n\n    int read() {\n        if (numChars == -1) throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) return -1;\n        }\n        return buf[curChar++];\n    }\n\n    boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    boolean isEndline(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String next() {\n        int c = read();\n        while (isSpaceChar(c)) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    String nextLine() {\n        int c = read();\n        while (isEndline(c)) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndline(c));\n        return res.toString();\n    }\n}\n"}
{"id": "Java/199", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n\n        String str[] = br.readLine().split(\" \");\n\n        int s[] = new int[100010];\n\n        for (int i = 0; i < n; i++) {\n            s[Integer.parseInt(str[i])]++;\n        }\n\n        int dec = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] != 0) {\n                if (s[i] % 2 == 0) {\n                    s[i] = 2;\n                } else {\n                    s[i] = 1;\n                }\n            }\n        }\n\n        int one = 0;\n        int two = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == 2) {\n                two++;\n            } else if (s[i] == 1) {\n                one++;\n            }\n        }\n\n        if (two % 2 != 0) {\n            one--;\n        }\n\n        System.out.println(two + one);\n    }\n}\n", "test_IO": {"input": ["5\n1 2 1 3 7\n"], "output": ["3\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n\n        String str[] = br.readLine() .split(\" \");\n\n        int s[] = new int[100010];\n\n        for (int i = 0; i < n; i++) {\n            s[Integer.parseInt(str[i])]++;\n        }\n\n        int dec = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] != 0) {\n                if (s[i] % 2 == 0) {\n                    s[i] = 2;\n                } else {\n                    s[i] = 1;\n                }\n            }\n        }\n\n        int one = 0;\n        int two = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == 2) {\n                two++;\n            } else if (s[i] == 1) {\n                one++;\n            }\n        }\n\n        if (two % 2 != 0) {\n            one--;\n        }\n\n        System.out.println(two + one);\n    }\n}\n"}
