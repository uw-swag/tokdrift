{"id": "Java/1", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int n = fs.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = fs.nextInt();\n        }\n        Arrays.sort(a);\n        long sum = 0;\n        int count = 0;\n        for (int i = 0; i < n - 1; i++) {\n            sum += a[i];\n            if (a[i + 1] <= 2 * sum) {\n                count++;\n            } else {\n                count = 0;\n            }\n        }\n        System.out.println(count + 1);\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "test_IO": {"input": ["3\n3 1 4\n"], "output": ["2\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int n = fs.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = fs.nextInt();\n        }\n        Arrays.sort(a);\n        long sum = 0;\n        int count = 0;\n        for (int i = 0; i < n - 1; i++) {\n            sum += a[i];\n            if (a[i + 1] <= 2 * sum) {\n                count++;\n            } else {\n                count = 0;\n            }\n        }\n        System.out.println(count + 1);\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte() ) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b) ) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b) ) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n    }\n}\n"}
{"id": "Java/2", "code": "import java.math.*;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        BigInteger a, b, c;\n        Scanner cin = new Scanner(System.in);\n        while (cin.hasNext()) {\n            a = cin.nextBigInteger();\n            b = cin.nextBigInteger();\n            c = a.max(b);\n            if (a.equals(c) && !b.equals(c)) System.out.println(\"GREATER\");\n            else if (b.equals(c) && !a.equals(c)) System.out.println(\"LESS\");\n            else System.out.println(\"EQUAL\");\n        }\n        cin.close();\n    }\n}\n", "test_IO": {"input": ["36\n24\n"], "output": ["GREATER\n"]}, "modified_context": "import java.math.*;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        BigInteger a, b, c;\n        Scanner cin = new Scanner(System.in);\n        while (cin.hasNext() ) {\n            a = cin.nextBigInteger();\n            b = cin.nextBigInteger();\n            c = a.max(b);\n            if (a.equals(c) && !b.equals(c) ) System.out.println(\"GREATER\");\n            else if (b.equals(c) && !a.equals(c) ) System.out.println(\"LESS\");\n            else System.out.println(\"EQUAL\");\n        }\n        cin.close();\n    }\n}\n"}
{"id": "Java/4", "code": "import java.util.Scanner;\n\npublic class SampleSolution implements Runnable {\n\n    private static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Thread(null, new SampleSolution(), \"\", 128 * 1024 * 1024).start();\n    }\n\n    public void run() {\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        long cost1 = 0;\n        long cost2 = 0;\n        int current1 = 0;\n        int current2 = 0;\n        long[] dp1 = new long[n];\n        long[] dp2 = new long[n];\n        for (int i = 0, j = n - 1; i < n; i++, j--) {\n            cost1 += Math.abs(a[i] - current1);\n            current1 = a[i];\n            dp1[i] = cost1;\n            cost2 += Math.abs(a[j] - current2);\n            current2 = a[j];\n            dp2[j] = cost2;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                System.out.println(dp2[i + 1] + Math.abs(a[1]));\n            } else if (i == n - 1) {\n                System.out.println(dp1[i - 1] + Math.abs(a[i - 1]));\n            } else {\n                System.out.println(dp1[i - 1] + dp2[i + 1] + Math.abs(a[i - 1] - a[i + 1]));\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["3\n3 5 -1\n"], "output": ["12\n8\n10\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution implements Runnable {\n\n    private static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        new Thread(null, new SampleSolution(), \"\", 128 * 1024 * 1024).start();\n    }\n\n    public void run() {\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        long cost1 = 0;\n        long cost2 = 0;\n        int current1 = 0;\n        int current2 = 0;\n        long[] dp1 = new long[n];\n        long[] dp2 = new long[n];\n        for (int i = 0, j = n - 1; i < n; i++, j--) {\n            cost1 += Math.abs(a[i] - current1);\n            current1 = a[i];\n            dp1[i] = cost1;\n            cost2 += Math.abs(a[j] - current2);\n            current2 = a[j];\n            dp2[j] = cost2;\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (i == 0) {\n                System.out.println(dp2[i + 1] + Math.abs(a[1]) );\n            } else if (i == n - 1) {\n                System.out.println(dp1[i - 1] + Math.abs(a[i - 1]) );\n            } else {\n                System.out.println(dp1[i - 1] + dp2[i + 1] + Math.abs(a[i - 1] - a[i + 1]) );\n            }\n        }\n    }\n}\n"}
{"id": "Java/5", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        int ans = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (a[i] != Math.min(a[i - 1], Math.min(a[i], a[i + 1]))\n                    && a[i] != Math.max(a[i - 1], Math.max(a[i], a[i + 1]))) {\n                ans++;\n            }\n        }\n        System.out.println(ans);\n        sc.close();\n    }\n}\n", "test_IO": {"input": ["5\n1 3 5 4 2\n"], "output": ["2\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = sc.nextInt();\n        }\n        int ans = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (a[i] != Math.min(a[i - 1], Math.min(a[i], a[i + 1]) )\n                    && a[i] != Math.max(a[i - 1], Math.max(a[i], a[i + 1]) ) ) {\n                ans++;\n            }\n        }\n        System.out.println(ans);\n        sc.close();\n    }\n}\n"}
{"id": "Java/6", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        String[] strs = reader.readLine().split(\" \");\n        int[] nums = new int[strs.length];\n        int top = 0;\n        for (int i = 0; i < strs.length; i++) {\n            switch (strs[i].charAt(0)) {\n                case '+':\n                    top--;\n                    nums[top - 1] = nums[top - 1] + nums[top];\n                    break;\n                case '-':\n                    top--;\n                    nums[top - 1] = nums[top - 1] - nums[top];\n                    break;\n                case '*':\n                    top--;\n                    nums[top - 1] = nums[top - 1] * nums[top];\n                    break;\n                default:\n                    nums[top] = Integer.parseInt(strs[i]);\n                    top++;\n                    break;\n            }\n        }\n        System.out.println(nums[0]);\n    }\n}\n", "test_IO": {"input": ["1 2 +\n"], "output": ["3\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws NumberFormatException, IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in) );\n\n        String[] strs = reader.readLine().split(\" \");\n        int[] nums = new int[strs.length];\n        int top = 0;\n        for (int i = 0; i < strs.length; i++) {\n            switch (strs[i].charAt(0) ) {\n                case '+':\n                    top--;\n                    nums[top - 1] = nums[top - 1] + nums[top];\n                    break;\n                case '-':\n                    top--;\n                    nums[top - 1] = nums[top - 1] - nums[top];\n                    break;\n                case '*':\n                    top--;\n                    nums[top - 1] = nums[top - 1] * nums[top];\n                    break;\n                default:\n                    nums[top] = Integer.parseInt(strs[i]);\n                    top++;\n                    break;\n            }\n        }\n        System.out.println(nums[0]);\n    }\n}\n"}
{"id": "Java/9", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        int[] a = new int[n];\n        String[] elements = br.readLine().split(\" \");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(elements[i]);\n        }\n\n        int swapCount = 0;\n\n        for (int i = 0; i < a.length; i++) {\n            int mini = i;\n\n            for (int j = i; j < a.length; j++) {\n                if (a[j] < a[mini]) {\n                    mini = j;\n                }\n            }\n\n            if (mini != i) {\n                int v = a[mini];\n                a[mini] = a[i];\n                a[i] = v;\n\n                swapCount++;\n            }\n        }\n\n        String ans = String.valueOf(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            ans += \" \" + a[i];\n        }\n\n        System.out.println(ans);\n        System.out.println(swapCount);\n    }\n}\n", "test_IO": {"input": ["6\n5 6 4 2 1 3\n"], "output": ["1 2 3 4 5 6\n4\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n        int n = Integer.parseInt(br.readLine() );\n        int[] a = new int[n];\n        String[] elements = br.readLine().split(\" \");\n\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(elements[i]);\n        }\n\n        int swapCount = 0;\n\n        for (int i = 0; i < a.length; i++) {\n            int mini = i;\n\n            for (int j = i; j < a.length; j++) {\n                if (a[j] < a[mini]) {\n                    mini = j;\n                }\n            }\n\n            if (mini != i) {\n                int v = a[mini];\n                a[mini] = a[i];\n                a[i] = v;\n\n                swapCount++;\n            }\n        }\n\n        String ans = String.valueOf(a[0]);\n        for (int i = 1; i < a.length; i++) {\n            ans += \" \" + a[i];\n        }\n\n        System.out.println(ans);\n        System.out.println(swapCount);\n    }\n}\n"}
{"id": "Java/12", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n\n        for (int i = 0; i < k; i++) {\n            int d = scanner.nextInt();\n            for (int j = 0; j < d; j++) {\n                int person = scanner.nextInt();\n\n                if (!map.containsKey(person)) {\n                    map.put(person, new ArrayList<>());\n                }\n                map.get(person).add(d);\n            }\n        }\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (!map.containsKey(i)) {\n                count++;\n            }\n        }\n\n        System.out.println(count);\n    }\n}\n", "test_IO": {"input": ["3 2\n2\n1 3\n1\n3\n"], "output": ["1\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        int k = scanner.nextInt();\n\n        Map<Integer, List<Integer>> map = new HashMap<>();\n\n        for (int i = 0; i < k; i++) {\n            int d = scanner.nextInt();\n            for (int j = 0; j < d; j++) {\n                int person = scanner.nextInt();\n\n                if (!map.containsKey(person) ) {\n                    map.put(person, new ArrayList<>() );\n                }\n                map.get(person).add(d);\n            }\n        }\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (!map.containsKey(i) ) {\n                count++;\n            }\n        }\n\n        System.out.println(count);\n    }\n}\n"}
{"id": "Java/14", "code": "import static java.lang.System.out;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        new SampleSolution().run();\n    }\n\n    MyInput in = new MyInput();\n\n    public void run() {\n        String Sd = in.next();\n        String T = in.next();\n        int count = 0;\n        char c;\n        boolean ok = false;\n        int first = -1;\n        int end = -1;\n        for (int j = 0; j < Sd.length(); j++) {\n            count = 0;\n            for (int i = 0; i + j < Sd.length(); i++) {\n                c = Sd.charAt(i + j);\n                if (c == '?' || c == T.charAt(count)) {\n                    count++;\n                    if (count == T.length()) {\n                        first = i + j - T.length() + 1;\n                        end = i + j;\n                        ok = true;\n                        break;\n                    }\n                } else count = 0;\n            }\n        }\n        if (ok) {\n            for (int i = 0; i < Sd.length(); i++) {\n                if (first <= i && i <= end) {\n                    out.print(T.charAt(i - first));\n                } else {\n                    if (Sd.charAt(i) == '?') out.print(\"a\");\n                    else out.print(Sd.charAt(i));\n                }\n            }\n            out.println();\n        } else {\n            out.println(\"UNRESTORABLE\");\n        }\n    }\n}\n\nclass MyInput {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "test_IO": {"input": ["?tc????\ncoder\n"], "output": ["atcoder\n"]}, "modified_context": "import static java.lang.System.out;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        new SampleSolution().run();\n    }\n\n    MyInput in = new MyInput();\n\n    public void run() {\n        String Sd = in.next();\n        String T = in.next();\n        int count = 0;\n        char c;\n        boolean ok = false;\n        int first = -1;\n        int end = -1;\n        for (int j = 0; j < Sd.length(); j++) {\n            count = 0;\n            for (int i = 0; i + j < Sd.length(); i++) {\n                c = Sd.charAt(i + j);\n                if (c == '?' || c == T.charAt(count) ) {\n                    count++;\n                    if (count == T.length() ) {\n                        first = i + j - T.length() + 1;\n                        end = i + j;\n                        ok = true;\n                        break;\n                    }\n                } else count = 0;\n            }\n        }\n        if (ok) {\n            for (int i = 0; i < Sd.length(); i++) {\n                if (first <= i && i <= end) {\n                    out.print(T.charAt(i - first) );\n                } else {\n                    if (Sd.charAt(i) == '?') out.print(\"a\");\n                    else out.print(Sd.charAt(i) );\n                }\n            }\n            out.println();\n        } else {\n            out.println(\"UNRESTORABLE\");\n        }\n    }\n}\n\nclass MyInput {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public int readByte() {\n        if (hasNextByte() ) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    private void skipUnprintable() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n    }\n\n    public boolean hasNext() {\n        skipUnprintable();\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b) ) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b) ) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n}\n"}
{"id": "Java/16", "code": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class SampleSolution {\n    public static final Scanner in =\n            new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    public static final PrintStream out = System.out;\n    public static final PrintStream err = System.err;\n\n    public static void main(String[] args) {\n        String Si = in.next();\n        char[] S = new StringBuilder(Si).reverse().toString().toCharArray();\n\n        long[] dp = new long[13];\n        dp[0] = 1;\n\n        for (int i = 0, d = 1; i < S.length; i++, d = d * 10 % 13) {\n            long[] nd = new long[13];\n\n            err.println(\"d: \" + d + \", i: \" + i + \", S[i]: \" + S[i]);\n            char c = S[i];\n\n            if (Character.isDigit(c)) {\n                int x = (c - '0') * d;\n\n                for (int j = 0; j < 13; j++) {\n                    nd[(j + x) % 13] = dp[j];\n                }\n            } else {\n                for (int xi = 0; xi < 10; xi++) {\n                    int x = xi * d;\n\n                    for (int j = 0; j < 13; j++) {\n                        int ni = (j + x) % 13;\n                        nd[ni] = (nd[ni] + dp[j]) % 1000000007;\n                    }\n                }\n            }\n\n            err.println(Arrays.toString(nd));\n            dp = nd;\n        }\n\n        out.println(dp[5]);\n    }\n}\n", "test_IO": {"input": ["??2??5\n"], "output": ["768\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class SampleSolution {\n    public static final Scanner in =\n            new Scanner(new BufferedReader(new InputStreamReader(System.in) ) );\n    public static final PrintStream out = System.out;\n    public static final PrintStream err = System.err;\n\n    public static void main(String[] args) {\n        String Si = in.next();\n        char[] S = new StringBuilder(Si).reverse().toString().toCharArray();\n\n        long[] dp = new long[13];\n        dp[0] = 1;\n\n        for (int i = 0, d = 1; i < S.length; i++, d = d * 10 % 13) {\n            long[] nd = new long[13];\n\n            err.println(\"d: \" + d + \", i: \" + i + \", S[i]: \" + S[i]);\n            char c = S[i];\n\n            if (Character.isDigit(c) ) {\n                int x = (c - '0') * d;\n\n                for (int j = 0; j < 13; j++) {\n                    nd[(j + x) % 13] = dp[j];\n                }\n            } else {\n                for (int xi = 0; xi < 10; xi++) {\n                    int x = xi * d;\n\n                    for (int j = 0; j < 13; j++) {\n                        int ni = (j + x) % 13;\n                        nd[ni] = (nd[ni] + dp[j]) % 1000000007;\n                    }\n                }\n            }\n\n            err.println(Arrays.toString(nd) );\n            dp = nd;\n        }\n\n        out.println(dp[5]);\n    }\n}\n"}
{"id": "Java/17", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    Scanner sc;\n    int max = 0, cur = 0;\n\n    void solve() {\n        int a = ni();\n        int b = ni();\n\n        System.out.println(Math.max(0, a - 2 * b));\n    }\n\n    SampleSolution() {\n        try {\n            sc = new Scanner(System.in);\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    int ni() {\n        int a = sc.nextInt();\n        return a;\n    }\n\n    long nl() {\n        return sc.nextLong();\n    }\n\n    float nf() {\n        float a = sc.nextFloat();\n        return a;\n    }\n\n    double nd() {\n        double a = sc.nextDouble();\n        return a;\n    }\n\n    String ns() {\n        return sc.nextLine();\n    }\n\n    StringTokenizer nst(String s) {\n        return new StringTokenizer(s);\n    }\n\n    void ia(int a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextInt();\n    }\n\n    void la(long a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextLong();\n    }\n\n    void fa(float a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextFloat();\n    }\n\n    void da(double a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextDouble();\n    }\n\n    void sa(String a[], boolean empty) {\n        if (empty) {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = \"\";\n            }\n        } else {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = ns();\n            }\n        }\n    }\n\n    void ida(int a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = ni();\n            }\n        }\n    }\n\n    void lda(long a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nl();\n            }\n        }\n    }\n\n    void dda(double a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nd();\n            }\n        }\n    }\n\n    int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n\n    double stod(String s) {\n        return Double.parseDouble(s);\n    }\n\n    long lmin(long a[]) {\n        long min = Long.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    int imin(int a[]) {\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    long lmax(long a[]) {\n        long max = Long.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    int imax(int a[]) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    boolean ibs(int a[], int toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    boolean lbs(long a[], long toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    int stb(String s) {\n        int sum = 0;\n        int k = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            sum += stoi(s.charAt(i) + \"\") * Math.pow(2, k++);\n        }\n        return sum;\n    }\n}\n", "test_IO": {"input": ["12 4\n"], "output": ["4\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    Scanner sc;\n    int max = 0, cur = 0;\n\n    void solve() {\n        int a = ni();\n        int b = ni();\n\n        System.out.println(Math.max(0, a - 2 * b) );\n    }\n\n    SampleSolution() {\n        try {\n            sc = new Scanner(System.in);\n        } catch (Exception e) {\n            System.out.println(e);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    int ni() {\n        int a = sc.nextInt();\n        return a;\n    }\n\n    long nl() {\n        return sc.nextLong();\n    }\n\n    float nf() {\n        float a = sc.nextFloat();\n        return a;\n    }\n\n    double nd() {\n        double a = sc.nextDouble();\n        return a;\n    }\n\n    String ns() {\n        return sc.nextLine();\n    }\n\n    StringTokenizer nst(String s) {\n        return new StringTokenizer(s);\n    }\n\n    void ia(int a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextInt();\n    }\n\n    void la(long a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextLong();\n    }\n\n    void fa(float a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextFloat();\n    }\n\n    void da(double a[]) {\n        for (int i = 0; i < a.length; i++) a[i] = sc.nextDouble();\n    }\n\n    void sa(String a[], boolean empty) {\n        if (empty) {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = \"\";\n            }\n        } else {\n            for (int i = 0; i < a.length; i++) {\n                a[i] = ns();\n            }\n        }\n    }\n\n    void ida(int a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = ni();\n            }\n        }\n    }\n\n    void lda(long a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nl();\n            }\n        }\n    }\n\n    void dda(double a[][], int n, int m) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                a[i][j] = nd();\n            }\n        }\n    }\n\n    int stoi(String s) {\n        return Integer.parseInt(s);\n    }\n\n    double stod(String s) {\n        return Double.parseDouble(s);\n    }\n\n    long lmin(long a[]) {\n        long min = Long.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    int imin(int a[]) {\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (min > a[i]) min = a[i];\n        }\n        return min;\n    }\n\n    long lmax(long a[]) {\n        long max = Long.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    int imax(int a[]) {\n        int max = Integer.MIN_VALUE;\n        for (int i = 0; i < a.length; i++) {\n            if (max < a[i]) max = a[i];\n        }\n        return max;\n    }\n\n    boolean ibs(int a[], int toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    boolean lbs(long a[], long toFind) {\n        Arrays.sort(a);\n        int min = 0;\n        int max = a.length - 1;\n        boolean found = false;\n\n        while (min <= max && !found) {\n            int mid = min + (max - min) / 2;\n            if (a[mid] == toFind) {\n                found = true;\n            } else if (toFind > a[mid]) {\n                min = mid + 1;\n            } else {\n                max = mid - 1;\n            }\n        }\n        return found;\n    }\n\n    int stb(String s) {\n        int sum = 0;\n        int k = 0;\n        for (int i = s.length() - 1; i >= 0; i--) {\n            sum += stoi(s.charAt(i) + \"\") * Math.pow(2, k++);\n        }\n        return sum;\n    }\n}\n"}
{"id": "Java/19", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SampleSolution {\n    static final long MOD1 = 1000000007;\n    static final long MOD2 = 998244353;\n    static long[] tenmod;\n    static final long inv9 = modInv(9);\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputReader sc = new InputReader(System.in);\n        int N = sc.nextInt();\n        int Q = sc.nextInt();\n        tenmod = new long[N + 1];\n        tenmod[0] = 1;\n        for (int j = 1; j <= N; j++) {\n            tenmod[j] = (tenmod[j - 1] * 10L) % MOD2;\n        }\n        S[] dat = new S[N];\n        Arrays.setAll(dat, i -> new S(tenmod[N - i - 1], i, i));\n        LazySegTree<S, F> lazySegTree =\n                new LazySegTree<S, F>(dat, S::op, S.E, S::map, F::composite, F.I);\n        for (int j = 0; j < Q; j++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt() - 1;\n            long D = sc.nextLong();\n            lazySegTree.apply(l, r + 1, new F(D, N));\n            out.println(lazySegTree.allProd().sum);\n        }\n        out.flush();\n    }\n\n    static class S {\n        static final S E = new S(0, Integer.MAX_VALUE / 2, Integer.MIN_VALUE / 2);\n        long sum;\n        int l;\n        int r;\n\n        public S(long sum, int l, int r) {\n            super();\n            this.sum = sum;\n            this.l = l;\n            this.r = r;\n        }\n\n        public static S op(S s1, S s2) {\n            long sum = s1.sum + s2.sum;\n            if (sum >= MOD2) {\n                sum -= MOD2;\n            }\n            return new S(sum, Math.min(s1.l, s2.l), Math.max(s1.r, s2.r));\n        }\n\n        static S map(F f, S s) {\n            long c = (tenmod[(f.N - s.l)] - tenmod[(f.N - s.r - 1)]);\n            if (c < 0) {\n                c += MOD2;\n            }\n            return new S(((f.D * c) % MOD2 * inv9) % MOD2, s.l, s.r);\n        }\n    }\n\n    static class F {\n        static final F I = new F(0, 0);\n        long D;\n        int N;\n\n        public F(long D, int N) {\n            super();\n            this.D = D;\n            this.N = N;\n        }\n\n        public static F composite(F f, F g) {\n            return new F(f.D, f.N);\n        }\n    }\n\n    static long modInv(long x) {\n        return modPow(x, MOD2 - 2);\n    }\n\n    static long modPow(long x, long y) {\n        long z = 1;\n        while (y > 0) {\n            if (y % 2 == 0) {\n                x = (x * x) % MOD2;\n                y /= 2;\n            } else {\n                z = (z * x) % MOD2;\n                y--;\n            }\n        }\n        return z;\n    }\n\n    static class LazySegTree<S, F> {\n        final int MAX;\n\n        final int N;\n        final int Log;\n        final java.util.function.BinaryOperator<S> Op;\n        final S E;\n        final java.util.function.BiFunction<F, S, S> Mapping;\n        final java.util.function.BinaryOperator<F> Composition;\n        final F Id;\n\n        final S[] Dat;\n        final F[] Laz;\n\n        @SuppressWarnings(\"unchecked\")\n        public LazySegTree(\n                int n,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this.MAX = n;\n            int k = 1;\n            while (k < n) k <<= 1;\n            this.N = k;\n            this.Log = Integer.numberOfTrailingZeros(N);\n            this.Op = op;\n            this.E = e;\n            this.Mapping = mapping;\n            this.Composition = composition;\n            this.Id = id;\n            this.Dat = (S[]) new Object[N << 1];\n            this.Laz = (F[]) new Object[N];\n            java.util.Arrays.fill(Dat, E);\n            java.util.Arrays.fill(Laz, Id);\n        }\n\n        public LazySegTree(\n                S[] dat,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this(dat.length, op, e, mapping, composition, id);\n            build(dat);\n        }\n\n        private void build(S[] dat) {\n            int l = dat.length;\n            System.arraycopy(dat, 0, Dat, N, l);\n            for (int i = N - 1; i > 0; i--) {\n                Dat[i] = Op.apply(Dat[i << 1 | 0], Dat[i << 1 | 1]);\n            }\n        }\n\n        private void push(int k) {\n            if (Laz[k] == Id) return;\n            int lk = k << 1 | 0, rk = k << 1 | 1;\n            Dat[lk] = Mapping.apply(Laz[k], Dat[lk]);\n            Dat[rk] = Mapping.apply(Laz[k], Dat[rk]);\n            if (lk < N) Laz[lk] = Composition.apply(Laz[k], Laz[lk]);\n            if (rk < N) Laz[rk] = Composition.apply(Laz[k], Laz[rk]);\n            Laz[k] = Id;\n        }\n\n        private void pushTo(int k) {\n            for (int i = Log; i > 0; i--) push(k >> i);\n        }\n\n        private void pushTo(int lk, int rk) {\n            for (int i = Log; i > 0; i--) {\n                if (((lk >> i) << i) != lk) push(lk >> i);\n                if (((rk >> i) << i) != rk) push(rk >> i);\n            }\n        }\n\n        private void updateFrom(int k) {\n            k >>= 1;\n            while (k > 0) {\n                Dat[k] = Op.apply(Dat[k << 1 | 0], Dat[k << 1 | 1]);\n                k >>= 1;\n            }\n        }\n\n        private void updateFrom(int lk, int rk) {\n            for (int i = 1; i <= Log; i++) {\n                if (((lk >> i) << i) != lk) {\n                    int lki = lk >> i;\n                    Dat[lki] = Op.apply(Dat[lki << 1 | 0], Dat[lki << 1 | 1]);\n                }\n                if (((rk >> i) << i) != rk) {\n                    int rki = (rk - 1) >> i;\n                    Dat[rki] = Op.apply(Dat[rki << 1 | 0], Dat[rki << 1 | 1]);\n                }\n            }\n        }\n\n        public void set(int p, S x) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = x;\n            updateFrom(p);\n        }\n\n        public S get(int p) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            return Dat[p];\n        }\n\n        public S allProd() {\n            return Dat[1];\n        }\n\n        public void apply(int p, F f) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = Mapping.apply(f, Dat[p]);\n            updateFrom(p);\n        }\n\n        public void apply(int l, int r, F f) {\n            if (l > r) {\n                throw new IllegalArgumentException(String.format(\"Invalid range: [%d, %d)\", l, r));\n            }\n            inclusiveRangeCheck(l);\n            inclusiveRangeCheck(r);\n            if (l == r) return;\n            l += N;\n            r += N;\n            pushTo(l, r);\n            for (int l2 = l, r2 = r; l2 < r2; ) {\n                if ((l2 & 1) == 1) {\n                    Dat[l2] = Mapping.apply(f, Dat[l2]);\n                    if (l2 < N) Laz[l2] = Composition.apply(f, Laz[l2]);\n                    l2++;\n                }\n                if ((r2 & 1) == 1) {\n                    r2--;\n                    Dat[r2] = Mapping.apply(f, Dat[r2]);\n                    if (r2 < N) Laz[r2] = Composition.apply(f, Laz[r2]);\n                }\n                l2 >>= 1;\n                r2 >>= 1;\n            }\n            updateFrom(l, r);\n        }\n\n        public int maxRight(int l, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(l);\n            if (!g.test(E)) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (l == MAX) return MAX;\n            l += N;\n            pushTo(l);\n            S sum = E;\n            do {\n                l >>= Integer.numberOfTrailingZeros(l);\n                if (!g.test(Op.apply(sum, Dat[l]))) {\n                    while (l < N) {\n                        push(l);\n                        l = l << 1;\n                        if (g.test(Op.apply(sum, Dat[l]))) {\n                            sum = Op.apply(sum, Dat[l]);\n                            l++;\n                        }\n                    }\n                    return l - N;\n                }\n                sum = Op.apply(sum, Dat[l]);\n                l++;\n            } while ((l & -l) != l);\n            return MAX;\n        }\n\n        public int minLeft(int r, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(r);\n            if (!g.test(E)) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (r == 0) return 0;\n            r += N;\n            pushTo(r - 1);\n            S sum = E;\n            do {\n                r--;\n                while (r > 1 && (r & 1) == 1) r >>= 1;\n                if (!g.test(Op.apply(Dat[r], sum))) {\n                    while (r < N) {\n                        push(r);\n                        r = r << 1 | 1;\n                        if (g.test(Op.apply(Dat[r], sum))) {\n                            sum = Op.apply(Dat[r], sum);\n                            r--;\n                        }\n                    }\n                    return r + 1 - N;\n                }\n                sum = Op.apply(Dat[r], sum);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n        private void exclusiveRangeCheck(int p) {\n            if (p < 0 || p >= MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d).\", p, 0, MAX));\n            }\n        }\n\n        private void inclusiveRangeCheck(int p) {\n            if (p < 0 || p > MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d].\", p, 0, MAX));\n            }\n        }\n\n        private int indent = 6;\n\n        public void setIndent(int newIndent) {\n            this.indent = newIndent;\n        }\n\n        @Override\n        public String toString() {\n            return makeString(1, 0);\n        }\n\n        private String makeString(int k, int sp) {\n            if (k >= N) return indent(sp) + Dat[k];\n            String s = \"\";\n            s += makeString(k << 1 | 1, sp + indent);\n            s += \"\\n\";\n            s += indent(sp) + Dat[k] + \"/\" + Laz[k];\n            s += \"\\n\";\n            s += makeString(k << 1 | 0, sp + indent);\n            return s;\n        }\n\n        private static String indent(int n) {\n            StringBuilder sb = new StringBuilder();\n            while (n-- > 0) sb.append(' ');\n            return sb.toString();\n        }\n    }\n\n    static class InputReader {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n\n        public InputReader(InputStream in) {\n            this.in = in;\n            this.curbuf = this.lenbuf = 0;\n        }\n\n        public boolean hasNextByte() {\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return false;\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[curbuf++];\n            else return -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private void skip() {\n            while (hasNextByte() && isSpaceChar(buffer[curbuf])) curbuf++;\n        }\n\n        public boolean hasNext() {\n            skip();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isSpaceChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            if (!hasNext()) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        public char[][] nextCharMap(int n, int m) {\n            char[][] map = new char[n][m];\n            for (int i = 0; i < n; i++) map[i] = next().toCharArray();\n            return map;\n        }\n    }\n}\n", "test_IO": {"input": ["8 5\n3 6 2\n1 4 7\n3 8 3\n2 2 2\n4 5 1\n"], "output": ["11222211\n77772211\n77333333\n72333333\n72311333\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class SampleSolution {\n    static final long MOD1 = 1000000007;\n    static final long MOD2 = 998244353;\n    static long[] tenmod;\n    static final long inv9 = modInv(9);\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n        InputReader sc = new InputReader(System.in);\n        int N = sc.nextInt();\n        int Q = sc.nextInt();\n        tenmod = new long[N + 1];\n        tenmod[0] = 1;\n        for (int j = 1; j <= N; j++) {\n            tenmod[j] = (tenmod[j - 1] * 10L) % MOD2;\n        }\n        S[] dat = new S[N];\n        Arrays.setAll(dat, i -> new S(tenmod[N - i - 1], i, i) );\n        LazySegTree<S, F> lazySegTree =\n                new LazySegTree<S, F>(dat, S::op, S.E, S::map, F::composite, F.I);\n        for (int j = 0; j < Q; j++) {\n            int l = sc.nextInt() - 1;\n            int r = sc.nextInt() - 1;\n            long D = sc.nextLong();\n            lazySegTree.apply(l, r + 1, new F(D, N) );\n            out.println(lazySegTree.allProd().sum);\n        }\n        out.flush();\n    }\n\n    static class S {\n        static final S E = new S(0, Integer.MAX_VALUE / 2, Integer.MIN_VALUE / 2);\n        long sum;\n        int l;\n        int r;\n\n        public S(long sum, int l, int r) {\n            super();\n            this.sum = sum;\n            this.l = l;\n            this.r = r;\n        }\n\n        public static S op(S s1, S s2) {\n            long sum = s1.sum + s2.sum;\n            if (sum >= MOD2) {\n                sum -= MOD2;\n            }\n            return new S(sum, Math.min(s1.l, s2.l), Math.max(s1.r, s2.r) );\n        }\n\n        static S map(F f, S s) {\n            long c = (tenmod[(f.N - s.l)] - tenmod[(f.N - s.r - 1)]);\n            if (c < 0) {\n                c += MOD2;\n            }\n            return new S(((f.D * c) % MOD2 * inv9) % MOD2, s.l, s.r);\n        }\n    }\n\n    static class F {\n        static final F I = new F(0, 0);\n        long D;\n        int N;\n\n        public F(long D, int N) {\n            super();\n            this.D = D;\n            this.N = N;\n        }\n\n        public static F composite(F f, F g) {\n            return new F(f.D, f.N);\n        }\n    }\n\n    static long modInv(long x) {\n        return modPow(x, MOD2 - 2);\n    }\n\n    static long modPow(long x, long y) {\n        long z = 1;\n        while (y > 0) {\n            if (y % 2 == 0) {\n                x = (x * x) % MOD2;\n                y /= 2;\n            } else {\n                z = (z * x) % MOD2;\n                y--;\n            }\n        }\n        return z;\n    }\n\n    static class LazySegTree<S, F> {\n        final int MAX;\n\n        final int N;\n        final int Log;\n        final java.util.function.BinaryOperator<S> Op;\n        final S E;\n        final java.util.function.BiFunction<F, S, S> Mapping;\n        final java.util.function.BinaryOperator<F> Composition;\n        final F Id;\n\n        final S[] Dat;\n        final F[] Laz;\n\n        @SuppressWarnings(\"unchecked\")\n        public LazySegTree(\n                int n,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this.MAX = n;\n            int k = 1;\n            while (k < n) k <<= 1;\n            this.N = k;\n            this.Log = Integer.numberOfTrailingZeros(N);\n            this.Op = op;\n            this.E = e;\n            this.Mapping = mapping;\n            this.Composition = composition;\n            this.Id = id;\n            this.Dat = (S[]) new Object[N << 1];\n            this.Laz = (F[]) new Object[N];\n            java.util.Arrays.fill(Dat, E);\n            java.util.Arrays.fill(Laz, Id);\n        }\n\n        public LazySegTree(\n                S[] dat,\n                java.util.function.BinaryOperator<S> op,\n                S e,\n                java.util.function.BiFunction<F, S, S> mapping,\n                java.util.function.BinaryOperator<F> composition,\n                F id) {\n            this(dat.length, op, e, mapping, composition, id);\n            build(dat);\n        }\n\n        private void build(S[] dat) {\n            int l = dat.length;\n            System.arraycopy(dat, 0, Dat, N, l);\n            for (int i = N - 1; i > 0; i--) {\n                Dat[i] = Op.apply(Dat[i << 1 | 0], Dat[i << 1 | 1]);\n            }\n        }\n\n        private void push(int k) {\n            if (Laz[k] == Id) return;\n            int lk = k << 1 | 0, rk = k << 1 | 1;\n            Dat[lk] = Mapping.apply(Laz[k], Dat[lk]);\n            Dat[rk] = Mapping.apply(Laz[k], Dat[rk]);\n            if (lk < N) Laz[lk] = Composition.apply(Laz[k], Laz[lk]);\n            if (rk < N) Laz[rk] = Composition.apply(Laz[k], Laz[rk]);\n            Laz[k] = Id;\n        }\n\n        private void pushTo(int k) {\n            for (int i = Log; i > 0; i--) push(k >> i);\n        }\n\n        private void pushTo(int lk, int rk) {\n            for (int i = Log; i > 0; i--) {\n                if (((lk >> i) << i) != lk) push(lk >> i);\n                if (((rk >> i) << i) != rk) push(rk >> i);\n            }\n        }\n\n        private void updateFrom(int k) {\n            k >>= 1;\n            while (k > 0) {\n                Dat[k] = Op.apply(Dat[k << 1 | 0], Dat[k << 1 | 1]);\n                k >>= 1;\n            }\n        }\n\n        private void updateFrom(int lk, int rk) {\n            for (int i = 1; i <= Log; i++) {\n                if (((lk >> i) << i) != lk) {\n                    int lki = lk >> i;\n                    Dat[lki] = Op.apply(Dat[lki << 1 | 0], Dat[lki << 1 | 1]);\n                }\n                if (((rk >> i) << i) != rk) {\n                    int rki = (rk - 1) >> i;\n                    Dat[rki] = Op.apply(Dat[rki << 1 | 0], Dat[rki << 1 | 1]);\n                }\n            }\n        }\n\n        public void set(int p, S x) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = x;\n            updateFrom(p);\n        }\n\n        public S get(int p) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            return Dat[p];\n        }\n\n        public S allProd() {\n            return Dat[1];\n        }\n\n        public void apply(int p, F f) {\n            exclusiveRangeCheck(p);\n            p += N;\n            pushTo(p);\n            Dat[p] = Mapping.apply(f, Dat[p]);\n            updateFrom(p);\n        }\n\n        public void apply(int l, int r, F f) {\n            if (l > r) {\n                throw new IllegalArgumentException(String.format(\"Invalid range: [%d, %d)\", l, r) );\n            }\n            inclusiveRangeCheck(l);\n            inclusiveRangeCheck(r);\n            if (l == r) return;\n            l += N;\n            r += N;\n            pushTo(l, r);\n            for (int l2 = l, r2 = r; l2 < r2; ) {\n                if ((l2 & 1) == 1) {\n                    Dat[l2] = Mapping.apply(f, Dat[l2]);\n                    if (l2 < N) Laz[l2] = Composition.apply(f, Laz[l2]);\n                    l2++;\n                }\n                if ((r2 & 1) == 1) {\n                    r2--;\n                    Dat[r2] = Mapping.apply(f, Dat[r2]);\n                    if (r2 < N) Laz[r2] = Composition.apply(f, Laz[r2]);\n                }\n                l2 >>= 1;\n                r2 >>= 1;\n            }\n            updateFrom(l, r);\n        }\n\n        public int maxRight(int l, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(l);\n            if (!g.test(E) ) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (l == MAX) return MAX;\n            l += N;\n            pushTo(l);\n            S sum = E;\n            do {\n                l >>= Integer.numberOfTrailingZeros(l);\n                if (!g.test(Op.apply(sum, Dat[l]) ) ) {\n                    while (l < N) {\n                        push(l);\n                        l = l << 1;\n                        if (g.test(Op.apply(sum, Dat[l]) ) ) {\n                            sum = Op.apply(sum, Dat[l]);\n                            l++;\n                        }\n                    }\n                    return l - N;\n                }\n                sum = Op.apply(sum, Dat[l]);\n                l++;\n            } while ((l & -l) != l);\n            return MAX;\n        }\n\n        public int minLeft(int r, java.util.function.Predicate<S> g) {\n            inclusiveRangeCheck(r);\n            if (!g.test(E) ) {\n                throw new IllegalArgumentException(\"Identity element must satisfy the condition.\");\n            }\n            if (r == 0) return 0;\n            r += N;\n            pushTo(r - 1);\n            S sum = E;\n            do {\n                r--;\n                while (r > 1 && (r & 1) == 1) r >>= 1;\n                if (!g.test(Op.apply(Dat[r], sum) ) ) {\n                    while (r < N) {\n                        push(r);\n                        r = r << 1 | 1;\n                        if (g.test(Op.apply(Dat[r], sum) ) ) {\n                            sum = Op.apply(Dat[r], sum);\n                            r--;\n                        }\n                    }\n                    return r + 1 - N;\n                }\n                sum = Op.apply(Dat[r], sum);\n            } while ((r & -r) != r);\n            return 0;\n        }\n\n        private void exclusiveRangeCheck(int p) {\n            if (p < 0 || p >= MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d).\", p, 0, MAX) );\n            }\n        }\n\n        private void inclusiveRangeCheck(int p) {\n            if (p < 0 || p > MAX) {\n                throw new IndexOutOfBoundsException(\n                        String.format(\"Index %d is not in [%d, %d].\", p, 0, MAX) );\n            }\n        }\n\n        private int indent = 6;\n\n        public void setIndent(int newIndent) {\n            this.indent = newIndent;\n        }\n\n        @Override\n        public String toString() {\n            return makeString(1, 0);\n        }\n\n        private String makeString(int k, int sp) {\n            if (k >= N) return indent(sp) + Dat[k];\n            String s = \"\";\n            s += makeString(k << 1 | 1, sp + indent);\n            s += \"\\n\";\n            s += indent(sp) + Dat[k] + \"/\" + Laz[k];\n            s += \"\\n\";\n            s += makeString(k << 1 | 0, sp + indent);\n            return s;\n        }\n\n        private static String indent(int n) {\n            StringBuilder sb = new StringBuilder();\n            while (n-- > 0) sb.append(' ');\n            return sb.toString();\n        }\n    }\n\n    static class InputReader {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n\n        public InputReader(InputStream in) {\n            this.in = in;\n            this.curbuf = this.lenbuf = 0;\n        }\n\n        public boolean hasNextByte() {\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return false;\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte() ) return buffer[curbuf++];\n            else return -1;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private void skip() {\n            while (hasNextByte() && isSpaceChar(buffer[curbuf]) ) curbuf++;\n        }\n\n        public boolean hasNext() {\n            skip();\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isSpaceChar(b) ) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c) ) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c) );\n            return (minus) ? -res : res;\n        }\n\n        public long nextLong() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            int c = readByte();\n            while (isSpaceChar(c) ) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c) );\n            return (minus) ? -res : res;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        public char[][] nextCharMap(int n, int m) {\n            char[][] map = new char[n][m];\n            for (int i = 0; i < n; i++) map[i] = next().toCharArray();\n            return map;\n        }\n    }\n}\n"}
{"id": "Java/20", "code": "import java.io.*;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String sc = br.readLine();\n        int n = Integer.parseInt(sc);\n        String[] str = new String[n];\n        for (int i = 0; i < n; i++) {\n            str[i] = br.readLine();\n        }\n        String[] mark = {\"S\", \"H\", \"C\", \"D\"};\n        for (String ma : mark) {\n            for (int i = 1; i <= 13; i++) {\n                String s = Integer.toString(i);\n                String st = ma + \" \" + s;\n                if (Arrays.asList(str).contains(st)) {\n                    continue;\n                } else {\n                    System.out.println(st);\n                }\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["47\nS 10\nS 11\nS 12\nS 13\nH 1\nH 2\nS 6\nS 7\nS 8\nS 9\nH 6\nH 8\nH 9\nH 10\nH 11\nH 4\nH 5\nS 2\nS 3\nS 4\nS 5\nH 12\nH 13\nC 1\nC 2\nD 1\nD 2\nD 3\nD 4\nD 5\nD 6\nD 7\nC 3\nC 4\nC 5\nC 6\nC 7\nC 8\nC 9\nC 10\nC 11\nC 13\nD 9\nD 10\nD 11\nD 12\nD 13\n"], "output": ["S 1\nH 3\nH 7\nC 12\nD 8\n"]}, "modified_context": "import java.io.*;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n        String sc = br.readLine();\n        int n = Integer.parseInt(sc);\n        String[] str = new String[n];\n        for (int i = 0; i < n; i++) {\n            str[i] = br.readLine();\n        }\n        String[] mark = {\"S\", \"H\", \"C\", \"D\"};\n        for (String ma : mark) {\n            for (int i = 1; i <= 13; i++) {\n                String s = Integer.toString(i);\n                String st = ma + \" \" + s;\n                if (Arrays.asList(str).contains(st) ) {\n                    continue;\n                } else {\n                    System.out.println(st);\n                }\n            }\n        }\n    }\n}\n"}
{"id": "Java/21", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class Pair {\n        int l, r;\n\n        Pair(int a, int b) {\n            l = a;\n            r = b;\n        }\n\n        @Override\n        public String toString() {\n            return l + \" \" + r;\n        }\n    }\n\n    static int[][][] memo;\n    static int[][] a;\n    static int n;\n\n    static int dp(int fliped, int idx, int msk) {\n        if (msk == (1 << n) - 1) return 0;\n        if (memo[fliped][idx][msk] != -1) return memo[fliped][idx][msk];\n        int x = Integer.bitCount(msk);\n        int ff = 0;\n        int ans = (int) 1e9;\n        for (int i = 0; i < n; i++) {\n            if ((msk & (1 << i)) == 0) {\n                int nf = x % 2;\n                if (idx == n || a[fliped][idx] <= a[(nf + (ff % 2)) % 2][i]) {\n                    ans = Math.min(ans, ff + dp((nf + (ff % 2)) % 2, i, msk | 1 << i));\n                }\n                ff++;\n            } else x--;\n        }\n        return memo[fliped][idx][msk] = ans;\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        n = sc.nextInt();\n        a = new int[2][n];\n        for (int i = 0; i < n; i++) a[0][i] = sc.nextInt();\n        for (int i = 0; i < n; i++) a[1][i] = sc.nextInt();\n        memo = new int[2][n + 1][1 << n];\n        for (int[][] z : memo) for (int[] x : z) Arrays.fill(x, -1);\n        int ans = dp(0, n, 0);\n        pw.println(ans >= 1e8 ? -1 : ans);\n        pw.flush();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec) f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}\n", "test_IO": {"input": ["3\n3 4 3\n3 2 3\n"], "output": ["1\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class Pair {\n        int l, r;\n\n        Pair(int a, int b) {\n            l = a;\n            r = b;\n        }\n\n        @Override\n        public String toString() {\n            return l + \" \" + r;\n        }\n    }\n\n    static int[][][] memo;\n    static int[][] a;\n    static int n;\n\n    static int dp(int fliped, int idx, int msk) {\n        if (msk == (1 << n) - 1) return 0;\n        if (memo[fliped][idx][msk] != -1) return memo[fliped][idx][msk];\n        int x = Integer.bitCount(msk);\n        int ff = 0;\n        int ans = (int) 1e9;\n        for (int i = 0; i < n; i++) {\n            if ((msk & (1 << i) ) == 0) {\n                int nf = x % 2;\n                if (idx == n || a[fliped][idx] <= a[(nf + (ff % 2) ) % 2][i]) {\n                    ans = Math.min(ans, ff + dp((nf + (ff % 2) ) % 2, i, msk | 1 << i) );\n                }\n                ff++;\n            } else x--;\n        }\n        return memo[fliped][idx][msk] = ans;\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        n = sc.nextInt();\n        a = new int[2][n];\n        for (int i = 0; i < n; i++) a[0][i] = sc.nextInt();\n        for (int i = 0; i < n; i++) a[1][i] = sc.nextInt();\n        memo = new int[2][n + 1][1 << n];\n        for (int[][] z : memo) for (int[] x : z) Arrays.fill(x, -1);\n        int ans = dp(0, n, 0);\n        pw.println(ans >= 1e8 ? -1 : ans);\n        pw.flush();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s) );\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens() ) st = new StringTokenizer(br.readLine() );\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next() );\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next() );\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString() );\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i) );\n                    if (dec) f *= 10;\n                }\n            res += Long.parseLong(sb.toString() ) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n}\n"}
{"id": "Java/24", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        MyWriter out = new MyWriter(System.out);\n\n        MyScanner sc = new MyScanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        LinkedList<Integer>[] list = new LinkedList[100001];\n\n        for (int i = 0; i < N; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if (list[a] == null) {\n                list[a] = new LinkedList<Integer>();\n            }\n            list[a].add(b);\n        }\n\n        int res = 0;\n        PriorityQueue<Integer> pqueue = new PriorityQueue<Integer>(Collections.reverseOrder());\n        for (int i = 1; i <= M; i++) {\n            if (list[i] != null) {\n                pqueue.addAll(list[i]);\n            }\n            if (!pqueue.isEmpty()) res += pqueue.poll();\n        }\n\n        out.println(res);\n        out.flush();\n    }\n\n    static final class MyScanner {\n        static final int BUFFER_SIZE = 8192;\n        private final InputStream in;\n        private final byte[] buffer = new byte[BUFFER_SIZE];\n        private int point;\n        private int readLength;\n\n        MyScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private int readByte() {\n            if (point < readLength) {\n                int result = buffer[point];\n                point += 1;\n                return result;\n            }\n            try {\n                readLength = in.read(buffer);\n            } catch (IOException e) {\n                throw new AssertionError(null, e);\n            }\n            if (readLength == -1) {\n                return -1;\n            }\n            point = 1;\n            return buffer[0];\n        }\n\n        private static boolean isPrintableCharExceptSpace(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        String next() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder b = new StringBuilder();\n            do {\n                b.appendCodePoint(c);\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c));\n            return b.toString();\n        }\n\n        long nextLong() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long result = 0L;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                result = result * 10L + (c - '0');\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c));\n            return minus ? -result : result;\n        }\n\n        int nextInt() {\n            long n = nextLong();\n            if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n                throw new InputMismatchException();\n            }\n            return (int) n;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] result = new int[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextInt();\n            }\n            return result;\n        }\n\n        private static boolean allSameLength(int[] a, int[] b, int[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (int[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static boolean allSameLength(char[] a, char[] b, char[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (char[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        void nextVerticalIntArrays(int[] a, int[] b, int[]... c) {\n            if (!allSameLength(a, b, c)) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n                b[i] = nextInt();\n                for (int[] d : c) {\n                    d[i] = nextInt();\n                }\n            }\n        }\n\n        long[] nextLongArray(int n) {\n            long[] result = new long[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextLong();\n            }\n            return result;\n        }\n\n        char nextChar() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c))) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            return (char) c;\n        }\n\n        char[] nextCharArray(int n) {\n            char[] result = new char[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextChar();\n            }\n            return result;\n        }\n\n        char[][] next2dCharArray(int n, int m) {\n            char[][] result = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    result[i][j] = nextChar();\n                }\n            }\n            return result;\n        }\n\n        void nextVerticalCharArrays(char[] a, char[] b, char[]... c) {\n            if (!allSameLength(a, b, c)) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextChar();\n                b[i] = nextChar();\n                for (char[] d : c) {\n                    d[i] = nextChar();\n                }\n            }\n        }\n    }\n\n    static final class MyWriter extends PrintWriter {\n        MyWriter(OutputStream out) {\n            super(out);\n        }\n\n        void joinAndPrintln(int[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(int[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter).append(x[i]);\n                }\n            }\n            println(b.toString());\n        }\n\n        void joinAndPrintln(long[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(long[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter).append(x[i]);\n                }\n            }\n            println(b.toString());\n        }\n\n        void joinAndPrintln(Iterable<?> iterable) {\n            joinAndPrintln(iterable, \" \");\n        }\n\n        void joinAndPrintln(Iterable<?> iterable, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            for (Iterator<?> i = iterable.iterator(); i.hasNext(); ) {\n                b.append(i.next());\n                while (i.hasNext()) {\n                    b.append(delimiter).append(i.next());\n                }\n            }\n            println(b.toString());\n        }\n    }\n}\n", "test_IO": {"input": ["3 4\n4 3\n4 1\n2 2\n"], "output": ["5\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        MyWriter out = new MyWriter(System.out);\n\n        MyScanner sc = new MyScanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        LinkedList<Integer>[] list = new LinkedList[100001];\n\n        for (int i = 0; i < N; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            if (list[a] == null) {\n                list[a] = new LinkedList<Integer>();\n            }\n            list[a].add(b);\n        }\n\n        int res = 0;\n        PriorityQueue<Integer> pqueue = new PriorityQueue<Integer>(Collections.reverseOrder() );\n        for (int i = 1; i <= M; i++) {\n            if (list[i] != null) {\n                pqueue.addAll(list[i]);\n            }\n            if (!pqueue.isEmpty() ) res += pqueue.poll();\n        }\n\n        out.println(res);\n        out.flush();\n    }\n\n    static final class MyScanner {\n        static final int BUFFER_SIZE = 8192;\n        private final InputStream in;\n        private final byte[] buffer = new byte[BUFFER_SIZE];\n        private int point;\n        private int readLength;\n\n        MyScanner(InputStream in) {\n            this.in = in;\n        }\n\n        private int readByte() {\n            if (point < readLength) {\n                int result = buffer[point];\n                point += 1;\n                return result;\n            }\n            try {\n                readLength = in.read(buffer);\n            } catch (IOException e) {\n                throw new AssertionError(null, e);\n            }\n            if (readLength == -1) {\n                return -1;\n            }\n            point = 1;\n            return buffer[0];\n        }\n\n        private static boolean isPrintableCharExceptSpace(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        String next() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c) ) ) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder b = new StringBuilder();\n            do {\n                b.appendCodePoint(c);\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c) );\n            return b.toString();\n        }\n\n        long nextLong() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c) ) ) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long result = 0L;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                result = result * 10L + (c - '0');\n                c = readByte();\n            } while (c != -1 && isPrintableCharExceptSpace(c) );\n            return minus ? -result : result;\n        }\n\n        int nextInt() {\n            long n = nextLong();\n            if (n < Integer.MIN_VALUE || n > Integer.MAX_VALUE) {\n                throw new InputMismatchException();\n            }\n            return (int) n;\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n\n        int[] nextIntArray(int n) {\n            int[] result = new int[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextInt();\n            }\n            return result;\n        }\n\n        private static boolean allSameLength(int[] a, int[] b, int[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (int[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private static boolean allSameLength(char[] a, char[] b, char[]... c) {\n            if (a.length != b.length) {\n                return false;\n            }\n            for (char[] element : c) {\n                if (a.length != element.length) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        void nextVerticalIntArrays(int[] a, int[] b, int[]... c) {\n            if (!allSameLength(a, b, c) ) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n                b[i] = nextInt();\n                for (int[] d : c) {\n                    d[i] = nextInt();\n                }\n            }\n        }\n\n        long[] nextLongArray(int n) {\n            long[] result = new long[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextLong();\n            }\n            return result;\n        }\n\n        char nextChar() {\n            int c = readByte();\n            while (!(c == -1 || isPrintableCharExceptSpace(c) ) ) {\n                c = readByte();\n            }\n            if (c == -1) {\n                throw new NoSuchElementException();\n            }\n            return (char) c;\n        }\n\n        char[] nextCharArray(int n) {\n            char[] result = new char[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = nextChar();\n            }\n            return result;\n        }\n\n        char[][] next2dCharArray(int n, int m) {\n            char[][] result = new char[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    result[i][j] = nextChar();\n                }\n            }\n            return result;\n        }\n\n        void nextVerticalCharArrays(char[] a, char[] b, char[]... c) {\n            if (!allSameLength(a, b, c) ) {\n                throw new IllegalArgumentException();\n            }\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextChar();\n                b[i] = nextChar();\n                for (char[] d : c) {\n                    d[i] = nextChar();\n                }\n            }\n        }\n    }\n\n    static final class MyWriter extends PrintWriter {\n        MyWriter(OutputStream out) {\n            super(out);\n        }\n\n        void joinAndPrintln(int[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(int[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter).append(x[i]);\n                }\n            }\n            println(b.toString() );\n        }\n\n        void joinAndPrintln(long[] x) {\n            joinAndPrintln(x, \" \");\n        }\n\n        void joinAndPrintln(long[] x, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            if (x.length > 0) {\n                b.append(x[0]);\n                for (int i = 1; i < x.length; i++) {\n                    b.append(delimiter).append(x[i]);\n                }\n            }\n            println(b.toString() );\n        }\n\n        void joinAndPrintln(Iterable<?> iterable) {\n            joinAndPrintln(iterable, \" \");\n        }\n\n        void joinAndPrintln(Iterable<?> iterable, String delimiter) {\n            StringBuilder b = new StringBuilder();\n            for (Iterator<?> i = iterable.iterator(); i.hasNext(); ) {\n                b.append(i.next() );\n                while (i.hasNext() ) {\n                    b.append(delimiter).append(i.next() );\n                }\n            }\n            println(b.toString() );\n        }\n    }\n}\n"}
{"id": "Java/26", "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class SampleSolution {\n\n    static Set<String> ODD = new HashSet<>();\n    static Set<String> EVE = new HashSet<>();\n\n    static {\n        ODD.add(\"R\");\n        ODD.add(\"U\");\n        ODD.add(\"D\");\n        EVE.add(\"L\");\n        EVE.add(\"U\");\n        EVE.add(\"D\");\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String N = sc.nextLine();\n        char[] tap = N.toCharArray();\n\n        boolean isGood = true;\n        for (int i = 0; i < N.length(); i++) {\n            if ((i + 1) % 2 == 0) {\n                if (!isMatch(EVE, tap[i])) {\n                    isGood = false;\n                    break;\n                }\n            } else {\n                if (!isMatch(ODD, tap[i])) {\n                    isGood = false;\n                    break;\n                }\n            }\n        }\n\n        System.out.println(isGood ? \"Yes\" : \"No\");\n    }\n\n    private static boolean isMatch(Set<String> set, char c) {\n        return set.contains(String.valueOf(c));\n    }\n}\n", "test_IO": {"input": ["RUDLUDR\n"], "output": ["Yes\n"]}, "modified_context": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class SampleSolution {\n\n    static Set<String> ODD = new HashSet<>();\n    static Set<String> EVE = new HashSet<>();\n\n    static {\n        ODD.add(\"R\");\n        ODD.add(\"U\");\n        ODD.add(\"D\");\n        EVE.add(\"L\");\n        EVE.add(\"U\");\n        EVE.add(\"D\");\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String N = sc.nextLine();\n        char[] tap = N.toCharArray();\n\n        boolean isGood = true;\n        for (int i = 0; i < N.length(); i++) {\n            if ((i + 1) % 2 == 0) {\n                if (!isMatch(EVE, tap[i]) ) {\n                    isGood = false;\n                    break;\n                }\n            } else {\n                if (!isMatch(ODD, tap[i]) ) {\n                    isGood = false;\n                    break;\n                }\n            }\n        }\n\n        System.out.println(isGood ? \"Yes\" : \"No\");\n    }\n\n    private static boolean isMatch(Set<String> set, char c) {\n        return set.contains(String.valueOf(c) );\n    }\n}\n"}
{"id": "Java/29", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        long k = sc.nextLong();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < s.length(); i++) {\n            if ((26 - (s.charAt(i) - 'a')) <= k && s.charAt(i) != 'a') {\n                k -= 26 - (s.charAt(i) - 'a');\n                sb.append('a');\n            } else {\n                sb.append(s.charAt(i));\n            }\n        }\n        if (k > 0) {\n            char t = sb.charAt(s.length() - 1);\n            sb.delete(s.length() - 1, s.length());\n            sb.append((char) ('a' + (t - 'a' + k) % 26));\n        }\n        System.out.println(sb);\n    }\n}\n", "test_IO": {"input": ["xyz\n4\n"], "output": ["aya\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        long k = sc.nextLong();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < s.length(); i++) {\n            if ((26 - (s.charAt(i) - 'a') ) <= k && s.charAt(i) != 'a') {\n                k -= 26 - (s.charAt(i) - 'a');\n                sb.append('a');\n            } else {\n                sb.append(s.charAt(i) );\n            }\n        }\n        if (k > 0) {\n            char t = sb.charAt(s.length() - 1);\n            sb.delete(s.length() - 1, s.length() );\n            sb.append((char) ('a' + (t - 'a' + k) % 26) );\n        }\n        System.out.println(sb);\n    }\n}\n"}
{"id": "Java/30", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\nclass SampleSolution {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static FastScanner sc = new FastScanner(br);\n    static PrintWriter out = new PrintWriter(System.out);\n    static Random rnd = new Random();\n\n    public static void main(String args[]) throws Exception {\n        int n = sc.nextInt();\n        long[] pre = new long[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1] + sc.nextLong();\n        }\n\n        long min = Long.MAX_VALUE;\n\n        for (int i = 1; i < n; i++) {\n            long val1 = pre[i], val2 = pre[n] - pre[i];\n\n            min = Math.min(min, Math.abs(val1 - val2));\n        }\n\n        out.println(min);\n        out.close();\n    }\n}\n\nclass FastScanner {\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\n    public String getNextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public String next() throws Exception {\n        return getNextToken().toString();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(getNextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(getNextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(getNextToken());\n    }\n}\n", "test_IO": {"input": ["6\n1 2 3 4 5 6\n"], "output": ["1\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.concurrent.*;\n\nclass SampleSolution {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n    static FastScanner sc = new FastScanner(br);\n    static PrintWriter out = new PrintWriter(System.out);\n    static Random rnd = new Random();\n\n    public static void main(String args[]) throws Exception {\n        int n = sc.nextInt();\n        long[] pre = new long[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            pre[i] = pre[i - 1] + sc.nextLong();\n        }\n\n        long min = Long.MAX_VALUE;\n\n        for (int i = 1; i < n; i++) {\n            long val1 = pre[i], val2 = pre[n] - pre[i];\n\n            min = Math.min(min, Math.abs(val1 - val2) );\n        }\n\n        out.println(min);\n        out.close();\n    }\n}\n\nclass FastScanner {\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\n    public String getNextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens() ) {\n            st = new StringTokenizer(in.readLine() );\n        }\n        return st.nextToken();\n    }\n\n    public String next() throws Exception {\n        return getNextToken().toString();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(getNextToken() );\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(getNextToken() );\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(getNextToken() );\n    }\n}\n"}
{"id": "Java/31", "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        try (Scanner scanner = new Scanner(System.in)) {\n            int n = scanner.nextInt();\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, n).forEach(i -> set.add(scanner.nextInt()));\n            System.out.println(set.size());\n        }\n    }\n}\n", "test_IO": {"input": ["4\n10\n8\n8\n6\n"], "output": ["3\n"]}, "modified_context": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        try (Scanner scanner = new Scanner(System.in) ) {\n            int n = scanner.nextInt();\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, n).forEach(i -> set.add(scanner.nextInt() ) );\n            System.out.println(set.size() );\n        }\n    }\n}\n"}
{"id": "Java/32", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(final String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int a = scanner.nextInt(), b = scanner.nextInt();\n        boolean flag = false;\n        for (int i = 1; i <= 100000; i++) {\n            if (Math.floor(1. * i * .08) == a && b == Math.floor(.1 * i)) {\n                System.out.println(i);\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            System.out.println(-1);\n        }\n    }\n}\n", "test_IO": {"input": ["2 2\n"], "output": ["25\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(final String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int a = scanner.nextInt(), b = scanner.nextInt();\n        boolean flag = false;\n        for (int i = 1; i <= 100000; i++) {\n            if (Math.floor(1. * i * .08) == a && b == Math.floor(.1 * i) ) {\n                System.out.println(i);\n                flag = true;\n                break;\n            }\n        }\n        if (!flag) {\n            System.out.println(-1);\n        }\n    }\n}\n"}
{"id": "Java/34", "code": "import java.util.*;\n\npublic class SampleSolution {\n    private static long split(long n, long k) {\n        long sum = 0;\n        while (n > 0) {\n            sum += n % k;\n            n /= k;\n        }\n        return sum;\n    }\n\n    private static long solve(long n, long s) {\n        long k;\n        for (k = 2; k * k <= n || k < 100; k++) {\n            if (split(n, k) == s) {\n                return k;\n            }\n        }\n        while (k <= n) {\n            long a = n / k;\n            long b = n % k;\n            if ((a + b - s) % a == 0) {\n                long dk = (a + b - s) / a;\n                if (dk >= 0 && b - dk * a >= 0) {\n                    return k + dk;\n                }\n            }\n            k = n / a + 1;\n        }\n        if (n == s) {\n            return n + 1;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        long nl = s.nextLong();\n        long sl = s.nextLong();\n        System.out.println(solve(nl, sl));\n    }\n}\n", "test_IO": {"input": ["87654\n30\n"], "output": ["10\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    private static long split(long n, long k) {\n        long sum = 0;\n        while (n > 0) {\n            sum += n % k;\n            n /= k;\n        }\n        return sum;\n    }\n\n    private static long solve(long n, long s) {\n        long k;\n        for (k = 2; k * k <= n || k < 100; k++) {\n            if (split(n, k) == s) {\n                return k;\n            }\n        }\n        while (k <= n) {\n            long a = n / k;\n            long b = n % k;\n            if ((a + b - s) % a == 0) {\n                long dk = (a + b - s) / a;\n                if (dk >= 0 && b - dk * a >= 0) {\n                    return k + dk;\n                }\n            }\n            k = n / a + 1;\n        }\n        if (n == s) {\n            return n + 1;\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        long nl = s.nextLong();\n        long sl = s.nextLong();\n        System.out.println(solve(nl, sl) );\n    }\n}\n"}
{"id": "Java/37", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        int n = sc.nextInt();\n        int[][] arr = new int[n][3];\n        for (int i = 0; i < n; ++i) for (int j = 0; j <= 2; ++j) arr[i][j] = sc.nextInt();\n        int[][] dp = new int[n][3];\n        dp[0][0] = arr[0][0];\n        dp[0][1] = arr[0][1];\n        dp[0][2] = arr[0][2];\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                if (j == 0) dp[i][j] = Math.max(arr[i][0] + dp[i - 1][1], arr[i][0] + dp[i - 1][2]);\n                if (j == 1) dp[i][j] = Math.max(arr[i][1] + dp[i - 1][0], arr[i][1] + dp[i - 1][2]);\n                if (j == 2) dp[i][j] = Math.max(arr[i][2] + dp[i - 1][1], arr[i][2] + dp[i - 1][0]);\n            }\n        }\n        int max = -1;\n        for (int i = 0; i < 3; ++i) if (dp[n - 1][i] > max) max = dp[n - 1][i];\n        System.out.println(max);\n    }\n}\n\nclass sc {\n    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) tokenizer = new StringTokenizer(reader.readLine());\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static float nextFloat() throws IOException {\n        return Float.parseFloat(next());\n    }\n}\n", "test_IO": {"input": ["3\n10 40 70\n20 50 80\n30 60 90\n"], "output": ["210\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        int n = sc.nextInt();\n        int[][] arr = new int[n][3];\n        for (int i = 0; i < n; ++i) for (int j = 0; j <= 2; ++j) arr[i][j] = sc.nextInt();\n        int[][] dp = new int[n][3];\n        dp[0][0] = arr[0][0];\n        dp[0][1] = arr[0][1];\n        dp[0][2] = arr[0][2];\n        for (int i = 1; i < n; ++i) {\n            for (int j = 0; j < 3; ++j) {\n                if (j == 0) dp[i][j] = Math.max(arr[i][0] + dp[i - 1][1], arr[i][0] + dp[i - 1][2]);\n                if (j == 1) dp[i][j] = Math.max(arr[i][1] + dp[i - 1][0], arr[i][1] + dp[i - 1][2]);\n                if (j == 2) dp[i][j] = Math.max(arr[i][2] + dp[i - 1][1], arr[i][2] + dp[i - 1][0]);\n            }\n        }\n        int max = -1;\n        for (int i = 0; i < 3; ++i) if (dp[n - 1][i] > max) max = dp[n - 1][i];\n        System.out.println(max);\n    }\n}\n\nclass sc {\n    static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in) );\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n    static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens() ) tokenizer = new StringTokenizer(reader.readLine() );\n        return tokenizer.nextToken();\n    }\n\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next() );\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next() );\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next() );\n    }\n\n    static float nextFloat() throws IOException {\n        return Float.parseFloat(next() );\n    }\n}\n"}
{"id": "Java/38", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long n = Long.parseLong(sc.nextLine());\n\n        double sqrt = Math.sqrt(n);\n        double nearNum = Math.floor(sqrt);\n\n        long ans = (long) Math.pow(nearNum, 2);\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}\n", "test_IO": {"input": ["10\n"], "output": ["9\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long n = Long.parseLong(sc.nextLine() );\n\n        double sqrt = Math.sqrt(n);\n        double nearNum = Math.floor(sqrt);\n\n        long ans = (long) Math.pow(nearNum, 2);\n\n        System.out.println(ans);\n\n        sc.close();\n    }\n}\n"}
{"id": "Java/41", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int m = sc.nextInt();\n\n        Node tree = null;\n        for (int i = 0; i < m; i++) {\n            String command = sc.next();\n\n            if (command.equals(\"insert\")) {\n                long key = sc.nextLong();\n                if (tree == null) {\n                    tree = new Node();\n                    tree.value = key;\n                } else {\n                    tree.insert(key);\n                }\n            } else {\n                if (tree != null) {\n                    tree.printInOrder();\n                    System.out.println();\n                    tree.printPreOrder();\n                    System.out.println();\n                }\n            }\n        }\n    }\n\n    static class Node {\n        long value;\n        Node left;\n        Node right;\n\n        void insert(long newValue) {\n            if (newValue < this.value) {\n                if (left == null) {\n                    left = new Node();\n                    left.value = newValue;\n                } else {\n                    left.insert(newValue);\n                }\n            } else {\n                if (right == null) {\n                    right = new Node();\n                    right.value = newValue;\n                } else {\n                    right.insert(newValue);\n                }\n            }\n        }\n\n        void printInOrder() {\n            if (left != null) {\n                left.printInOrder();\n            }\n            System.out.print(\" \" + value);\n            if (right != null) {\n                right.printInOrder();\n            }\n        }\n\n        void printPreOrder() {\n            System.out.print(\" \" + value);\n            if (left != null) {\n                left.printPreOrder();\n            }\n            if (right != null) {\n                right.printPreOrder();\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["8\ninsert 30\ninsert 88\ninsert 12\ninsert 1\ninsert 20\ninsert 17\ninsert 25\nprint\n"], "output": [" 1 12 17 20 25 30 88\n 30 12 1 20 17 25 88\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int m = sc.nextInt();\n\n        Node tree = null;\n        for (int i = 0; i < m; i++) {\n            String command = sc.next();\n\n            if (command.equals(\"insert\") ) {\n                long key = sc.nextLong();\n                if (tree == null) {\n                    tree = new Node();\n                    tree.value = key;\n                } else {\n                    tree.insert(key);\n                }\n            } else {\n                if (tree != null) {\n                    tree.printInOrder();\n                    System.out.println();\n                    tree.printPreOrder();\n                    System.out.println();\n                }\n            }\n        }\n    }\n\n    static class Node {\n        long value;\n        Node left;\n        Node right;\n\n        void insert(long newValue) {\n            if (newValue < this.value) {\n                if (left == null) {\n                    left = new Node();\n                    left.value = newValue;\n                } else {\n                    left.insert(newValue);\n                }\n            } else {\n                if (right == null) {\n                    right = new Node();\n                    right.value = newValue;\n                } else {\n                    right.insert(newValue);\n                }\n            }\n        }\n\n        void printInOrder() {\n            if (left != null) {\n                left.printInOrder();\n            }\n            System.out.print(\" \" + value);\n            if (right != null) {\n                right.printInOrder();\n            }\n        }\n\n        void printPreOrder() {\n            System.out.print(\" \" + value);\n            if (left != null) {\n                left.printPreOrder();\n            }\n            if (right != null) {\n                right.printPreOrder();\n            }\n        }\n    }\n}\n"}
{"id": "Java/42", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    private static final int BASE = 3;\n\n    public static void main(String[] args) {\n        System.out.println((int) Math.pow(new Scanner(System.in).nextInt(), BASE));\n    }\n}\n", "test_IO": {"input": ["2\n"], "output": ["8\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    private static final int BASE = 3;\n\n    public static void main(String[] args) {\n        System.out.println((int) Math.pow(new Scanner(System.in).nextInt(), BASE) );\n    }\n}\n"}
{"id": "Java/43", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        SampleSolution main = new SampleSolution();\n        main.solve();\n    }\n\n    private void solve() {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int[][] c = new int[10][10];\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                c[i][j] = sc.nextInt();\n            }\n        }\n        int[] min = new int[10];\n        for (int i = 0; i < 10; i++) {\n            min[i] = c[i][1];\n        }\n        for (int tc = 0; tc < 10; tc++) {\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    min[i] = Math.min(min[i], c[i][j] + min[j]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int h = 1; h <= H; h++) {\n            for (int w = 1; w <= W; w++) {\n                int A = sc.nextInt();\n                if (A >= 0) {\n                    ans += min[A];\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    class Scanner {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int index;\n        private int length;\n\n        public Scanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return '!' <= c && c <= '~';\n        }\n\n        private boolean isDigit(int c) {\n            return '0' <= c && c <= '9';\n        }\n\n        private boolean hasNextByte() {\n            if (index < length) {\n                return true;\n            } else {\n                try {\n                    length = in.read(buffer);\n                    index = 0;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return length > 0;\n            }\n        }\n\n        private boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[index])) {\n                index++;\n            }\n            return hasNextByte();\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[index++] : -1;\n        }\n\n        public String next() {\n            if (!hasNext()) {\n                throw new RuntimeException(\"no input\");\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) {\n                throw new RuntimeException(\"no input\");\n            }\n            long value = 0L;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (isPrintableChar(b)) {\n                if (isDigit(b)) {\n                    value = value * 10 + (b - '0');\n                }\n                b = readByte();\n            }\n            return minus ? -value : value;\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    interface CombCalculator {\n        long comb(int n, int m);\n    }\n\n    interface MobiusFunction {\n        int get(int n);\n    }\n\n    class SieveMobiusFunction implements MobiusFunction {\n        int size;\n        int[] mobiusFunctionValues;\n\n        public SieveMobiusFunction(int size) {\n            this.size = size;\n            mobiusFunctionValues = new int[size];\n\n            mobiusFunctionValues[0] = 0;\n            mobiusFunctionValues[1] = 1;\n            for (int i = 2; i < size; i++) {\n                mobiusFunctionValues[i] = 1;\n            }\n            for (int i = 2; i * i < size; i++) {\n                for (int k = 1; i * i * k < size; k++) {\n                    mobiusFunctionValues[i * i * k] *= 0;\n                }\n            }\n\n            for (int i = 2; i < size; i++) {\n                if (mobiusFunctionValues[i] == 1) {\n                    for (int k = 1; i * k < size; k++) {\n                        mobiusFunctionValues[i * k] *= -2;\n                    }\n                }\n                if (mobiusFunctionValues[i] > 1) {\n                    mobiusFunctionValues[i] = 1;\n                }\n                if (mobiusFunctionValues[i] < -1) {\n                    mobiusFunctionValues[i] = -1;\n                }\n            }\n        }\n\n        @Override\n        public int get(int n) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0) {\n                return 0;\n            }\n            return mobiusFunctionValues[n];\n        }\n    }\n\n    class PrimeFactorizationMobiusFunction implements MobiusFunction {\n        @Override\n        public int get(int n) {\n            if (n <= 0) {\n                return 0;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            int num = 0;\n            for (int i = 2; i < n; i++) {\n                if (n % i == 0) {\n                    n /= i;\n                    num++;\n                    if (n % i == 0) {\n                        return 0;\n                    }\n                }\n            }\n            return num % 2 == 0 ? -1 : 1;\n        }\n    }\n\n    class FactorialTableCombCalculator implements CombCalculator {\n        int size;\n        long[] factorialTable;\n        long[] inverseFactorialTable;\n        long mod;\n\n        public FactorialTableCombCalculator(int size, long mod) {\n            this.size = size;\n            factorialTable = new long[size + 1];\n            inverseFactorialTable = new long[size + 1];\n            this.mod = mod;\n\n            factorialTable[0] = 1L;\n            for (int i = 1; i <= size; i++) {\n                factorialTable[i] = (factorialTable[i - 1] * i) % mod;\n            }\n            inverseFactorialTable[size] = inverse(factorialTable[size], mod);\n            for (int i = size - 1; i >= 0; i--) {\n                inverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1)) % mod;\n            }\n        }\n\n        private long inverse(long n, long mod) {\n            return pow(n, mod - 2, mod);\n        }\n\n        private long pow(long n, long p, long mod) {\n            if (p == 0) {\n                return 1L;\n            }\n            long half = pow(n, p / 2, mod);\n            long ret = (half * half) % mod;\n            if (p % 2 == 1) {\n                ret = (ret * n) % mod;\n            }\n            return ret;\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return (((factorialTable[n] * inverseFactorialTable[m]) % mod)\n                            * inverseFactorialTable[n - m])\n                    % mod;\n        }\n    }\n\n    class TableCombCalculator implements CombCalculator {\n        long[][] table;\n        int size;\n\n        public TableCombCalculator(int size, long mod) {\n            this.size = size;\n            table = new long[size + 1][];\n\n            table[0] = new long[1];\n            table[0][0] = 1L;\n            for (int n = 1; n <= size; n++) {\n                table[n] = new long[n + 1];\n                table[n][0] = 1L;\n                for (int m = 1; m < n; m++) {\n                    table[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n                }\n                table[n][n] = 1L;\n            }\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return table[n][m];\n        }\n    }\n\n    interface Graph {\n        void link(int from, int to, long cost);\n\n        Optional<Long> getCost(int from, int to);\n\n        int getVertexNum();\n    }\n\n    interface FlowResolver {\n        long maxFlow(int from, int to);\n    }\n\n    class ArrayGraph implements Graph {\n        private Long[][] costArray;\n        private int vertexNum;\n\n        public ArrayGraph(int n) {\n            costArray = new Long[n][];\n            for (int i = 0; i < n; i++) {\n                costArray[i] = new Long[n];\n            }\n            vertexNum = n;\n        }\n\n        @Override\n        public void link(int from, int to, long cost) {\n            costArray[from][to] = new Long(cost);\n        }\n\n        @Override\n        public Optional<Long> getCost(int from, int to) {\n            return Optional.ofNullable(costArray[from][to]);\n        }\n\n        @Override\n        public int getVertexNum() {\n            return vertexNum;\n        }\n    }\n\n    class DfsFlowResolver implements FlowResolver {\n        private Graph graph;\n\n        public DfsFlowResolver(Graph graph) {\n            this.graph = graph;\n        }\n\n        public long maxFlow(int from, int to) {\n            long sum = 0L;\n            long currentFlow;\n            do {\n                currentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n                sum += currentFlow;\n            } while (currentFlow > 0);\n            return sum;\n        }\n\n        private long flow(int from, int to, long current_flow, boolean[] passed) {\n            passed[from] = true;\n            if (from == to) {\n                return current_flow;\n            }\n            for (int id = 0; id < graph.getVertexNum(); id++) {\n                if (passed[id]) {\n                    continue;\n                }\n                Optional<Long> cost = graph.getCost(from, id);\n                if (cost.orElse(0L) > 0) {\n                    long nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n                    long returnFlow = flow(id, to, nextFlow, passed);\n                    if (returnFlow > 0) {\n                        graph.link(from, id, cost.get() - returnFlow);\n                        graph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n                        return returnFlow;\n                    }\n                }\n            }\n            return 0L;\n        }\n    }\n\n    class BinaryIndexedTree {\n        private long[] array;\n\n        public BinaryIndexedTree(int size) {\n            this.array = new long[size + 1];\n        }\n\n        public void add(int index, long value) {\n            for (int i = index; i < array.length; i += (i & -i)) {\n                array[i] += value;\n            }\n        }\n\n        public long getSum(int index) {\n            long sum = 0L;\n            for (int i = index; i > 0; i -= (i & -i)) {\n                sum += array[i];\n            }\n            return sum;\n        }\n    }\n\n    class BinaryIndexedTree2D {\n        private long[][] array;\n\n        public BinaryIndexedTree2D(int size1, int size2) {\n            this.array = new long[size1 + 1][];\n            for (int i = 1; i <= size1; i++) {\n                this.array[i] = new long[size2 + 1];\n            }\n        }\n\n        public void add(int index1, int index2, long value) {\n            for (int i1 = index1; i1 < array.length; i1 += (i1 & -i1)) {\n                for (int i2 = index2; i2 < array.length; i2 += (i2 & -i2)) {\n                    array[i1][i2] += value;\n                }\n            }\n        }\n\n        public long getSum(int index1, int index2) {\n            long sum = 0L;\n            for (int i1 = index1; i1 > 0; i1 -= (i1 & -i1)) {\n                for (int i2 = index2; i2 > 0; i2 -= (i2 & -i2)) {\n                    sum += array[i1][i2];\n                }\n            }\n            return sum;\n        }\n    }\n\n    interface UnionFind {\n        void union(int A, int B);\n\n        boolean judge(int A, int B);\n\n        Set<Integer> getSet(int id);\n    }\n\n    class SetUnionFind extends ArrayUnionFind {\n        Map<Integer, Set<Integer>> map;\n\n        public SetUnionFind(int size) {\n            super(size);\n            map = new HashMap<>();\n            for (int i = 0; i < size; i++) {\n                map.put(i, new HashSet<>());\n                map.get(i).add(i);\n            }\n        }\n\n        @Override\n        protected void unionTo(int source, int dest) {\n            super.unionTo(source, dest);\n            map.get(dest).addAll(map.get(source));\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            return map.get(root(id));\n        }\n    }\n\n    class ArrayUnionFind implements UnionFind {\n        int[] parent;\n        int[] rank;\n        int size;\n\n        public ArrayUnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n            rank = new int[size];\n            this.size = size;\n        }\n\n        @Override\n        public void union(int A, int B) {\n            int rootA = root(A);\n            int rootB = root(B);\n            if (rootA != rootB) {\n                if (rank[rootA] < rank[rootB]) {\n                    unionTo(rootA, rootB);\n                } else {\n                    unionTo(rootB, rootA);\n                    if (rank[rootA] == rank[rootB]) {\n                        rank[rootA]++;\n                    }\n                }\n            }\n        }\n\n        protected void unionTo(int source, int dest) {\n            parent[source] = dest;\n        }\n\n        @Override\n        public boolean judge(int A, int B) {\n            return root(A) == root(B);\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, size).filter(i -> judge(i, id)).forEach(set::add);\n            return set;\n        }\n\n        protected int root(int id) {\n            if (parent[id] == id) {\n                return id;\n            }\n            parent[id] = root(parent[id]);\n            return parent[id];\n        }\n    }\n\n    class PrimeNumberUtils {\n        boolean[] isPrimeArray;\n        List<Integer> primes;\n\n        public PrimeNumberUtils(int limit) {\n            if (limit > 10000000) {\n                System.err.println(\"The upper limit value is too high, so there is a very high possibility that the prime number utility initialization will result in TLE (Time Limit Exceeded)\");\n            }\n            primes = new ArrayList<>();\n            isPrimeArray = new boolean[limit];\n            if (limit > 2) {\n                primes.add(2);\n                isPrimeArray[2] = true;\n            }\n\n            for (int i = 3; i < limit; i += 2) {\n                if (isPrime(i, primes)) {\n                    primes.add(i);\n                    isPrimeArray[i] = true;\n                }\n            }\n        }\n\n        public List<Integer> getPrimeNumberList() {\n            return primes;\n        }\n\n        public boolean isPrime(int n) {\n            return isPrimeArray[n];\n        }\n\n        private boolean isPrime(int n, List<Integer> primes) {\n            for (int prime : primes) {\n                if (n % prime == 0) {\n                    return false;\n                }\n                if (prime > Math.sqrt(n)) {\n                    break;\n                }\n            }\n            return true;\n        }\n    }\n\n    interface BitSet {\n        void set(int index, boolean bit);\n\n        boolean get(int index);\n\n        void shiftRight(int num);\n\n        void shiftLeft(int num);\n\n        void or(BitSet bitset);\n\n        void and(BitSet bitset);\n    }\n\n    class LongBit implements BitSet {\n        long[] bitArray;\n\n        public LongBit(int size) {\n            bitArray = new long[((size + 63) / 64)];\n        }\n\n        @Override\n        public void set(int index, boolean bit) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            if (bit) {\n                bitArray[segment] |= 1L << inIndex;\n            } else {\n                bitArray[segment] &= ~(1L << inIndex);\n            }\n        }\n\n        @Override\n        public boolean get(int index) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            return (bitArray[segment] & (1L << inIndex)) != 0L;\n        }\n\n        @Override\n        public void shiftRight(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                int sourceSeg = segment + shiftSeg;\n                if (sourceSeg < bitArray.length) {\n                    bitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n                    if (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n                        bitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        @Override\n        public void shiftLeft(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = bitArray.length - 1; segment >= 0; segment--) {\n                int sourceSeg = segment - shiftSeg;\n                if (sourceSeg >= 0) {\n                    bitArray[segment] = bitArray[sourceSeg] << shiftInI;\n                    if (shiftInI > 0 && sourceSeg > 0) {\n                        bitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        public long getLong(int segment) {\n            return bitArray[segment];\n        }\n\n        @Override\n        public void or(BitSet bitset) {\n            if (!(bitset instanceof LongBit)) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] |= ((LongBit) bitset).getLong(segment);\n            }\n        }\n\n        @Override\n        public void and(BitSet bitset) {\n            if (!(bitset instanceof LongBit)) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] &= ((LongBit) bitset).getLong(segment);\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["2 4\n0 9 9 9 9 9 9 9 9 9\n9 0 9 9 9 9 9 9 9 9\n9 9 0 9 9 9 9 9 9 9\n9 9 9 0 9 9 9 9 9 9\n9 9 9 9 0 9 9 9 9 2\n9 9 9 9 9 0 9 9 9 9\n9 9 9 9 9 9 0 9 9 9\n9 9 9 9 9 9 9 0 9 9\n9 9 9 9 2 9 9 9 0 9\n9 2 9 9 9 9 9 9 9 0\n-1 -1 -1 -1\n8 1 1 8\n"], "output": ["12\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.stream.IntStream;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        SampleSolution main = new SampleSolution();\n        main.solve();\n    }\n\n    private void solve() {\n        Scanner sc = new Scanner(System.in);\n        int H = sc.nextInt();\n        int W = sc.nextInt();\n        int[][] c = new int[10][10];\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                c[i][j] = sc.nextInt();\n            }\n        }\n        int[] min = new int[10];\n        for (int i = 0; i < 10; i++) {\n            min[i] = c[i][1];\n        }\n        for (int tc = 0; tc < 10; tc++) {\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    min[i] = Math.min(min[i], c[i][j] + min[j]);\n                }\n            }\n        }\n        int ans = 0;\n        for (int h = 1; h <= H; h++) {\n            for (int w = 1; w <= W; w++) {\n                int A = sc.nextInt();\n                if (A >= 0) {\n                    ans += min[A];\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    class Scanner {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int index;\n        private int length;\n\n        public Scanner(InputStream in) {\n            this.in = in;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return '!' <= c && c <= '~';\n        }\n\n        private boolean isDigit(int c) {\n            return '0' <= c && c <= '9';\n        }\n\n        private boolean hasNextByte() {\n            if (index < length) {\n                return true;\n            } else {\n                try {\n                    length = in.read(buffer);\n                    index = 0;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                return length > 0;\n            }\n        }\n\n        private boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[index]) ) {\n                index++;\n            }\n            return hasNextByte();\n        }\n\n        private int readByte() {\n            return hasNextByte() ? buffer[index++] : -1;\n        }\n\n        public String next() {\n            if (!hasNext() ) {\n                throw new RuntimeException(\"no input\");\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b) ) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext() ) {\n                throw new RuntimeException(\"no input\");\n            }\n            long value = 0L;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (isPrintableChar(b) ) {\n                if (isDigit(b) ) {\n                    value = value * 10 + (b - '0');\n                }\n                b = readByte();\n            }\n            return minus ? -value : value;\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n    }\n\n    interface CombCalculator {\n        long comb(int n, int m);\n    }\n\n    interface MobiusFunction {\n        int get(int n);\n    }\n\n    class SieveMobiusFunction implements MobiusFunction {\n        int size;\n        int[] mobiusFunctionValues;\n\n        public SieveMobiusFunction(int size) {\n            this.size = size;\n            mobiusFunctionValues = new int[size];\n\n            mobiusFunctionValues[0] = 0;\n            mobiusFunctionValues[1] = 1;\n            for (int i = 2; i < size; i++) {\n                mobiusFunctionValues[i] = 1;\n            }\n            for (int i = 2; i * i < size; i++) {\n                for (int k = 1; i * i * k < size; k++) {\n                    mobiusFunctionValues[i * i * k] *= 0;\n                }\n            }\n\n            for (int i = 2; i < size; i++) {\n                if (mobiusFunctionValues[i] == 1) {\n                    for (int k = 1; i * k < size; k++) {\n                        mobiusFunctionValues[i * k] *= -2;\n                    }\n                }\n                if (mobiusFunctionValues[i] > 1) {\n                    mobiusFunctionValues[i] = 1;\n                }\n                if (mobiusFunctionValues[i] < -1) {\n                    mobiusFunctionValues[i] = -1;\n                }\n            }\n        }\n\n        @Override\n        public int get(int n) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0) {\n                return 0;\n            }\n            return mobiusFunctionValues[n];\n        }\n    }\n\n    class PrimeFactorizationMobiusFunction implements MobiusFunction {\n        @Override\n        public int get(int n) {\n            if (n <= 0) {\n                return 0;\n            }\n            if (n == 1) {\n                return 1;\n            }\n            int num = 0;\n            for (int i = 2; i < n; i++) {\n                if (n % i == 0) {\n                    n /= i;\n                    num++;\n                    if (n % i == 0) {\n                        return 0;\n                    }\n                }\n            }\n            return num % 2 == 0 ? -1 : 1;\n        }\n    }\n\n    class FactorialTableCombCalculator implements CombCalculator {\n        int size;\n        long[] factorialTable;\n        long[] inverseFactorialTable;\n        long mod;\n\n        public FactorialTableCombCalculator(int size, long mod) {\n            this.size = size;\n            factorialTable = new long[size + 1];\n            inverseFactorialTable = new long[size + 1];\n            this.mod = mod;\n\n            factorialTable[0] = 1L;\n            for (int i = 1; i <= size; i++) {\n                factorialTable[i] = (factorialTable[i - 1] * i) % mod;\n            }\n            inverseFactorialTable[size] = inverse(factorialTable[size], mod);\n            for (int i = size - 1; i >= 0; i--) {\n                inverseFactorialTable[i] = (inverseFactorialTable[i + 1] * (i + 1) ) % mod;\n            }\n        }\n\n        private long inverse(long n, long mod) {\n            return pow(n, mod - 2, mod);\n        }\n\n        private long pow(long n, long p, long mod) {\n            if (p == 0) {\n                return 1L;\n            }\n            long half = pow(n, p / 2, mod);\n            long ret = (half * half) % mod;\n            if (p % 2 == 1) {\n                ret = (ret * n) % mod;\n            }\n            return ret;\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return (((factorialTable[n] * inverseFactorialTable[m]) % mod)\n                            * inverseFactorialTable[n - m])\n                    % mod;\n        }\n    }\n\n    class TableCombCalculator implements CombCalculator {\n        long[][] table;\n        int size;\n\n        public TableCombCalculator(int size, long mod) {\n            this.size = size;\n            table = new long[size + 1][];\n\n            table[0] = new long[1];\n            table[0][0] = 1L;\n            for (int n = 1; n <= size; n++) {\n                table[n] = new long[n + 1];\n                table[n][0] = 1L;\n                for (int m = 1; m < n; m++) {\n                    table[n][m] = (table[n - 1][m - 1] + table[n - 1][m]) % mod;\n                }\n                table[n][n] = 1L;\n            }\n        }\n\n        @Override\n        public long comb(int n, int m) {\n            if (n > size) {\n                throw new RuntimeException(\"n is greater than size.\");\n            }\n            if (n < 0 || m < 0 || n < m) {\n                return 0L;\n            }\n            return table[n][m];\n        }\n    }\n\n    interface Graph {\n        void link(int from, int to, long cost);\n\n        Optional<Long> getCost(int from, int to);\n\n        int getVertexNum();\n    }\n\n    interface FlowResolver {\n        long maxFlow(int from, int to);\n    }\n\n    class ArrayGraph implements Graph {\n        private Long[][] costArray;\n        private int vertexNum;\n\n        public ArrayGraph(int n) {\n            costArray = new Long[n][];\n            for (int i = 0; i < n; i++) {\n                costArray[i] = new Long[n];\n            }\n            vertexNum = n;\n        }\n\n        @Override\n        public void link(int from, int to, long cost) {\n            costArray[from][to] = new Long(cost);\n        }\n\n        @Override\n        public Optional<Long> getCost(int from, int to) {\n            return Optional.ofNullable(costArray[from][to]);\n        }\n\n        @Override\n        public int getVertexNum() {\n            return vertexNum;\n        }\n    }\n\n    class DfsFlowResolver implements FlowResolver {\n        private Graph graph;\n\n        public DfsFlowResolver(Graph graph) {\n            this.graph = graph;\n        }\n\n        public long maxFlow(int from, int to) {\n            long sum = 0L;\n            long currentFlow;\n            do {\n                currentFlow = flow(from, to, Long.MAX_VALUE / 3, new boolean[graph.getVertexNum()]);\n                sum += currentFlow;\n            } while (currentFlow > 0);\n            return sum;\n        }\n\n        private long flow(int from, int to, long current_flow, boolean[] passed) {\n            passed[from] = true;\n            if (from == to) {\n                return current_flow;\n            }\n            for (int id = 0; id < graph.getVertexNum(); id++) {\n                if (passed[id]) {\n                    continue;\n                }\n                Optional<Long> cost = graph.getCost(from, id);\n                if (cost.orElse(0L) > 0) {\n                    long nextFlow = current_flow < cost.get() ? current_flow : cost.get();\n                    long returnFlow = flow(id, to, nextFlow, passed);\n                    if (returnFlow > 0) {\n                        graph.link(from, id, cost.get() - returnFlow);\n                        graph.link(id, from, graph.getCost(id, from).orElse(0L) + returnFlow);\n                        return returnFlow;\n                    }\n                }\n            }\n            return 0L;\n        }\n    }\n\n    class BinaryIndexedTree {\n        private long[] array;\n\n        public BinaryIndexedTree(int size) {\n            this.array = new long[size + 1];\n        }\n\n        public void add(int index, long value) {\n            for (int i = index; i < array.length; i += (i & -i) ) {\n                array[i] += value;\n            }\n        }\n\n        public long getSum(int index) {\n            long sum = 0L;\n            for (int i = index; i > 0; i -= (i & -i) ) {\n                sum += array[i];\n            }\n            return sum;\n        }\n    }\n\n    class BinaryIndexedTree2D {\n        private long[][] array;\n\n        public BinaryIndexedTree2D(int size1, int size2) {\n            this.array = new long[size1 + 1][];\n            for (int i = 1; i <= size1; i++) {\n                this.array[i] = new long[size2 + 1];\n            }\n        }\n\n        public void add(int index1, int index2, long value) {\n            for (int i1 = index1; i1 < array.length; i1 += (i1 & -i1) ) {\n                for (int i2 = index2; i2 < array.length; i2 += (i2 & -i2) ) {\n                    array[i1][i2] += value;\n                }\n            }\n        }\n\n        public long getSum(int index1, int index2) {\n            long sum = 0L;\n            for (int i1 = index1; i1 > 0; i1 -= (i1 & -i1) ) {\n                for (int i2 = index2; i2 > 0; i2 -= (i2 & -i2) ) {\n                    sum += array[i1][i2];\n                }\n            }\n            return sum;\n        }\n    }\n\n    interface UnionFind {\n        void union(int A, int B);\n\n        boolean judge(int A, int B);\n\n        Set<Integer> getSet(int id);\n    }\n\n    class SetUnionFind extends ArrayUnionFind {\n        Map<Integer, Set<Integer>> map;\n\n        public SetUnionFind(int size) {\n            super(size);\n            map = new HashMap<>();\n            for (int i = 0; i < size; i++) {\n                map.put(i, new HashSet<>() );\n                map.get(i).add(i);\n            }\n        }\n\n        @Override\n        protected void unionTo(int source, int dest) {\n            super.unionTo(source, dest);\n            map.get(dest).addAll(map.get(source) );\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            return map.get(root(id) );\n        }\n    }\n\n    class ArrayUnionFind implements UnionFind {\n        int[] parent;\n        int[] rank;\n        int size;\n\n        public ArrayUnionFind(int size) {\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n            rank = new int[size];\n            this.size = size;\n        }\n\n        @Override\n        public void union(int A, int B) {\n            int rootA = root(A);\n            int rootB = root(B);\n            if (rootA != rootB) {\n                if (rank[rootA] < rank[rootB]) {\n                    unionTo(rootA, rootB);\n                } else {\n                    unionTo(rootB, rootA);\n                    if (rank[rootA] == rank[rootB]) {\n                        rank[rootA]++;\n                    }\n                }\n            }\n        }\n\n        protected void unionTo(int source, int dest) {\n            parent[source] = dest;\n        }\n\n        @Override\n        public boolean judge(int A, int B) {\n            return root(A) == root(B);\n        }\n\n        @Override\n        public Set<Integer> getSet(int id) {\n            Set<Integer> set = new HashSet<>();\n            IntStream.range(0, size).filter(i -> judge(i, id) ).forEach(set::add);\n            return set;\n        }\n\n        protected int root(int id) {\n            if (parent[id] == id) {\n                return id;\n            }\n            parent[id] = root(parent[id]);\n            return parent[id];\n        }\n    }\n\n    class PrimeNumberUtils {\n        boolean[] isPrimeArray;\n        List<Integer> primes;\n\n        public PrimeNumberUtils(int limit) {\n            if (limit > 10000000) {\n                System.err.println(\"The upper limit value is too high, so there is a very high possibility that the prime number utility initialization will result in TLE (Time Limit Exceeded)\");\n            }\n            primes = new ArrayList<>();\n            isPrimeArray = new boolean[limit];\n            if (limit > 2) {\n                primes.add(2);\n                isPrimeArray[2] = true;\n            }\n\n            for (int i = 3; i < limit; i += 2) {\n                if (isPrime(i, primes) ) {\n                    primes.add(i);\n                    isPrimeArray[i] = true;\n                }\n            }\n        }\n\n        public List<Integer> getPrimeNumberList() {\n            return primes;\n        }\n\n        public boolean isPrime(int n) {\n            return isPrimeArray[n];\n        }\n\n        private boolean isPrime(int n, List<Integer> primes) {\n            for (int prime : primes) {\n                if (n % prime == 0) {\n                    return false;\n                }\n                if (prime > Math.sqrt(n) ) {\n                    break;\n                }\n            }\n            return true;\n        }\n    }\n\n    interface BitSet {\n        void set(int index, boolean bit);\n\n        boolean get(int index);\n\n        void shiftRight(int num);\n\n        void shiftLeft(int num);\n\n        void or(BitSet bitset);\n\n        void and(BitSet bitset);\n    }\n\n    class LongBit implements BitSet {\n        long[] bitArray;\n\n        public LongBit(int size) {\n            bitArray = new long[((size + 63) / 64)];\n        }\n\n        @Override\n        public void set(int index, boolean bit) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            if (bit) {\n                bitArray[segment] |= 1L << inIndex;\n            } else {\n                bitArray[segment] &= ~(1L << inIndex);\n            }\n        }\n\n        @Override\n        public boolean get(int index) {\n            int segment = index / 64;\n            int inIndex = index % 64;\n            return (bitArray[segment] & (1L << inIndex) ) != 0L;\n        }\n\n        @Override\n        public void shiftRight(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                int sourceSeg = segment + shiftSeg;\n                if (sourceSeg < bitArray.length) {\n                    bitArray[segment] = bitArray[sourceSeg] >>> shiftInI;\n                    if (shiftInI > 0 && sourceSeg + 1 < bitArray.length) {\n                        bitArray[segment] |= bitArray[sourceSeg + 1] << (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        @Override\n        public void shiftLeft(int num) {\n            int shiftSeg = num / 64;\n            int shiftInI = num % 64;\n            for (int segment = bitArray.length - 1; segment >= 0; segment--) {\n                int sourceSeg = segment - shiftSeg;\n                if (sourceSeg >= 0) {\n                    bitArray[segment] = bitArray[sourceSeg] << shiftInI;\n                    if (shiftInI > 0 && sourceSeg > 0) {\n                        bitArray[segment] |= bitArray[sourceSeg - 1] >>> (64 - shiftInI);\n                    }\n                } else {\n                    bitArray[segment] = 0L;\n                }\n            }\n        }\n\n        public long getLong(int segment) {\n            return bitArray[segment];\n        }\n\n        @Override\n        public void or(BitSet bitset) {\n            if (!(bitset instanceof LongBit) ) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] |= ((LongBit) bitset).getLong(segment);\n            }\n        }\n\n        @Override\n        public void and(BitSet bitset) {\n            if (!(bitset instanceof LongBit) ) {\n                return;\n            }\n            for (int segment = 0; segment < bitArray.length; segment++) {\n                bitArray[segment] &= ((LongBit) bitset).getLong(segment);\n            }\n        }\n    }\n}\n"}
{"id": "Java/44", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            queue.add(sc.nextInt());\n        }\n        int sum = 0;\n        for (int i = 0; i < n - 1; i++) {\n            sum += queue.poll();\n        }\n\n        System.out.println(queue.poll() < sum ? \"Yes\" : \"No\");\n    }\n}\n", "test_IO": {"input": ["4\n3 8 5 1\n"], "output": ["Yes\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        PriorityQueue<Integer> queue = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            queue.add(sc.nextInt() );\n        }\n        int sum = 0;\n        for (int i = 0; i < n - 1; i++) {\n            sum += queue.poll();\n        }\n\n        System.out.println(queue.poll() < sum ? \"Yes\" : \"No\");\n    }\n}\n"}
{"id": "Java/45", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws Exception {\n\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n\n        String begin;\n        String end;\n        String answer;\n\n        for (int i = 0; i < S.length(); i++) {\n\n            for (int j = 0; j < S.length(); j++) {\n\n                begin = S.substring(0, i);\n                end = S.substring(j, S.length());\n                answer = begin + end;\n\n                if (answer.equals(\"keyence\")) {\n                    System.out.println(\"YES\");\n                    return;\n\n                } else if (begin.equals(\"keyence\")) {\n                    System.out.println(\"YES\");\n                    return;\n\n                } else if (end.equals(\"keyence\")) {\n                    System.out.println(\"YES\");\n                    return;\n                }\n            }\n        }\n        System.out.println(\"NO\");\n    }\n}\n", "test_IO": {"input": ["keyofscience\n"], "output": ["YES\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws Exception {\n\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n\n        String begin;\n        String end;\n        String answer;\n\n        for (int i = 0; i < S.length(); i++) {\n\n            for (int j = 0; j < S.length(); j++) {\n\n                begin = S.substring(0, i);\n                end = S.substring(j, S.length() );\n                answer = begin + end;\n\n                if (answer.equals(\"keyence\") ) {\n                    System.out.println(\"YES\");\n                    return;\n\n                } else if (begin.equals(\"keyence\") ) {\n                    System.out.println(\"YES\");\n                    return;\n\n                } else if (end.equals(\"keyence\") ) {\n                    System.out.println(\"YES\");\n                    return;\n                }\n            }\n        }\n        System.out.println(\"NO\");\n    }\n}\n"}
{"id": "Java/46", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    @SuppressWarnings(\"resource\")\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        long ans = 1;\n        int mod = (int) Math.pow(10, 9) + 7;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 2; (i % j != 0 && j < i) || j == i; j++) {\n                if (j == i) {\n                    int s = 0;\n                    for (int k = 1; k <= n; k++) {\n                        s += findS(k, i);\n                    }\n\n                    ans = (ans * (s + 1)) % mod;\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    private static int findS(int k, int i) {\n        int s = 0;\n        for (int j = k; j % i == 0; j /= i) {\n\n            s++;\n        }\n        return s;\n    }\n}\n", "test_IO": {"input": ["3\n"], "output": ["4\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    @SuppressWarnings(\"resource\")\n    public static void main(String args[]) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        long ans = 1;\n        int mod = (int) Math.pow(10, 9) + 7;\n        for (int i = 2; i <= n; i++) {\n            for (int j = 2; (i % j != 0 && j < i) || j == i; j++) {\n                if (j == i) {\n                    int s = 0;\n                    for (int k = 1; k <= n; k++) {\n                        s += findS(k, i);\n                    }\n\n                    ans = (ans * (s + 1) ) % mod;\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n\n    private static int findS(int k, int i) {\n        int s = 0;\n        for (int j = k; j % i == 0; j /= i) {\n\n            s++;\n        }\n        return s;\n    }\n}\n"}
{"id": "Java/48", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        IntegralRect rects[] = new IntegralRect[40000];\n        for (int i = 0; i < 200; i++) {\n            for (int j = 0; j < 200; j++) {\n                rects[i * 200 + j] = new IntegralRect(i + 1, j + 1);\n            }\n        }\n        Arrays.sort(rects);\n\n        while (true) {\n            String[] tmpArray = br.readLine().split(\" \");\n\n            int h = Integer.parseInt(tmpArray[0]);\n            int w = Integer.parseInt(tmpArray[1]);\n\n            if (h == 0 && w == 0) {\n                break;\n            }\n\n            IntegralRect tmpRect = new IntegralRect(h, w);\n            int diag = tmpRect.diagonal();\n\n            for (int i = 0; i < rects.length; i++) {\n\n                if (rects[i].compareTo(tmpRect) > 0) {\n                    System.out.println(rects[i].height + \" \" + rects[i].width);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nclass IntegralRect implements Comparable<IntegralRect> {\n    int height;\n    int width;\n\n    public IntegralRect(int h, int w) {\n        this.height = h;\n        this.width = w;\n    }\n\n    public int diagonal() {\n        if (height >= width) {\n            return Integer.MAX_VALUE;\n        }\n        return this.height * this.height + this.width * this.width;\n    }\n\n    @Override\n    public int compareTo(IntegralRect o) {\n\n        int d1 = this.diagonal();\n        int d2 = o.diagonal();\n\n        return d1 == d2 ? this.height - o.height : d1 - d2;\n    }\n}\n", "test_IO": {"input": ["1 2\n1 3\n2 3\n1 4\n2 4\n5 6\n1 8\n4 7\n98 100\n99 100\n0 0\n"], "output": ["1 3\n2 3\n1 4\n2 4\n3 4\n1 8\n4 7\n2 8\n3 140\n89 109\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n\n        IntegralRect rects[] = new IntegralRect[40000];\n        for (int i = 0; i < 200; i++) {\n            for (int j = 0; j < 200; j++) {\n                rects[i * 200 + j] = new IntegralRect(i + 1, j + 1);\n            }\n        }\n        Arrays.sort(rects);\n\n        while (true) {\n            String[] tmpArray = br.readLine().split(\" \");\n\n            int h = Integer.parseInt(tmpArray[0]);\n            int w = Integer.parseInt(tmpArray[1]);\n\n            if (h == 0 && w == 0) {\n                break;\n            }\n\n            IntegralRect tmpRect = new IntegralRect(h, w);\n            int diag = tmpRect.diagonal();\n\n            for (int i = 0; i < rects.length; i++) {\n\n                if (rects[i].compareTo(tmpRect) > 0) {\n                    System.out.println(rects[i].height + \" \" + rects[i].width);\n                    break;\n                }\n            }\n        }\n    }\n}\n\nclass IntegralRect implements Comparable<IntegralRect> {\n    int height;\n    int width;\n\n    public IntegralRect(int h, int w) {\n        this.height = h;\n        this.width = w;\n    }\n\n    public int diagonal() {\n        if (height >= width) {\n            return Integer.MAX_VALUE;\n        }\n        return this.height * this.height + this.width * this.width;\n    }\n\n    @Override\n    public int compareTo(IntegralRect o) {\n\n        int d1 = this.diagonal();\n        int d2 = o.diagonal();\n\n        return d1 == d2 ? this.height - o.height : d1 - d2;\n    }\n}\n"}
{"id": "Java/49", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\nclass SampleSolution {\n\n    static class Solver {\n        final FastScanner sc;\n        final PrintWriter writer;\n\n        Solver(final FastScanner sc, final PrintWriter writer) {\n            this.sc = sc;\n            this.writer = writer;\n        }\n\n        int n, m, q;\n        int max = 0;\n        int[] a, b, c, d;\n\n        void run() {\n            n = sc.nextInt();\n            m = sc.nextInt();\n            q = sc.nextInt();\n            a = new int[q];\n            b = new int[q];\n            c = new int[q];\n            d = new int[q];\n            for (int i = 0; i < q; i++) {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n                d[i] = sc.nextInt();\n            }\n            dfs(new int[] {1});\n            writer.println(max);\n        }\n\n        private void dfs(int[] array) {\n            if (array.length > n) {\n                int score = 0;\n                for (int i = 0; i < q; i++) {\n                    if (array[b[i]] - array[a[i]] == c[i]) {\n                        score += d[i];\n                    }\n                }\n                max = Math.max(max, score);\n                return;\n            }\n\n            int[] newArray = new int[array.length + 1];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            System.arraycopy(new int[] {array[array.length - 1]}, 0, newArray, array.length, 1);\n\n            while (newArray[newArray.length - 1] <= m) {\n                dfs(newArray);\n                newArray[newArray.length - 1] += 1;\n            }\n        }\n    }\n\n    public static void main(final String[] args) {\n        final FastScanner sc = new FastScanner();\n        try (final PrintWriter w = new PrintWriter(System.out)) {\n            new Solver(sc, w).run();\n            w.flush();\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner() {}\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (final IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(final int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            final StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            final long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(final int n) {\n            final long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n}\n", "test_IO": {"input": ["3 4 3\n1 3 3 100\n1 2 2 10\n2 3 2 10\n"], "output": ["110\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\n\nclass SampleSolution {\n\n    static class Solver {\n        final FastScanner sc;\n        final PrintWriter writer;\n\n        Solver(final FastScanner sc, final PrintWriter writer) {\n            this.sc = sc;\n            this.writer = writer;\n        }\n\n        int n, m, q;\n        int max = 0;\n        int[] a, b, c, d;\n\n        void run() {\n            n = sc.nextInt();\n            m = sc.nextInt();\n            q = sc.nextInt();\n            a = new int[q];\n            b = new int[q];\n            c = new int[q];\n            d = new int[q];\n            for (int i = 0; i < q; i++) {\n                a[i] = sc.nextInt();\n                b[i] = sc.nextInt();\n                c[i] = sc.nextInt();\n                d[i] = sc.nextInt();\n            }\n            dfs(new int[] {1});\n            writer.println(max);\n        }\n\n        private void dfs(int[] array) {\n            if (array.length > n) {\n                int score = 0;\n                for (int i = 0; i < q; i++) {\n                    if (array[b[i]] - array[a[i]] == c[i]) {\n                        score += d[i];\n                    }\n                }\n                max = Math.max(max, score);\n                return;\n            }\n\n            int[] newArray = new int[array.length + 1];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            System.arraycopy(new int[] {array[array.length - 1]}, 0, newArray, array.length, 1);\n\n            while (newArray[newArray.length - 1] <= m) {\n                dfs(newArray);\n                newArray[newArray.length - 1] += 1;\n            }\n        }\n    }\n\n    public static void main(final String[] args) {\n        final FastScanner sc = new FastScanner();\n        try (final PrintWriter w = new PrintWriter(System.out) ) {\n            new Solver(sc, w).run();\n            w.flush();\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        public FastScanner() {}\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (final IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte() ) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(final int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            final StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b) ) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b) ) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            final long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n\n        public int[] nextIntArray(final int n) {\n            final int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        public long[] nextLongArray(final int n) {\n            final long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n    }\n}\n"}
{"id": "Java/52", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = Integer.parseInt(s.next());\n        int[] v = new int[n];\n        int[] c = new int[n];\n        int[] dp = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            v[i] = Integer.parseInt(s.next());\n        }\n        for (int i = 0; i < n; i++) {\n            c[i] = Integer.parseInt(s.next());\n        }\n\n        dp[0] = 0;\n\n        for (int i = 1; i < n; i++) {\n            int tmp = dp[i - 1] + (v[i - 1] - c[i - 1]);\n            dp[i] = tmp > dp[i - 1] ? tmp : dp[i - 1];\n        }\n\n        int tmp = dp[n - 1] + (v[n - 1] - c[n - 1]);\n        dp[n - 1] = tmp > dp[n - 1] ? tmp : dp[n - 1];\n\n        System.out.println(dp[n - 1]);\n    }\n}\n", "test_IO": {"input": ["3\n10 2 5\n6 3 4\n"], "output": ["5\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int n = Integer.parseInt(s.next() );\n        int[] v = new int[n];\n        int[] c = new int[n];\n        int[] dp = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = 0;\n        }\n        for (int i = 0; i < n; i++) {\n            v[i] = Integer.parseInt(s.next() );\n        }\n        for (int i = 0; i < n; i++) {\n            c[i] = Integer.parseInt(s.next() );\n        }\n\n        dp[0] = 0;\n\n        for (int i = 1; i < n; i++) {\n            int tmp = dp[i - 1] + (v[i - 1] - c[i - 1]);\n            dp[i] = tmp > dp[i - 1] ? tmp : dp[i - 1];\n        }\n\n        int tmp = dp[n - 1] + (v[n - 1] - c[n - 1]);\n        dp[n - 1] = tmp > dp[n - 1] ? tmp : dp[n - 1];\n\n        System.out.println(dp[n - 1]);\n    }\n}\n"}
{"id": "Java/53", "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        Scanner insert = new Scanner(System.in);\n        int n = -1;\n        while (true) {\n            String line = insert.nextLine();\n            n = Integer.parseInt(line);\n            if (n == 0) {\n                break;\n            }\n            for (int i = 0; i < n; i++) {}\n\n            line = insert.nextLine();\n            String array2[] = line.split(\" \");\n            int[] input = new int[n];\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                input[i] = (Integer.parseInt(array2[i]));\n                sum += input[i];\n            }\n            double avg = (double) sum / (double) n;\n            int num = 0;\n            for (int i = 0; i < n; i++) {\n                if (input[i] <= avg) {\n                    num++;\n                }\n            }\n            result.add(num);\n        }\n        for (int i = 0; i < (result.size()); i++) {\n            if (result.get(i) == -1) {\n                System.out.println(\"NONE\");\n            } else {\n                System.out.println(result.get(i));\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["7\n15 15 15 15 15 15 15\n4\n10 20 30 60\n10\n1 1 1 1 1 1 1 1 1 100\n7\n90 90 90 90 90 90 10\n7\n2 7 1 8 2 8 4\n0\n"], "output": ["7\n3\n9\n1\n4\n"]}, "modified_context": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        ArrayList<Integer> result = new ArrayList<Integer>();\n        Scanner insert = new Scanner(System.in);\n        int n = -1;\n        while (true) {\n            String line = insert.nextLine();\n            n = Integer.parseInt(line);\n            if (n == 0) {\n                break;\n            }\n            for (int i = 0; i < n; i++) {}\n\n            line = insert.nextLine();\n            String array2[] = line.split(\" \");\n            int[] input = new int[n];\n            int sum = 0;\n            for (int i = 0; i < n; i++) {\n                input[i] = (Integer.parseInt(array2[i]) );\n                sum += input[i];\n            }\n            double avg = (double) sum / (double) n;\n            int num = 0;\n            for (int i = 0; i < n; i++) {\n                if (input[i] <= avg) {\n                    num++;\n                }\n            }\n            result.add(num);\n        }\n        for (int i = 0; i < (result.size() ); i++) {\n            if (result.get(i) == -1) {\n                System.out.println(\"NONE\");\n            } else {\n                System.out.println(result.get(i) );\n            }\n        }\n    }\n}\n"}
{"id": "Java/54", "code": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n\n        out.close();\n    }\n\n    static class Solver {\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int ans = 0;\n            int K = in.nextInt();\n            int S = in.nextInt();\n            int wk = 0;\n            for (int x = 0; x <= K; x++) {\n                for (int y = 0; y <= K; y++) {\n                    wk = S - x - y;\n                    if (wk >= 0 && wk <= K) {\n                        ans++;\n                    }\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar()).trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n", "test_IO": {"input": ["2 2\n"], "output": ["6\n"]}, "modified_context": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver();\n        solver.solve(1, in, out);\n\n        out.close();\n    }\n\n    static class Solver {\n\n        public void solve(int testNumber, MyInput in, PrintWriter out) {\n            int ans = 0;\n            int K = in.nextInt();\n            int S = in.nextInt();\n            int wk = 0;\n            for (int x = 0; x <= K; x++) {\n                for (int y = 0; y <= K; y++) {\n                    wk = S - x - y;\n                    if (wk >= 0 && wk <= K) {\n                        ans++;\n                    }\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n\n        public String getString() {\n            return \"[\" + getKey() + \"] [\" + getValue() + \"]\";\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is) );\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar() ).trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n"}
{"id": "Java/56", "code": "import java.util.*;\n\npublic class SampleSolution {\n    static Scanner sc = new Scanner(System.in);\n\n    static int[] score;\n\n    static int number;\n\n    public static void main(String[] args) {\n\n        while (read()) {\n            slove();\n        }\n    }\n\n    static boolean read() {\n        number = sc.nextInt();\n        if (number == 0) return false;\n\n        score = new int[number];\n        for (int i = 0; i < number; i++) {\n            score[i] = sc.nextInt();\n        }\n        return true;\n    }\n\n    static void slove() {\n        java.util.Arrays.sort(score);\n        int sum = 0;\n        for (int i = 1; i < number - 1; i++) {\n            sum = sum + score[i];\n        }\n        System.out.println(sum / (number - 2));\n    }\n}\n", "test_IO": {"input": ["3\n1000\n342\n0\n5\n2\n2\n9\n11\n932\n5\n300\n1000\n0\n200\n400\n8\n353\n242\n402\n274\n283\n132\n402\n523\n0\n"], "output": ["342\n7\n300\n326\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    static Scanner sc = new Scanner(System.in);\n\n    static int[] score;\n\n    static int number;\n\n    public static void main(String[] args) {\n\n        while (read() ) {\n            slove();\n        }\n    }\n\n    static boolean read() {\n        number = sc.nextInt();\n        if (number == 0) return false;\n\n        score = new int[number];\n        for (int i = 0; i < number; i++) {\n            score[i] = sc.nextInt();\n        }\n        return true;\n    }\n\n    static void slove() {\n        java.util.Arrays.sort(score);\n        int sum = 0;\n        for (int i = 1; i < number - 1; i++) {\n            sum = sum + score[i];\n        }\n        System.out.println(sum / (number - 2) );\n    }\n}\n"}
{"id": "Java/58", "code": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        LinkedList<Integer> list = new LinkedList<Integer>();\n\n        while (scan.hasNextInt() == true) {\n            int a = scan.nextInt();\n            if (a == 0) {\n                System.out.println(list.pop());\n            } else {\n                list.push(a);\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["1\n6\n0\n8\n10\n0\n0\n0\n"], "output": ["6\n10\n8\n1\n"]}, "modified_context": "import java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        LinkedList<Integer> list = new LinkedList<Integer>();\n\n        while (scan.hasNextInt() == true) {\n            int a = scan.nextInt();\n            if (a == 0) {\n                System.out.println(list.pop() );\n            } else {\n                list.push(a);\n            }\n        }\n    }\n}\n"}
{"id": "Java/59", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int total = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j < s.length(); j++) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    total++;\n                }\n            }\n        }\n\n        System.out.println(total == 2 ? \"Yes\" : \"No\");\n    }\n}\n", "test_IO": {"input": ["ASSA\n"], "output": ["Yes\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int total = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + 1; j < s.length(); j++) {\n                if (s.charAt(i) == s.charAt(j) ) {\n                    total++;\n                }\n            }\n        }\n\n        System.out.println(total == 2 ? \"Yes\" : \"No\");\n    }\n}\n"}
{"id": "Java/60", "code": "import java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int[] num = new int[in.nextInt()];\n        for (int i = 0; i < num.length; i++) {\n            num[i] = i + 1;\n        }\n        int count = in.nextInt();\n        Pattern pt = Pattern.compile(\"(\\\\d+),(\\\\d+)\");\n        int line[] = new int[2];\n        for (int i = 0; i < count; i++) {\n            String next = in.next(pt);\n            for (int j = 0; j < line.length; j++) {\n                Matcher matcher = pt.matcher(next);\n                matcher.matches();\n                line[j] = Integer.parseInt(matcher.group(j + 1)) - 1;\n            }\n            int change = num[line[0]];\n            num[line[0]] = num[line[1]];\n            num[line[1]] = change;\n        }\n        for (int i = 0; i < num.length; i++) {\n            System.out.println(num[i]);\n        }\n    }\n}\n", "test_IO": {"input": ["5\n4\n2,4\n3,5\n1,2\n3,4\n"], "output": ["4\n1\n2\n5\n3\n"]}, "modified_context": "import java.util.Scanner;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int[] num = new int[in.nextInt()];\n        for (int i = 0; i < num.length; i++) {\n            num[i] = i + 1;\n        }\n        int count = in.nextInt();\n        Pattern pt = Pattern.compile(\"(\\\\d+),(\\\\d+)\");\n        int line[] = new int[2];\n        for (int i = 0; i < count; i++) {\n            String next = in.next(pt);\n            for (int j = 0; j < line.length; j++) {\n                Matcher matcher = pt.matcher(next);\n                matcher.matches();\n                line[j] = Integer.parseInt(matcher.group(j + 1) ) - 1;\n            }\n            int change = num[line[0]];\n            num[line[0]] = num[line[1]];\n            num[line[1]] = change;\n        }\n        for (int i = 0; i < num.length; i++) {\n            System.out.println(num[i]);\n        }\n    }\n}\n"}
{"id": "Java/61", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class SampleSolution {\n\n    static final InputStream in = System.in;\n    static final PrintWriter out = new PrintWriter(System.out);\n    static final int INF = Integer.MAX_VALUE / 2;\n    static final long LINF = Long.MAX_VALUE / 2;\n\n    public static void main(String[] args) throws IOException {\n        InputReader ir = new InputReader(in);\n        int m = ir.nextInt();\n        int n = ir.nextInt();\n        int[] manju = ir.toIntArray(m);\n        int[] boxlen = new int[n];\n        int[] boxcost = new int[n];\n        for (int i = 0; i < n; i++) {\n            boxlen[i] = ir.nextInt();\n            boxcost[i] = ir.nextInt();\n        }\n        sort(manju);\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int len = i + boxlen[j] >= m ? m : i + boxlen[j];\n                int cnt = 0;\n                for (int k = i; k < len; k++) cnt += manju[m - 1 - k];\n                dp[i][j] = Math.max(dp[i][j], dp[len][j + 1] + cnt - boxcost[j]);\n                dp[i][j] = Math.max(dp[i][j], dp[i][j + 1]);\n            }\n        }\n        out.println(dp[0][0]);\n        out.flush();\n    }\n\n    public static void sort(int[] a) {\n        for (int i = a.length - 1; i >= 1; i--) {\n            int t = (int) Math.random() * i;\n            int temp = a[i];\n            a[i] = a[t];\n            a[t] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class InputReader {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n\n        public InputReader(InputStream in) {\n            this.in = in;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return buffer[curbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private int skip() {\n            int b;\n            while ((b = readByte()) != -1 && isSpaceChar(b))\n                ;\n            return b;\n        }\n\n        public String next() {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public long nextLong() {\n            int c = readByte();\n            while (isSpaceChar(c)) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c));\n            return (minus) ? -res : res;\n        }\n\n        public int[] toIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n    }\n}\n", "test_IO": {"input": ["4 3\n180\n160\n170\n190\n2 100\n3 120\n4 250\n"], "output": ["480\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class SampleSolution {\n\n    static final InputStream in = System.in;\n    static final PrintWriter out = new PrintWriter(System.out);\n    static final int INF = Integer.MAX_VALUE / 2;\n    static final long LINF = Long.MAX_VALUE / 2;\n\n    public static void main(String[] args) throws IOException {\n        InputReader ir = new InputReader(in);\n        int m = ir.nextInt();\n        int n = ir.nextInt();\n        int[] manju = ir.toIntArray(m);\n        int[] boxlen = new int[n];\n        int[] boxcost = new int[n];\n        for (int i = 0; i < n; i++) {\n            boxlen[i] = ir.nextInt();\n            boxcost[i] = ir.nextInt();\n        }\n        sort(manju);\n        int[][] dp = new int[m + 1][n + 1];\n        for (int i = m - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                int len = i + boxlen[j] >= m ? m : i + boxlen[j];\n                int cnt = 0;\n                for (int k = i; k < len; k++) cnt += manju[m - 1 - k];\n                dp[i][j] = Math.max(dp[i][j], dp[len][j + 1] + cnt - boxcost[j]);\n                dp[i][j] = Math.max(dp[i][j], dp[i][j + 1]);\n            }\n        }\n        out.println(dp[0][0]);\n        out.flush();\n    }\n\n    public static void sort(int[] a) {\n        for (int i = a.length - 1; i >= 1; i--) {\n            int t = (int) Math.random() * i;\n            int temp = a[i];\n            a[i] = a[t];\n            a[t] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class InputReader {\n        private InputStream in;\n        private byte[] buffer = new byte[1024];\n        private int curbuf;\n        private int lenbuf;\n\n        public InputReader(InputStream in) {\n            this.in = in;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (curbuf >= lenbuf) {\n                curbuf = 0;\n                try {\n                    lenbuf = in.read(buffer);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return buffer[curbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private int skip() {\n            int b;\n            while ((b = readByte() ) != -1 && isSpaceChar(b) )\n                ;\n            return b;\n        }\n\n        public String next() {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!isSpaceChar(b) ) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int c = readByte();\n            while (isSpaceChar(c) ) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c) );\n            return (minus) ? -res : res;\n        }\n\n        public long nextLong() {\n            int c = readByte();\n            while (isSpaceChar(c) ) c = readByte();\n            boolean minus = false;\n            if (c == '-') {\n                minus = true;\n                c = readByte();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = readByte();\n            } while (!isSpaceChar(c) );\n            return (minus) ? -res : res;\n        }\n\n        public int[] toIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n    }\n}\n"}
{"id": "Java/62", "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    static class Task {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] countArr = new int[n + 1];\n            for (int x = 1; x <= 100; x++) {\n                for (int y = 1; y <= 100; y++) {\n                    for (int z = 1; z <= 100; z++) {\n                        int value = x * x + y * y + z * z + x * y + x * z + y * z;\n                        if (value > n) {\n                            break;\n                        }\n                        countArr[value]++;\n                    }\n                }\n            }\n\n            for (int i = 1; i <= n; i++) {\n                out.println(countArr[i]);\n            }\n        }\n    }\n\n    private static void sort(double[] arr) {\n        Double[] objArr = Arrays.stream(arr).boxed().toArray(Double[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(int[] arr) {\n        Integer[] objArr = Arrays.stream(arr).boxed().toArray(Integer[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(long[] arr) {\n        Long[] objArr = Arrays.stream(arr).boxed().toArray(Long[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task task = new Task();\n        task.solve(1, in, out);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, () -> solve(), \"1\", 1 << 26).start();\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "test_IO": {"input": ["20\n"], "output": ["0\n0\n0\n0\n0\n1\n0\n0\n0\n0\n3\n0\n0\n0\n0\n0\n3\n3\n0\n0\n"]}, "modified_context": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    static class Task {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int[] countArr = new int[n + 1];\n            for (int x = 1; x <= 100; x++) {\n                for (int y = 1; y <= 100; y++) {\n                    for (int z = 1; z <= 100; z++) {\n                        int value = x * x + y * y + z * z + x * y + x * z + y * z;\n                        if (value > n) {\n                            break;\n                        }\n                        countArr[value]++;\n                    }\n                }\n            }\n\n            for (int i = 1; i <= n; i++) {\n                out.println(countArr[i]);\n            }\n        }\n    }\n\n    private static void sort(double[] arr) {\n        Double[] objArr = Arrays.stream(arr).boxed().toArray(Double[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(int[] arr) {\n        Integer[] objArr = Arrays.stream(arr).boxed().toArray(Integer[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void sort(long[] arr) {\n        Long[] objArr = Arrays.stream(arr).boxed().toArray(Long[]::new);\n        Arrays.sort(objArr);\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = objArr[i];\n        }\n    }\n\n    private static void solve() {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task task = new Task();\n        task.solve(1, in, out);\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, () -> solve(), \"1\", 1 << 26).start();\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens() ) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine() );\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next() );\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next() );\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n    }\n}\n"}
{"id": "Java/65", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            nums[i] = sc.nextInt();\n        }\n\n        int min = Integer.MAX_VALUE;\n        int countNegatives = 0;\n        long sum = 0;\n        for (int num : nums) {\n            int abs = Math.abs(num);\n            sum += abs;\n            min = Math.min(min, abs);\n            if (num < 0) {\n                countNegatives++;\n            }\n        }\n\n        System.out.println(countNegatives % 2 == 0 ? sum : sum - (min * 2));\n    }\n}\n", "test_IO": {"input": ["3\n-10 5 -4\n"], "output": ["19\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] nums = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            nums[i] = sc.nextInt();\n        }\n\n        int min = Integer.MAX_VALUE;\n        int countNegatives = 0;\n        long sum = 0;\n        for (int num : nums) {\n            int abs = Math.abs(num);\n            sum += abs;\n            min = Math.min(min, abs);\n            if (num < 0) {\n                countNegatives++;\n            }\n        }\n\n        System.out.println(countNegatives % 2 == 0 ? sum : sum - (min * 2) );\n    }\n}\n"}
{"id": "Java/66", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int count = Integer.parseInt(sc.next());\n        int[] givingNumbers = new int[count];\n\n        for (int i = 0; i < count; i++) {\n\n            givingNumbers[i] = Integer.parseInt(sc.next());\n        }\n\n        for (int i = count - 1; 0 <= i; i--) {\n\n            System.out.print(givingNumbers[i]);\n\n            if (i > 0) {\n                System.out.print(\" \");\n            }\n        }\n\n        System.out.println();\n\n        sc.close();\n    }\n}\n", "test_IO": {"input": ["5\n1 2 3 4 5\n"], "output": ["5 4 3 2 1\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        int count = Integer.parseInt(sc.next() );\n        int[] givingNumbers = new int[count];\n\n        for (int i = 0; i < count; i++) {\n\n            givingNumbers[i] = Integer.parseInt(sc.next() );\n        }\n\n        for (int i = count - 1; 0 <= i; i--) {\n\n            System.out.print(givingNumbers[i]);\n\n            if (i > 0) {\n                System.out.print(\" \");\n            }\n        }\n\n        System.out.println();\n\n        sc.close();\n    }\n}\n"}
{"id": "Java/67", "code": "import java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            String str = sc.next();\n            String[] strArr = str.split(\",\");\n            int[] l = new int[10];\n            int d = 0;\n            for (int i = 0; i < 10; i++) {\n                l[i] = Integer.parseInt(strArr[i]);\n                d += l[i];\n            }\n            int[] v = {Integer.parseInt(strArr[10]), Integer.parseInt(strArr[11])};\n            double t = (double) d / (v[0] + v[1]);\n            d = 0;\n            for (int i = 0; i < 11; i++) {\n                if (v[0] * t <= d) {\n                    System.out.println(i);\n                    break;\n                } else {\n                    d += l[i];\n                }\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["1,1,1,1,1,1,1,1,1,1,40,60\n1,1,1,1,1,3,3,3,3,3,50,50\n10,10,10,10,10,10,10,10,10,10,50,49\n"], "output": ["4\n7\n6\n"]}, "modified_context": "import java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext() ) {\n            String str = sc.next();\n            String[] strArr = str.split(\",\");\n            int[] l = new int[10];\n            int d = 0;\n            for (int i = 0; i < 10; i++) {\n                l[i] = Integer.parseInt(strArr[i]);\n                d += l[i];\n            }\n            int[] v = {Integer.parseInt(strArr[10]), Integer.parseInt(strArr[11])};\n            double t = (double) d / (v[0] + v[1]);\n            d = 0;\n            for (int i = 0; i < 11; i++) {\n                if (v[0] * t <= d) {\n                    System.out.println(i);\n                    break;\n                } else {\n                    d += l[i];\n                }\n            }\n        }\n    }\n}\n"}
{"id": "Java/68", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String s = sc.next();\n        int n = Integer.parseInt(s.substring(s.length() - 1, s.length()));\n        if (n == 3) System.out.println(\"bon\");\n        else if (n == 0 || n == 1 || n == 6 || n == 8) System.out.println(\"pon\");\n        else System.out.println(\"hon\");\n        sc.close();\n    }\n}\n", "test_IO": {"input": ["16\n"], "output": ["pon\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String s = sc.next();\n        int n = Integer.parseInt(s.substring(s.length() - 1, s.length() ) );\n        if (n == 3) System.out.println(\"bon\");\n        else if (n == 0 || n == 1 || n == 6 || n == 8) System.out.println(\"pon\");\n        else System.out.println(\"hon\");\n        sc.close();\n    }\n}\n"}
{"id": "Java/69", "code": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        HashMap<String, String> map = new HashMap<String, String>();\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String str = sc.nextLine();\n        for (int i = 0; i < n; i++) {\n            map.put(sc.nextLine(), \"\");\n        }\n        sc.close();\n\n        System.out.println(map.size());\n    }\n}\n", "test_IO": {"input": ["3\napple\norange\napple\n"], "output": ["2\n"]}, "modified_context": "import java.util.HashMap;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        HashMap<String, String> map = new HashMap<String, String>();\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String str = sc.nextLine();\n        for (int i = 0; i < n; i++) {\n            map.put(sc.nextLine(), \"\");\n        }\n        sc.close();\n\n        System.out.println(map.size() );\n    }\n}\n"}
{"id": "Java/71", "code": "import java.io.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unused\")\npublic class SampleSolution {\n    FastScanner in;\n    PrintWriter out;\n    static final int MOD = (int) 1e9 + 7;\n\n    void solve() {\n        int N = in.nextInt();\n        int[] A = in.nextIntArray(N);\n\n        long ans = 0, sum = A[N - 1];\n        for (int i = N - 2; i >= 0; i--) {\n            ans += (sum * A[i]) % MOD;\n            ans %= MOD;\n            sum += A[i];\n            sum %= MOD;\n        }\n        out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().m();\n    }\n\n    private void m() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    static class FastScanner {\n        private Reader input;\n\n        public FastScanner() {\n            this(System.in);\n        }\n\n        public FastScanner(InputStream stream) {\n            this.input = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public void close() {\n            try {\n                this.input.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long nextLong() {\n            try {\n                int sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                long ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) return ret * sign;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                return -1;\n            }\n        }\n\n        public double nextDouble() {\n            try {\n                double sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                double ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) break;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n                if (b != '.') return sign * ret;\n                double div = 1;\n                b = input.read();\n                while ('0' <= b && b <= '9') {\n                    ret *= 10;\n                    ret += b - '0';\n                    div *= 10;\n                    b = input.read();\n                }\n                return sign * ret / div;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return Double.NaN;\n            }\n        }\n\n        public char nextChar() {\n            try {\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                return (char) b;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return 0;\n            }\n        }\n\n        public String nextStr() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (Character.isWhitespace(b)) {\n                    b = input.read();\n                }\n                while (b != -1 && !Character.isWhitespace(b)) {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public String nextLine() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (b != -1 && b != '\\n') {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public int[] nextIntArrayDec(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt() - 1;\n            }\n            return res;\n        }\n\n        public int[] nextIntArray1Index(int n) {\n            int[] res = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextInt();\n            }\n            return res;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongArrayDec(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong() - 1;\n            }\n            return res;\n        }\n\n        public long[] nextLongArray1Index(int n) {\n            long[] res = new long[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextLong();\n            }\n            return res;\n        }\n\n        public double[] nextDoubleArray(int n) {\n            double[] res = new double[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n    }\n}\n", "test_IO": {"input": ["3\n1 2 3\n"], "output": ["11\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\n@SuppressWarnings(\"unused\")\npublic class SampleSolution {\n    FastScanner in;\n    PrintWriter out;\n    static final int MOD = (int) 1e9 + 7;\n\n    void solve() {\n        int N = in.nextInt();\n        int[] A = in.nextIntArray(N);\n\n        long ans = 0, sum = A[N - 1];\n        for (int i = N - 2; i >= 0; i--) {\n            ans += (sum * A[i]) % MOD;\n            ans %= MOD;\n            sum += A[i];\n            sum %= MOD;\n        }\n        out.println(ans);\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().m();\n    }\n\n    private void m() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    static class FastScanner {\n        private Reader input;\n\n        public FastScanner() {\n            this(System.in);\n        }\n\n        public FastScanner(InputStream stream) {\n            this.input = new BufferedReader(new InputStreamReader(stream) );\n        }\n\n        public void close() {\n            try {\n                this.input.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public long nextLong() {\n            try {\n                int sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                long ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) return ret * sign;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n                return -1;\n            }\n        }\n\n        public double nextDouble() {\n            try {\n                double sign = 1;\n                int b = input.read();\n                while ((b < '0' || '9' < b) && b != '-' && b != '+') {\n                    b = input.read();\n                }\n                if (b == '-') {\n                    sign = -1;\n                    b = input.read();\n                } else if (b == '+') {\n                    b = input.read();\n                }\n                double ret = b - '0';\n                while (true) {\n                    b = input.read();\n                    if (b < '0' || '9' < b) break;\n                    ret *= 10;\n                    ret += b - '0';\n                }\n                if (b != '.') return sign * ret;\n                double div = 1;\n                b = input.read();\n                while ('0' <= b && b <= '9') {\n                    ret *= 10;\n                    ret += b - '0';\n                    div *= 10;\n                    b = input.read();\n                }\n                return sign * ret / div;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return Double.NaN;\n            }\n        }\n\n        public char nextChar() {\n            try {\n                int b = input.read();\n                while (Character.isWhitespace(b) ) {\n                    b = input.read();\n                }\n                return (char) b;\n            } catch (IOException e) {\n                e.printStackTrace();\n                return 0;\n            }\n        }\n\n        public String nextStr() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (Character.isWhitespace(b) ) {\n                    b = input.read();\n                }\n                while (b != -1 && !Character.isWhitespace(b) ) {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public String nextLine() {\n            try {\n                StringBuilder sb = new StringBuilder();\n                int b = input.read();\n                while (b != -1 && b != '\\n') {\n                    sb.append((char) b);\n                    b = input.read();\n                }\n                return sb.toString();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int[] nextIntArray(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt();\n            }\n            return res;\n        }\n\n        public int[] nextIntArrayDec(int n) {\n            int[] res = new int[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextInt() - 1;\n            }\n            return res;\n        }\n\n        public int[] nextIntArray1Index(int n) {\n            int[] res = new int[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextInt();\n            }\n            return res;\n        }\n\n        public long[] nextLongArray(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongArrayDec(int n) {\n            long[] res = new long[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextLong() - 1;\n            }\n            return res;\n        }\n\n        public long[] nextLongArray1Index(int n) {\n            long[] res = new long[n + 1];\n            for (int i = 0; i < n; i++) {\n                res[i + 1] = nextLong();\n            }\n            return res;\n        }\n\n        public double[] nextDoubleArray(int n) {\n            double[] res = new double[n];\n            for (int i = 0; i < n; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n    }\n}\n"}
{"id": "Java/72", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    long MOD = 1000000007;\n\n    void solve(BufferedReader in) throws Exception {\n        int[] xx = toInts(in.readLine());\n        int min = Math.min(xx[0], xx[1]);\n        int max = Math.max(xx[0], xx[1]);\n        long res;\n        if (min == max) {\n            long f = f(min);\n            res = (2 * f * f) % MOD;\n        } else if (min + 1 == max) {\n            long f = f(min);\n            res = (f * ((f * max) % MOD)) % MOD;\n        } else {\n            res = 0;\n        }\n        System.out.println(res);\n    }\n\n    long f(int n) {\n        long res = 1;\n        for (int i = 2; i <= n; i++) res = (res * i) % MOD;\n        return res;\n    }\n\n    int toInt(String s) {\n        return Integer.parseInt(s);\n    }\n\n    int[] toInts(String s) {\n        String[] a = s.split(\" \");\n        int[] o = new int[a.length];\n        for (int i = 0; i < a.length; i++) o[i] = toInt(a[i]);\n        return o;\n    }\n\n    void e(Object o) {\n        System.err.println(o);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        (new SampleSolution()).solve(in);\n    }\n}\n", "test_IO": {"input": ["2 2\n"], "output": ["8\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    long MOD = 1000000007;\n\n    void solve(BufferedReader in) throws Exception {\n        int[] xx = toInts(in.readLine() );\n        int min = Math.min(xx[0], xx[1]);\n        int max = Math.max(xx[0], xx[1]);\n        long res;\n        if (min == max) {\n            long f = f(min);\n            res = (2 * f * f) % MOD;\n        } else if (min + 1 == max) {\n            long f = f(min);\n            res = (f * ((f * max) % MOD) ) % MOD;\n        } else {\n            res = 0;\n        }\n        System.out.println(res);\n    }\n\n    long f(int n) {\n        long res = 1;\n        for (int i = 2; i <= n; i++) res = (res * i) % MOD;\n        return res;\n    }\n\n    int toInt(String s) {\n        return Integer.parseInt(s);\n    }\n\n    int[] toInts(String s) {\n        String[] a = s.split(\" \");\n        int[] o = new int[a.length];\n        for (int i = 0; i < a.length; i++) o[i] = toInt(a[i]);\n        return o;\n    }\n\n    void e(Object o) {\n        System.err.println(o);\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in) );\n        (new SampleSolution() ).solve(in);\n    }\n}\n"}
{"id": "Java/73", "code": "import java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[3];\n        for (int i = 0; i < n; i++) {\n            a[0] = sc.nextInt();\n            a[1] = sc.nextInt();\n            a[2] = sc.nextInt();\n            Arrays.sort(a);\n            if (Math.pow(a[2], 2) == Math.pow(a[0], 2) + Math.pow(a[1], 2))\n                System.out.println(\"YES\");\n            else System.out.println(\"NO\");\n        }\n    }\n}\n", "test_IO": {"input": ["3\n4 3 5\n4 3 6\n8 8 8\n"], "output": ["YES\nNO\nNO\n"]}, "modified_context": "import java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[] a = new int[3];\n        for (int i = 0; i < n; i++) {\n            a[0] = sc.nextInt();\n            a[1] = sc.nextInt();\n            a[2] = sc.nextInt();\n            Arrays.sort(a);\n            if (Math.pow(a[2], 2) == Math.pow(a[0], 2) + Math.pow(a[1], 2) )\n                System.out.println(\"YES\");\n            else System.out.println(\"NO\");\n        }\n    }\n}\n"}
{"id": "Java/74", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int n, a[];\n    static double dp[][][];\n\n    static void solve() {\n        n = ni();\n        a = na(n);\n        dp = new double[n + 1][n + 1][n + 1];\n        for (int i = 0; i < n + 1; i++) fill(dp[i], -1);\n        dp[0][0][0] = 0;\n        int cnt[] = new int[3];\n        for (int i = 0; i < n; i++) {\n            cnt[a[i] - 1]++;\n        }\n        double ans = rec(cnt[0], cnt[1], cnt[2]);\n        out.println(ans);\n    }\n\n    static double rec(int i, int j, int k) {\n        if (dp[i][j][k] != -1) return dp[i][j][k];\n        double ret = 0;\n        double p = ((double) i + j + k) / n;\n        double pi = (double) i / n;\n        double pj = (double) j / n;\n        double pk = (double) k / n;\n        ret += 1 / p;\n        if (i > 0) ret += pi / p * rec(i - 1, j, k);\n        if (j > 0) ret += pj / p * rec(i + 1, j - 1, k);\n        if (k > 0) ret += pk / p * rec(i, j + 1, k - 1);\n        return dp[i][j][k] = ret;\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "test_IO": {"input": ["3\n1 1 1\n"], "output": ["5.5\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int n, a[];\n    static double dp[][][];\n\n    static void solve() {\n        n = ni();\n        a = na(n);\n        dp = new double[n + 1][n + 1][n + 1];\n        for (int i = 0; i < n + 1; i++) fill(dp[i], -1);\n        dp[0][0][0] = 0;\n        int cnt[] = new int[3];\n        for (int i = 0; i < n; i++) {\n            cnt[a[i] - 1]++;\n        }\n        double ans = rec(cnt[0], cnt[1], cnt[2]);\n        out.println(ans);\n    }\n\n    static double rec(int i, int j, int k) {\n        if (dp[i][j][k] != -1) return dp[i][j][k];\n        double ret = 0;\n        double p = ((double) i + j + k) / n;\n        double pi = (double) i / n;\n        double pj = (double) j / n;\n        double pk = (double) k / n;\n        ret += 1 / p;\n        if (i > 0) ret += pi / p * rec(i - 1, j, k);\n        if (j > 0) ret += pj / p * rec(i + 1, j - 1, k);\n        if (k > 0) ret += pk / p * rec(i, j + 1, k - 1);\n        return dp[i][j][k] = ret;\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i) );\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1) ) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes() );\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte() ) != -1 && isSpaceChar(b) )\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns() );\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b) ) ) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b) ) ) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte() ) != -1 && !((b >= '0' && b <= '9') || b == '-') )\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte() ) != -1 && !((b >= '0' && b <= '9') || b == '-') )\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n"}
{"id": "Java/77", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int x = Integer.parseInt(sc.next());\n        System.out.println(x < 1200 ? \"ABC\" : \"ARC\");\n    }\n}\n", "test_IO": {"input": ["1000\n"], "output": ["ABC\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int x = Integer.parseInt(sc.next() );\n        System.out.println(x < 1200 ? \"ABC\" : \"ARC\");\n    }\n}\n"}
{"id": "Java/78", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[][] a = new char[n][n];\n            long P = 37, Q = 47;\n            long[] powP = new long[n + 1], powQ = new long[n + 1];\n            powP[0] = powQ[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                powP[i] = powP[i - 1] * P;\n                powQ[i] = powQ[i - 1] * Q;\n            }\n            for (int i = 0; i < n; i++) {\n                a[i] = in.next().toCharArray();\n            }\n\n            long[][] hashRow = new long[n][n];\n            long[][] hashCol = new long[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        hashRow[i][k] += a[i][j] * powP[(j - k + n) % n];\n                        hashCol[j][k] += a[i][j] * powP[(i - k + n) % n];\n                    }\n                }\n            }\n\n            int ans = 0;\n            for (int A = 0; A < n; A++) {\n                for (int B = 0; B < n; B++) {\n                    boolean ok = true;\n                    for (int i = 0; i < n; i++) {\n                        ok &= hashRow[(i + A) % n][B] == hashCol[(i + B) % n][A];\n                    }\n                    ans += ok ? 1 : 0;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n    }\n}\n", "test_IO": {"input": ["2\nab\nca\n"], "output": ["2\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int n = in.nextInt();\n            char[][] a = new char[n][n];\n            long P = 37, Q = 47;\n            long[] powP = new long[n + 1], powQ = new long[n + 1];\n            powP[0] = powQ[0] = 1;\n            for (int i = 1; i <= n; i++) {\n                powP[i] = powP[i - 1] * P;\n                powQ[i] = powQ[i - 1] * Q;\n            }\n            for (int i = 0; i < n; i++) {\n                a[i] = in.next().toCharArray();\n            }\n\n            long[][] hashRow = new long[n][n];\n            long[][] hashCol = new long[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        hashRow[i][k] += a[i][j] * powP[(j - k + n) % n];\n                        hashCol[j][k] += a[i][j] * powP[(i - k + n) % n];\n                    }\n                }\n            }\n\n            int ans = 0;\n            for (int A = 0; A < n; A++) {\n                for (int B = 0; B < n; B++) {\n                    boolean ok = true;\n                    for (int i = 0; i < n; i++) {\n                        ok &= hashRow[(i + A) % n][B] == hashCol[(i + B) % n][A];\n                    }\n                    ans += ok ? 1 : 0;\n                }\n            }\n            out.println(ans);\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in) );\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next() );\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements() ) {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                }\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n    }\n}\n"}
{"id": "Java/79", "code": "import java.io.IOException;\nimport java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder(\"\");\n        int a, b, digit;\n        while (sc.hasNextInt()) {\n            a = sc.nextInt();\n            b = sc.nextInt();\n            digit = (int) Math.log10(a + b) + 1;\n            sb.append(digit);\n            sb.append('\\n');\n        }\n        System.out.print(sb);\n    }\n}\n", "test_IO": {"input": ["5 7\n1 99\n1000 999\n"], "output": ["2\n3\n4\n"]}, "modified_context": "import java.io.IOException;\nimport java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder(\"\");\n        int a, b, digit;\n        while (sc.hasNextInt() ) {\n            a = sc.nextInt();\n            b = sc.nextInt();\n            digit = (int) Math.log10(a + b) + 1;\n            sb.append(digit);\n            sb.append('\\n');\n        }\n        System.out.print(sb);\n    }\n}\n"}
{"id": "Java/80", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n; i++) {\n            int a = sc.nextInt();\n            if (map.containsKey(a)) {\n                map.put(a, map.get(a) + 1);\n            } else {\n                map.put(a, 1);\n            }\n        }\n        int ans = 0;\n        for (int key : map.keySet()) {\n            if ((map.get(key) % 2) == 1) ans++;\n        }\n        System.out.println(ans);\n    }\n}\n", "test_IO": {"input": ["3\n6\n2\n6\n"], "output": ["1\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 0; i < n; i++) {\n            int a = sc.nextInt();\n            if (map.containsKey(a) ) {\n                map.put(a, map.get(a) + 1);\n            } else {\n                map.put(a, 1);\n            }\n        }\n        int ans = 0;\n        for (int key : map.keySet() ) {\n            if ((map.get(key) % 2) == 1) ans++;\n        }\n        System.out.println(ans);\n    }\n}\n"}
{"id": "Java/81", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    static Scanner sc = new Scanner(System.in);\n    static int d;\n\n    static boolean read() {\n        if (!sc.hasNextInt()) return false;\n        d = sc.nextInt();\n        return true;\n    }\n\n    static int solve() {\n        int ans, n;\n\n        ans = 0;\n        for (int i = 1; i * d < 600; i++) {\n            int x = i * d;\n            int y = x * x;\n            ans += y * d;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        while (read()) {\n            System.out.println(solve());\n        }\n    }\n}\n", "test_IO": {"input": ["20\n10\n"], "output": ["68440000\n70210000\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    static Scanner sc = new Scanner(System.in);\n    static int d;\n\n    static boolean read() {\n        if (!sc.hasNextInt() ) return false;\n        d = sc.nextInt();\n        return true;\n    }\n\n    static int solve() {\n        int ans, n;\n\n        ans = 0;\n        for (int i = 1; i * d < 600; i++) {\n            int x = i * d;\n            int y = x * x;\n            ans += y * d;\n        }\n        return ans;\n    }\n\n    public static void main(String[] args) {\n        while (read() ) {\n            System.out.println(solve() );\n        }\n    }\n}\n"}
{"id": "Java/83", "code": "import static java.lang.Integer.parseInt;\n\nimport java.awt.geom.Point2D.Double;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    public void run() {\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in))) {\n\n            Point2D p0, p1, p2;\n            String[] line = br.readLine().split(\" \");\n            p0 = new Point2D(parseInt(line[0]), parseInt(line[1]));\n            p1 = new Point2D(parseInt(line[2]), parseInt(line[3]));\n            int q = parseInt(br.readLine());\n\n            StringBuilder buf = new StringBuilder();\n            for (int i = 0; i < q; i++) {\n                line = br.readLine().split(\" \");\n                p2 = new Point2D(parseInt(line[0]), parseInt(line[1]));\n                buf.append(jadgeClockwise(p0, p1, p2)).append(\"\\n\");\n            }\n\n            System.out.print(buf);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    public String jadgeClockwise(Point2D p0, Point2D p1, Point2D p2) {\n        Vector v = new Vector();\n        Point2D a = p1.diff(p0);\n        Point2D b = p2.diff(p0);\n\n        if (v.cross(a, b) > v.EPS) {\n            return \"COUNTER_CLOCKWISE\";\n        }\n        if (v.cross(a, b) < -v.EPS) {\n            return \"CLOCKWISE\";\n        }\n        if (v.dot(a, b) < -v.EPS) {\n            return \"ONLINE_BACK\";\n        }\n        if (a.norm() < b.norm()) {\n            return \"ONLINE_FRONT\";\n        }\n\n        return \"ON_SEGMENT\";\n    }\n\n    private class Point2D extends Double {\n        private static final long serialVersionUID = 1L;\n        double EPS = 1e-10;\n\n        public Point2D() {\n            super();\n        }\n\n        public Point2D(double x, double y) {\n            super(x, y);\n        }\n\n        public boolean equals(double a, double b) {\n            return Math.abs(a - b) < EPS;\n        }\n\n        public Point2D sum(Point2D b) {\n            return new Point2D(x + b.x, y + b.y);\n        }\n\n        public Point2D diff(Point2D b) {\n            return new Point2D(x - b.x, y - b.y);\n        }\n\n        public Point2D multiple(double k) {\n            return new Point2D(x * k, y * k);\n        }\n\n        public double norm() {\n            return x * x + y * y;\n        }\n\n        public double abs(Point2D a) {\n            return Math.sqrt(a.norm());\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%.10f %.10f\", x, y);\n        }\n    }\n\n    private class Vector extends Point2D {\n\n        private static final long serialVersionUID = 1L;\n\n        public Vector() {\n            super();\n        }\n\n        public Vector(double x, double y) {\n            super(x, y);\n        }\n\n        public Vector(Point2D p) {\n            super(p.x, p.y);\n        }\n\n        public double dot(Point2D a, Point2D b) {\n            return a.x * b.x + a.y * b.y;\n        }\n\n        public double cross(Point2D a, Point2D b) {\n            return a.x * b.y - a.y * b.x;\n        }\n\n        public boolean isOrthogonal(Point2D a, Point2D b) {\n            return equals(dot(a, b), 0.0);\n        }\n\n        public boolean isOrthogonal(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isOrthogonal(a1.diff(a2), b1.diff(b2));\n        }\n\n        public boolean isParallel(Point2D a, Point2D b) {\n            return equals(cross(a, b), 0.0);\n        }\n\n        public boolean isParallel(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isParallel(a1.diff(a2), b1.diff(b2));\n        }\n\n        public Point2D project(Point2D sp1, Point2D sp2, Point2D p) {\n            Vector base = new Vector(sp2.diff(sp1));\n            double r = dot(p.diff(sp1), base) / base.norm();\n\n            return sp1.sum(base.multiple(r));\n        }\n\n        public Point2D reflect(Point2D sp1, Point2D sp2, Point2D p) {\n            return p.sum(project(sp1, sp2, p).diff(p).multiple(2.0));\n        }\n    }\n}\n", "test_IO": {"input": ["0 0 2 0\n2\n-1 1\n-1 -1\n"], "output": ["COUNTER_CLOCKWISE\nCLOCKWISE\n"]}, "modified_context": "import static java.lang.Integer.parseInt;\n\nimport java.awt.geom.Point2D.Double;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    public void run() {\n\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(System.in) ) ) {\n\n            Point2D p0, p1, p2;\n            String[] line = br.readLine().split(\" \");\n            p0 = new Point2D(parseInt(line[0]), parseInt(line[1]) );\n            p1 = new Point2D(parseInt(line[2]), parseInt(line[3]) );\n            int q = parseInt(br.readLine() );\n\n            StringBuilder buf = new StringBuilder();\n            for (int i = 0; i < q; i++) {\n                line = br.readLine().split(\" \");\n                p2 = new Point2D(parseInt(line[0]), parseInt(line[1]) );\n                buf.append(jadgeClockwise(p0, p1, p2) ).append(\"\\n\");\n            }\n\n            System.out.print(buf);\n\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    public String jadgeClockwise(Point2D p0, Point2D p1, Point2D p2) {\n        Vector v = new Vector();\n        Point2D a = p1.diff(p0);\n        Point2D b = p2.diff(p0);\n\n        if (v.cross(a, b) > v.EPS) {\n            return \"COUNTER_CLOCKWISE\";\n        }\n        if (v.cross(a, b) < -v.EPS) {\n            return \"CLOCKWISE\";\n        }\n        if (v.dot(a, b) < -v.EPS) {\n            return \"ONLINE_BACK\";\n        }\n        if (a.norm() < b.norm() ) {\n            return \"ONLINE_FRONT\";\n        }\n\n        return \"ON_SEGMENT\";\n    }\n\n    private class Point2D extends Double {\n        private static final long serialVersionUID = 1L;\n        double EPS = 1e-10;\n\n        public Point2D() {\n            super();\n        }\n\n        public Point2D(double x, double y) {\n            super(x, y);\n        }\n\n        public boolean equals(double a, double b) {\n            return Math.abs(a - b) < EPS;\n        }\n\n        public Point2D sum(Point2D b) {\n            return new Point2D(x + b.x, y + b.y);\n        }\n\n        public Point2D diff(Point2D b) {\n            return new Point2D(x - b.x, y - b.y);\n        }\n\n        public Point2D multiple(double k) {\n            return new Point2D(x * k, y * k);\n        }\n\n        public double norm() {\n            return x * x + y * y;\n        }\n\n        public double abs(Point2D a) {\n            return Math.sqrt(a.norm() );\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%.10f %.10f\", x, y);\n        }\n    }\n\n    private class Vector extends Point2D {\n\n        private static final long serialVersionUID = 1L;\n\n        public Vector() {\n            super();\n        }\n\n        public Vector(double x, double y) {\n            super(x, y);\n        }\n\n        public Vector(Point2D p) {\n            super(p.x, p.y);\n        }\n\n        public double dot(Point2D a, Point2D b) {\n            return a.x * b.x + a.y * b.y;\n        }\n\n        public double cross(Point2D a, Point2D b) {\n            return a.x * b.y - a.y * b.x;\n        }\n\n        public boolean isOrthogonal(Point2D a, Point2D b) {\n            return equals(dot(a, b), 0.0);\n        }\n\n        public boolean isOrthogonal(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isOrthogonal(a1.diff(a2), b1.diff(b2) );\n        }\n\n        public boolean isParallel(Point2D a, Point2D b) {\n            return equals(cross(a, b), 0.0);\n        }\n\n        public boolean isParallel(Point2D a1, Point2D a2, Point2D b1, Point2D b2) {\n            return isParallel(a1.diff(a2), b1.diff(b2) );\n        }\n\n        public Point2D project(Point2D sp1, Point2D sp2, Point2D p) {\n            Vector base = new Vector(sp2.diff(sp1) );\n            double r = dot(p.diff(sp1), base) / base.norm();\n\n            return sp1.sum(base.multiple(r) );\n        }\n\n        public Point2D reflect(Point2D sp1, Point2D sp2, Point2D p) {\n            return p.sum(project(sp1, sp2, p).diff(p).multiple(2.0) );\n        }\n    }\n}\n"}
{"id": "Java/84", "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        int[][] g = new int[n + 1][n + 1];\n\n        for (int i = 0; i < n; i++) {\n            int u = sc.nextInt();\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                int v = sc.nextInt();\n                g[u][v] = 1;\n            }\n        }\n\n        int[] d = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            d[i] = -1;\n        }\n        Queue<Integer> que = new LinkedList<Integer>();\n        que.add(1);\n        d[1] = 0;\n        while (!que.isEmpty()) {\n            int top = que.poll();\n            for (int j = 1; j <= n; j++) {\n                if (g[top][j] == 1 && d[j] == -1) {\n                    que.add(j);\n                    d[j] = d[top] + 1;\n                }\n            }\n        }\n\n        for (int i = 1; i <= n; i++) {\n            System.out.println(i + \" \" + d[i]);\n        }\n    }\n}\n", "test_IO": {"input": ["4\n1 2 2 4\n2 1 4\n3 0\n4 1 3\n"], "output": ["1 0\n2 1\n3 2\n4 1\n"]}, "modified_context": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n\n        int[][] g = new int[n + 1][n + 1];\n\n        for (int i = 0; i < n; i++) {\n            int u = sc.nextInt();\n            int k = sc.nextInt();\n            for (int j = 0; j < k; j++) {\n                int v = sc.nextInt();\n                g[u][v] = 1;\n            }\n        }\n\n        int[] d = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            d[i] = -1;\n        }\n        Queue<Integer> que = new LinkedList<Integer>();\n        que.add(1);\n        d[1] = 0;\n        while (!que.isEmpty() ) {\n            int top = que.poll();\n            for (int j = 1; j <= n; j++) {\n                if (g[top][j] == 1 && d[j] == -1) {\n                    que.add(j);\n                    d[j] = d[top] + 1;\n                }\n            }\n        }\n\n        for (int i = 1; i <= n; i++) {\n            System.out.println(i + \" \" + d[i]);\n        }\n    }\n}\n"}
{"id": "Java/87", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int sum = 0;\n            String s = sc.next();\n            if (s.equals(\"0\")) break;\n            for (int i = 0; i < s.length(); i++) {\n                char a = s.charAt(i);\n                sum += a - '0';\n            }\n            System.out.printf(\"%d\\n\", sum);\n        }\n    }\n}\n", "test_IO": {"input": ["123\n55\n1000\n0\n"], "output": ["6\n10\n1\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (true) {\n            int sum = 0;\n            String s = sc.next();\n            if (s.equals(\"0\") ) break;\n            for (int i = 0; i < s.length(); i++) {\n                char a = s.charAt(i);\n                sum += a - '0';\n            }\n            System.out.printf(\"%d\\n\", sum);\n        }\n    }\n}\n"}
{"id": "Java/88", "code": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static int[] counter;\n    static List<List<Integer>> graph;\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int n = fs.nextInt();\n        int q = fs.nextInt();\n        graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) graph.add(new LinkedList<>());\n\n        counter = new int[n];\n        Integer a, b;\n        for (int i = 0; i < n - 1; i++) {\n            a = fs.nextInt() - 1;\n            b = fs.nextInt() - 1;\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n        for (int i = 0; i < q; i++) {\n            counter[fs.nextInt() - 1] += fs.nextInt();\n        }\n        dfs(0, -1, 0);\n        StringJoiner sj = new StringJoiner(\" \");\n        for (int i = 0; i < n; i++) {\n            sj.add(String.valueOf(counter[i]));\n        }\n        System.out.println(sj.toString());\n    }\n\n    static void dfs(int v, int par, long val) {\n\n        for (Integer i : graph.get(v)) {\n            if (i != par) {\n                dfs(i, v, val + counter[v]);\n            }\n        }\n        counter[v] += val;\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "test_IO": {"input": ["4 3\n1 2\n2 3\n2 4\n2 10\n1 100\n3 1\n"], "output": ["100 110 111 110\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static int[] counter;\n    static List<List<Integer>> graph;\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n        int n = fs.nextInt();\n        int q = fs.nextInt();\n        graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) graph.add(new LinkedList<>() );\n\n        counter = new int[n];\n        Integer a, b;\n        for (int i = 0; i < n - 1; i++) {\n            a = fs.nextInt() - 1;\n            b = fs.nextInt() - 1;\n            graph.get(a).add(b);\n            graph.get(b).add(a);\n        }\n        for (int i = 0; i < q; i++) {\n            counter[fs.nextInt() - 1] += fs.nextInt();\n        }\n        dfs(0, -1, 0);\n        StringJoiner sj = new StringJoiner(\" \");\n        for (int i = 0; i < n; i++) {\n            sj.add(String.valueOf(counter[i]) );\n        }\n        System.out.println(sj.toString() );\n    }\n\n    static void dfs(int v, int par, long val) {\n\n        for (Integer i : graph.get(v) ) {\n            if (i != par) {\n                dfs(i, v, val + counter[v]);\n            }\n        }\n        counter[v] += val;\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte() ) return buffer[ptr++];\n            else return -1;\n        }\n\n        private boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b) ) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nextLong() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b) ) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n    }\n}\n"}
{"id": "Java/89", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass SampleSolution {\n    private static BufferedReader buf;\n\n    public static void main(String[] args) throws IOException {\n        int[] abc = new int[3];\n        String str;\n        String[] inp;\n        buf = new BufferedReader(new InputStreamReader(System.in));\n        str = buf.readLine();\n        inp = str.split(\" \", -1);\n        for (int i = 0; i < inp.length; i++) abc[i] = Integer.parseInt(inp[i]);\n        if (abc[0] < abc[1] && abc[1] < abc[2]) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n", "test_IO": {"input": ["1 3 8\n"], "output": ["Yes\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\nclass SampleSolution {\n    private static BufferedReader buf;\n\n    public static void main(String[] args) throws IOException {\n        int[] abc = new int[3];\n        String str;\n        String[] inp;\n        buf = new BufferedReader(new InputStreamReader(System.in) );\n        str = buf.readLine();\n        inp = str.split(\" \", -1);\n        for (int i = 0; i < inp.length; i++) abc[i] = Integer.parseInt(inp[i]);\n        if (abc[0] < abc[1] && abc[1] < abc[2]) {\n            System.out.println(\"Yes\");\n        } else {\n            System.out.println(\"No\");\n        }\n    }\n}\n"}
{"id": "Java/91", "code": "import java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        String s1 = s.substring(0, 1);\n        String s2 = s.substring(1, 2);\n        String s3 = s.substring(2, 3);\n        String s4 = s.substring(3, 4);\n        int a = 0;\n\n        if (s1.equals(s2)) a = 1;\n        if (s2.equals(s3)) a = 1;\n        if (s3.equals(s4)) a = 1;\n\n        if (a == 1) {\n            System.out.println(\"Bad\");\n        } else {\n            System.out.println(\"Good\");\n        }\n    }\n}\n", "test_IO": {"input": ["3776\n"], "output": ["Bad\n"]}, "modified_context": "import java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        String s1 = s.substring(0, 1);\n        String s2 = s.substring(1, 2);\n        String s3 = s.substring(2, 3);\n        String s4 = s.substring(3, 4);\n        int a = 0;\n\n        if (s1.equals(s2) ) a = 1;\n        if (s2.equals(s3) ) a = 1;\n        if (s3.equals(s4) ) a = 1;\n\n        if (a == 1) {\n            System.out.println(\"Bad\");\n        } else {\n            System.out.println(\"Good\");\n        }\n    }\n}\n"}
{"id": "Java/92", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws java.lang.Exception {\n        new Solution();\n    }\n}\n\nclass Solution {\n    Scanner scanner;\n\n    public Solution() {\n        scanner = new Scanner(System.in);\n\n        while (scanner.hasNext()) {\n            run_case();\n        }\n    }\n\n    private void run_case() {\n\n        String line = scanner.nextLine();\n        int N = Integer.parseInt(line.split(\"\\\\s+\")[0]);\n        int K = Integer.parseInt(line.split(\"\\\\s+\")[1]);\n\n        int len = 0;\n        while (N > 0) {\n            N /= K;\n            len++;\n        }\n\n        System.out.println(len);\n        return;\n    }\n\n    private int[] strToIntArray(String str) {\n        String[] vals = str.split(\"\\\\s+\");\n        int sz = vals.length;\n        int[] res = new int[sz];\n        for (int i = 0; i < sz; i++) {\n            res[i] = Integer.parseInt(vals[i]);\n        }\n        return res;\n    }\n}\n\nclass LCS {\n    int[][] dp;\n\n    public int lcs(String A, String B) {\n        int sz_a = A.length(), sz_b = B.length();\n        dp = new int[sz_a + 1][sz_b + 1];\n\n        for (int i = 0; i <= sz_a; i++) dp[i][0] = 0;\n        for (int j = 0; j <= sz_b; j++) dp[0][j] = 0;\n\n        for (int i = 1; i <= sz_a; i++) {\n            for (int j = 1; j <= sz_b; j++) {\n                if (A.charAt(i - 1) == B.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[sz_a][sz_b];\n    }\n\n    public String getLCS(String X, String Y) {\n        int m = X.length();\n        int n = Y.length();\n\n        int index = dp[m][n];\n        int temp = index;\n\n        char[] lcs = new char[index + 1];\n        lcs[index] = '\\0';\n\n        int i = m;\n        int j = n;\n        while (i > 0 && j > 0) {\n\n            if (X.charAt(i - 1) == Y.charAt(j - 1)) {\n\n                lcs[index - 1] = X.charAt(i - 1);\n\n                i--;\n                j--;\n                index--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) i--;\n            else j--;\n        }\n\n        return String.valueOf(lcs).substring(0, temp + 2);\n    }\n}\n", "test_IO": {"input": ["11 2\n"], "output": ["4\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws java.lang.Exception {\n        new Solution();\n    }\n}\n\nclass Solution {\n    Scanner scanner;\n\n    public Solution() {\n        scanner = new Scanner(System.in);\n\n        while (scanner.hasNext() ) {\n            run_case();\n        }\n    }\n\n    private void run_case() {\n\n        String line = scanner.nextLine();\n        int N = Integer.parseInt(line.split(\"\\\\s+\")[0]);\n        int K = Integer.parseInt(line.split(\"\\\\s+\")[1]);\n\n        int len = 0;\n        while (N > 0) {\n            N /= K;\n            len++;\n        }\n\n        System.out.println(len);\n        return;\n    }\n\n    private int[] strToIntArray(String str) {\n        String[] vals = str.split(\"\\\\s+\");\n        int sz = vals.length;\n        int[] res = new int[sz];\n        for (int i = 0; i < sz; i++) {\n            res[i] = Integer.parseInt(vals[i]);\n        }\n        return res;\n    }\n}\n\nclass LCS {\n    int[][] dp;\n\n    public int lcs(String A, String B) {\n        int sz_a = A.length(), sz_b = B.length();\n        dp = new int[sz_a + 1][sz_b + 1];\n\n        for (int i = 0; i <= sz_a; i++) dp[i][0] = 0;\n        for (int j = 0; j <= sz_b; j++) dp[0][j] = 0;\n\n        for (int i = 1; i <= sz_a; i++) {\n            for (int j = 1; j <= sz_b; j++) {\n                if (A.charAt(i - 1) == B.charAt(j - 1) ) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[sz_a][sz_b];\n    }\n\n    public String getLCS(String X, String Y) {\n        int m = X.length();\n        int n = Y.length();\n\n        int index = dp[m][n];\n        int temp = index;\n\n        char[] lcs = new char[index + 1];\n        lcs[index] = '\\0';\n\n        int i = m;\n        int j = n;\n        while (i > 0 && j > 0) {\n\n            if (X.charAt(i - 1) == Y.charAt(j - 1) ) {\n\n                lcs[index - 1] = X.charAt(i - 1);\n\n                i--;\n                j--;\n                index--;\n            } else if (dp[i - 1][j] > dp[i][j - 1]) i--;\n            else j--;\n        }\n\n        return String.valueOf(lcs).substring(0, temp + 2);\n    }\n}\n"}
{"id": "Java/95", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class InputIterator {\n        ArrayList<String> inputLine = new ArrayList<String>(1024);\n        int index = 0;\n        int max;\n        String read;\n\n        InputIterator() {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            try {\n                while ((read = br.readLine()) != null) {\n                    inputLine.add(read);\n                }\n            } catch (IOException e) {\n            }\n            max = inputLine.size();\n        }\n\n        boolean hasNext() {\n            return (index < max);\n        }\n\n        String next() {\n            if (hasNext()) {\n                return inputLine.get(index++);\n            } else {\n                throw new IndexOutOfBoundsException(\"There is no more input\");\n            }\n        }\n    }\n\n    static HashMap<Integer, String> CONVSTR = new HashMap<Integer, String>();\n    static InputIterator ii = new InputIterator();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static void flush() {\n        out.flush();\n    }\n\n    static void myout(Object t) {\n        out.println(t);\n    }\n\n    static void myerr(Object t) {\n        System.err.print(\"debug:\");\n        System.err.println(t);\n    }\n\n    static String next() {\n        return ii.next();\n    }\n\n    static boolean hasNext() {\n        return ii.hasNext();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    static ArrayList<String> nextStrArray() {\n        return myconv(next(), 8);\n    }\n\n    static ArrayList<String> nextCharArray() {\n        return myconv(next(), 0);\n    }\n\n    static ArrayList<Integer> nextIntArray() {\n        ArrayList<String> input = nextStrArray();\n        ArrayList<Integer> ret = new ArrayList<Integer>(input.size());\n        for (int i = 0; i < input.size(); i++) {\n            ret.add(Integer.parseInt(input.get(i)));\n        }\n        return ret;\n    }\n\n    static ArrayList<Long> nextLongArray() {\n        ArrayList<String> input = nextStrArray();\n        ArrayList<Long> ret = new ArrayList<Long>(input.size());\n        for (int i = 0; i < input.size(); i++) {\n            ret.add(Long.parseLong(input.get(i)));\n        }\n        return ret;\n    }\n\n    static String myconv(Object list, int no) {\n        String joinString = CONVSTR.get(no);\n        if (list instanceof String[]) {\n            return String.join(joinString, (String[]) list);\n        } else if (list instanceof ArrayList) {\n            return String.join(joinString, (ArrayList) list);\n        } else {\n            throw new ClassCastException(\"Don't join\");\n        }\n    }\n\n    static ArrayList<String> myconv(String str, int no) {\n        String splitString = CONVSTR.get(no);\n        return new ArrayList<String>(Arrays.asList(str.split(splitString)));\n    }\n\n    public static void main(String[] args) {\n        CONVSTR.put(8, \" \");\n        CONVSTR.put(9, \"\\n\");\n        CONVSTR.put(0, \"\");\n        solve();\n        flush();\n    }\n\n    static void solve() {\n        int N = nextInt();\n        ArrayList<Integer> list = nextIntArray();\n        int max = 0;\n        int output = 0;\n        for (int i = 0; i < N; i++) {\n            if (max <= list.get(i)) {\n                max = list.get(i);\n                output++;\n            }\n        }\n        myout(output);\n    }\n}\n", "test_IO": {"input": ["4\n6 5 6 8\n"], "output": ["3\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class InputIterator {\n        ArrayList<String> inputLine = new ArrayList<String>(1024);\n        int index = 0;\n        int max;\n        String read;\n\n        InputIterator() {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n            try {\n                while ((read = br.readLine() ) != null) {\n                    inputLine.add(read);\n                }\n            } catch (IOException e) {\n            }\n            max = inputLine.size();\n        }\n\n        boolean hasNext() {\n            return (index < max);\n        }\n\n        String next() {\n            if (hasNext() ) {\n                return inputLine.get(index++);\n            } else {\n                throw new IndexOutOfBoundsException(\"There is no more input\");\n            }\n        }\n    }\n\n    static HashMap<Integer, String> CONVSTR = new HashMap<Integer, String>();\n    static InputIterator ii = new InputIterator();\n    static PrintWriter out = new PrintWriter(System.out);\n\n    static void flush() {\n        out.flush();\n    }\n\n    static void myout(Object t) {\n        out.println(t);\n    }\n\n    static void myerr(Object t) {\n        System.err.print(\"debug:\");\n        System.err.println(t);\n    }\n\n    static String next() {\n        return ii.next();\n    }\n\n    static boolean hasNext() {\n        return ii.hasNext();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(next() );\n    }\n\n    static long nextLong() {\n        return Long.parseLong(next() );\n    }\n\n    static double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n\n    static ArrayList<String> nextStrArray() {\n        return myconv(next(), 8);\n    }\n\n    static ArrayList<String> nextCharArray() {\n        return myconv(next(), 0);\n    }\n\n    static ArrayList<Integer> nextIntArray() {\n        ArrayList<String> input = nextStrArray();\n        ArrayList<Integer> ret = new ArrayList<Integer>(input.size() );\n        for (int i = 0; i < input.size(); i++) {\n            ret.add(Integer.parseInt(input.get(i) ) );\n        }\n        return ret;\n    }\n\n    static ArrayList<Long> nextLongArray() {\n        ArrayList<String> input = nextStrArray();\n        ArrayList<Long> ret = new ArrayList<Long>(input.size() );\n        for (int i = 0; i < input.size(); i++) {\n            ret.add(Long.parseLong(input.get(i) ) );\n        }\n        return ret;\n    }\n\n    static String myconv(Object list, int no) {\n        String joinString = CONVSTR.get(no);\n        if (list instanceof String[]) {\n            return String.join(joinString, (String[]) list);\n        } else if (list instanceof ArrayList) {\n            return String.join(joinString, (ArrayList) list);\n        } else {\n            throw new ClassCastException(\"Don't join\");\n        }\n    }\n\n    static ArrayList<String> myconv(String str, int no) {\n        String splitString = CONVSTR.get(no);\n        return new ArrayList<String>(Arrays.asList(str.split(splitString) ) );\n    }\n\n    public static void main(String[] args) {\n        CONVSTR.put(8, \" \");\n        CONVSTR.put(9, \"\\n\");\n        CONVSTR.put(0, \"\");\n        solve();\n        flush();\n    }\n\n    static void solve() {\n        int N = nextInt();\n        ArrayList<Integer> list = nextIntArray();\n        int max = 0;\n        int output = 0;\n        for (int i = 0; i < N; i++) {\n            if (max <= list.get(i) ) {\n                max = list.get(i);\n                output++;\n            }\n        }\n        myout(output);\n    }\n}\n"}
{"id": "Java/96", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int mod = (int) 1e9 + 7;\n    static List<ArrayList<Integer>> to;\n    static int dp[];\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner(System.in);\n        int N = fs.nextInt();\n        to = new ArrayList<>();\n        for (int i = 0; i < N; i++) to.add(new ArrayList<Integer>());\n        int edges[][] = new int[N - 1][2];\n        for (int i = 0; i < N - 1; i++) {\n            int A = fs.nextInt() - 1, B = fs.nextInt() - 1;\n            to.get(A).add(B);\n            to.get(B).add(A);\n            edges[i][0] = B;\n            edges[i][1] = A;\n        }\n        dp = new int[N];\n        rec(0, -1);\n        long mulsum = 0;\n        for (int e[] : edges) {\n\n            int candidate1 = e[0];\n            int candidate2 = e[1];\n            int child = candidate1;\n            if (dp[candidate1] > dp[candidate2]) child = candidate2;\n\n            long a = dp[child];\n            long b = N - a;\n\n            long mul = (modpow(2, a) - 1) * (modpow(2, b) - 1) % mod;\n            mulsum += mul;\n            mulsum %= mod;\n        }\n        long cases = modpow(2, N);\n\n        long PN = (mulsum + (cases - 1 + mod) % mod) % mod;\n\n        long BN = N * modpow(2, N - 1) % mod;\n\n        long WN = (PN - BN + mod) % mod;\n        long ans = WN * modpow(cases, mod - 2);\n        ans %= mod;\n\n        System.out.println(ans);\n    }\n\n    static int rec(int v, int parent) {\n        int res = 1;\n        for (int next : to.get(v)) {\n            if (next == parent) continue;\n            res += rec(next, v);\n        }\n        return dp[v] = res;\n    }\n\n    static long modpow(long x, long y) {\n        if (y == 0) return 1;\n        if (y % 2 != 0) return x * modpow(x, y - 1) % mod;\n        long tmp = modpow(x, y / 2);\n        return tmp * tmp % mod;\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    public long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n}\n", "test_IO": {"input": ["3\n1 2\n2 3\n"], "output": ["125000001\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int mod = (int) 1e9 + 7;\n    static List<ArrayList<Integer>> to;\n    static int dp[];\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner(System.in);\n        int N = fs.nextInt();\n        to = new ArrayList<>();\n        for (int i = 0; i < N; i++) to.add(new ArrayList<Integer>() );\n        int edges[][] = new int[N - 1][2];\n        for (int i = 0; i < N - 1; i++) {\n            int A = fs.nextInt() - 1, B = fs.nextInt() - 1;\n            to.get(A).add(B);\n            to.get(B).add(A);\n            edges[i][0] = B;\n            edges[i][1] = A;\n        }\n        dp = new int[N];\n        rec(0, -1);\n        long mulsum = 0;\n        for (int e[] : edges) {\n\n            int candidate1 = e[0];\n            int candidate2 = e[1];\n            int child = candidate1;\n            if (dp[candidate1] > dp[candidate2]) child = candidate2;\n\n            long a = dp[child];\n            long b = N - a;\n\n            long mul = (modpow(2, a) - 1) * (modpow(2, b) - 1) % mod;\n            mulsum += mul;\n            mulsum %= mod;\n        }\n        long cases = modpow(2, N);\n\n        long PN = (mulsum + (cases - 1 + mod) % mod) % mod;\n\n        long BN = N * modpow(2, N - 1) % mod;\n\n        long WN = (PN - BN + mod) % mod;\n        long ans = WN * modpow(cases, mod - 2);\n        ans %= mod;\n\n        System.out.println(ans);\n    }\n\n    static int rec(int v, int parent) {\n        int res = 1;\n        for (int next : to.get(v) ) {\n            if (next == parent) continue;\n            res += rec(next, v);\n        }\n        return dp[v] = res;\n    }\n\n    static long modpow(long x, long y) {\n        if (y == 0) return 1;\n        if (y % 2 != 0) return x * modpow(x, y - 1) % mod;\n        long tmp = modpow(x, y / 2);\n        return tmp * tmp % mod;\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in) );\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens() ) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine() );\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens() ) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next() );\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next() );\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    public long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n}\n"}
{"id": "Java/99", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(in.readLine());\n        BigDecimal a = new BigDecimal(st.nextToken());\n        BigDecimal b = new BigDecimal(st.nextToken());\n        BigDecimal mul = a.multiply(b);\n        st = new StringTokenizer(mul.toString(), \".\");\n        System.out.println(st.nextElement());\n    }\n}\n", "test_IO": {"input": ["198 1.10\n"], "output": ["217\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigDecimal;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in) );\n        StringTokenizer st = new StringTokenizer(in.readLine() );\n        BigDecimal a = new BigDecimal(st.nextToken() );\n        BigDecimal b = new BigDecimal(st.nextToken() );\n        BigDecimal mul = a.multiply(b);\n        st = new StringTokenizer(mul.toString(), \".\");\n        System.out.println(st.nextElement() );\n    }\n}\n"}
{"id": "Java/100", "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 1; i < N + 1; i++) map.put(i, sc.nextInt());\n        System.out.println(\n                String.join(\n                        \" \",\n                        map.entrySet().stream()\n                                .sorted(Entry.<Integer, Integer>comparingByValue())\n                                .map(Map.Entry::getKey)\n                                .map(String::valueOf)\n                                .collect(Collectors.toList())));\n    }\n}\n", "test_IO": {"input": ["3\n2 3 1\n"], "output": ["3 1 2\n"]}, "modified_context": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\n        for (int i = 1; i < N + 1; i++) map.put(i, sc.nextInt() );\n        System.out.println(\n                String.join(\n                        \" \",\n                        map.entrySet().stream()\n                                .sorted(Entry.<Integer, Integer>comparingByValue() )\n                                .map(Map.Entry::getKey)\n                                .map(String::valueOf)\n                                .collect(Collectors.toList() ) ) );\n    }\n}\n"}
{"id": "Java/102", "code": "import static java.lang.System.*;\n\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] youbi = {\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"};\n        String s = sc.next();\n        int ans = 0;\n        for (int i = 0; i < youbi.length; i++) {\n            if (youbi[i].equals(s)) {\n                ans = 7 - i;\n            }\n        }\n        out.println(ans);\n    }\n}\n", "test_IO": {"input": ["SAT\n"], "output": ["1\n"]}, "modified_context": "import static java.lang.System.*;\n\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String[] youbi = {\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"};\n        String s = sc.next();\n        int ans = 0;\n        for (int i = 0; i < youbi.length; i++) {\n            if (youbi[i].equals(s) ) {\n                ans = 7 - i;\n            }\n        }\n        out.println(ans);\n    }\n}\n"}
{"id": "Java/105", "code": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        DLazyFaith solver = new DLazyFaith();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DLazyFaith {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            int a = in.ints(), b = in.ints(), q = in.ints();\n            long[] s = new long[a + 2], t = new long[b + 2];\n            s[0] = t[0] = -10_000_000_000L;\n            for (int i = 0; i < a; i++) {\n                s[i + 1] = in.longs();\n            }\n            for (int i = 0; i < b; i++) {\n                t[i + 1] = in.longs();\n            }\n            s[a + 1] = t[b + 1] = 20_000_000_000L;\n            for (int i = 0; i < q; i++) {\n                long x = in.longs();\n                long sl = x - s[Math.max(0, ArrayUtil.lowerBound(s, x + 1) - 1)];\n                long tl = x - t[Math.max(0, ArrayUtil.lowerBound(t, x + 1) - 1)];\n                long sr = s[ArrayUtil.lowerBound(s, x)] - x;\n                long tr = t[ArrayUtil.lowerBound(t, x)] - x;\n                out.ansln(\n                        IntMath.min(\n                                Math.max(sl, tl),\n                                Math.max(sr, tr),\n                                2 * sl + tr,\n                                2 * tl + sr,\n                                sl + 2 * tr,\n                                tl + 2 * sr));\n            }\n        }\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n        public long longs() {\n            return Long.parseLong(string());\n        }\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ansln(long... n) {\n            for (long n1 : n) {\n                ans(n1).ln();\n            }\n            return this;\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n    }\n\n    static final class IntMath {\n        private IntMath() {}\n\n        public static long min(long... v) {\n            return Arrays.stream(v).min().orElseThrow(NoSuchElementException::new);\n        }\n    }\n\n    static final class ArrayUtil {\n        private ArrayUtil() {}\n\n        public static int lowerBound(long[] a, long t) {\n            return lowerBound(a, t, 0);\n        }\n\n        public static int lowerBound(long[] a, long t, int min) {\n            int max = a.length;\n            while (min < max) {\n                int mid = (min + max) / 2;\n                if (t <= a[mid]) {\n                    max = mid;\n                } else {\n                    min = mid + 1;\n                }\n            }\n            return min;\n        }\n    }\n}\n", "test_IO": {"input": ["2 3 4\n100\n600\n400\n900\n1000\n150\n2000\n899\n799\n"], "output": ["350\n1400\n301\n399\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UncheckedIOException;\nimport java.io.Writer;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        DLazyFaith solver = new DLazyFaith();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DLazyFaith {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            int a = in.ints(), b = in.ints(), q = in.ints();\n            long[] s = new long[a + 2], t = new long[b + 2];\n            s[0] = t[0] = -10_000_000_000L;\n            for (int i = 0; i < a; i++) {\n                s[i + 1] = in.longs();\n            }\n            for (int i = 0; i < b; i++) {\n                t[i + 1] = in.longs();\n            }\n            s[a + 1] = t[b + 1] = 20_000_000_000L;\n            for (int i = 0; i < q; i++) {\n                long x = in.longs();\n                long sl = x - s[Math.max(0, ArrayUtil.lowerBound(s, x + 1) - 1)];\n                long tl = x - t[Math.max(0, ArrayUtil.lowerBound(t, x + 1) - 1)];\n                long sr = s[ArrayUtil.lowerBound(s, x)] - x;\n                long tr = t[ArrayUtil.lowerBound(t, x)] - x;\n                out.ansln(\n                        IntMath.min(\n                                Math.max(sl, tl),\n                                Math.max(sr, tr),\n                                2 * sl + tr,\n                                2 * tl + sr,\n                                sl + 2 * tr,\n                                tl + 2 * sr) );\n            }\n        }\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in) );\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens() ) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine() );\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string() );\n        }\n\n        public long longs() {\n            return Long.parseLong(string() );\n        }\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset() ) ) );\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length() );\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l) );\n        }\n\n        public LightWriter ansln(long... n) {\n            for (long n1 : n) {\n                ans(n1).ln();\n            }\n            return this;\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator() );\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n    }\n\n    static final class IntMath {\n        private IntMath() {}\n\n        public static long min(long... v) {\n            return Arrays.stream(v).min().orElseThrow(NoSuchElementException::new);\n        }\n    }\n\n    static final class ArrayUtil {\n        private ArrayUtil() {}\n\n        public static int lowerBound(long[] a, long t) {\n            return lowerBound(a, t, 0);\n        }\n\n        public static int lowerBound(long[] a, long t, int min) {\n            int max = a.length;\n            while (min < max) {\n                int mid = (min + max) / 2;\n                if (t <= a[mid]) {\n                    max = mid;\n                } else {\n                    min = mid + 1;\n                }\n            }\n            return min;\n        }\n    }\n}\n"}
{"id": "Java/107", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        solve(in, out);\n        out.close();\n    }\n\n    static int L, R, top, bottom;\n\n    public static void solve(InputReader sc, PrintWriter pw) {\n\n        int t = 1;\n        u:\n        while (t-- > 0) {\n            long n = sc.nextLong();\n            long m = sc.nextLong();\n            if (n == 0) {\n                pw.println(0);\n                continue u;\n            }\n            if (n == m) {\n                pw.println(0);\n                continue u;\n            }\n            if (n > m) {\n                n = m + n % m;\n                n -= m;\n                pw.println(Math.min(m - n, n));\n                continue u;\n            }\n            pw.println(Math.min(m - n, n));\n        }\n    }\n\n    public static void swap(char[] chrr, int i, int j) {\n        char temp = chrr[i];\n        chrr[i] = chrr[j];\n        chrr[j] = temp;\n    }\n\n    public static int num(int n) {\n        int a = 0;\n        while (n > 0) {\n            a += (n & 1);\n            n >>= 1;\n        }\n        return a;\n    }\n\n    static class Pair {\n        int u, v, i, val;\n\n        Pair(int a, int b, int i) {\n            this.u = a;\n            this.v = b;\n            this.i = i;\n        }\n    }\n\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i * i <= n; i = i + 6) if (n % i == 0 || n % (i + 2) == 0) return false;\n        return true;\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0) return a;\n        return a > b ? gcd(b, a % b) : gcd(a, b % a);\n    }\n\n    static long fast_pow(long base, long n, long M) {\n        if (n == 0) return 1;\n        if (n == 1) return base;\n        long halfn = fast_pow(base, n / 2, M);\n        if (n % 2 == 0) return (halfn * halfn) % M;\n        else return (((halfn * halfn) % M) * base) % M;\n    }\n\n    static long modInverse(long n, long M) {\n        return fast_pow(n, M - 2, M);\n    }\n\n    public static void feedArr(long[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.nextLong();\n    }\n\n    public static void feedArr(double[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.nextDouble();\n    }\n\n    public static void feedArr(int[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.nextInt();\n    }\n\n    public static void feedArr(String[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.next();\n    }\n\n    public static String printArr(int[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (int i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    public static String printArr(long[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (long i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    public static String printArr(String[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (String i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    public static String printArr(double[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (double i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "test_IO": {"input": ["7 4\n"], "output": ["1\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        solve(in, out);\n        out.close();\n    }\n\n    static int L, R, top, bottom;\n\n    public static void solve(InputReader sc, PrintWriter pw) {\n\n        int t = 1;\n        u:\n        while (t-- > 0) {\n            long n = sc.nextLong();\n            long m = sc.nextLong();\n            if (n == 0) {\n                pw.println(0);\n                continue u;\n            }\n            if (n == m) {\n                pw.println(0);\n                continue u;\n            }\n            if (n > m) {\n                n = m + n % m;\n                n -= m;\n                pw.println(Math.min(m - n, n) );\n                continue u;\n            }\n            pw.println(Math.min(m - n, n) );\n        }\n    }\n\n    public static void swap(char[] chrr, int i, int j) {\n        char temp = chrr[i];\n        chrr[i] = chrr[j];\n        chrr[j] = temp;\n    }\n\n    public static int num(int n) {\n        int a = 0;\n        while (n > 0) {\n            a += (n & 1);\n            n >>= 1;\n        }\n        return a;\n    }\n\n    static class Pair {\n        int u, v, i, val;\n\n        Pair(int a, int b, int i) {\n            this.u = a;\n            this.v = b;\n            this.i = i;\n        }\n    }\n\n    static boolean isPrime(int n) {\n        if (n <= 1) return false;\n        if (n <= 3) return true;\n        if (n % 2 == 0 || n % 3 == 0) return false;\n        for (int i = 5; i * i <= n; i = i + 6) if (n % i == 0 || n % (i + 2) == 0) return false;\n        return true;\n    }\n\n    static long gcd(long a, long b) {\n        if (b == 0) return a;\n        return a > b ? gcd(b, a % b) : gcd(a, b % a);\n    }\n\n    static long fast_pow(long base, long n, long M) {\n        if (n == 0) return 1;\n        if (n == 1) return base;\n        long halfn = fast_pow(base, n / 2, M);\n        if (n % 2 == 0) return (halfn * halfn) % M;\n        else return (((halfn * halfn) % M) * base) % M;\n    }\n\n    static long modInverse(long n, long M) {\n        return fast_pow(n, M - 2, M);\n    }\n\n    public static void feedArr(long[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.nextLong();\n    }\n\n    public static void feedArr(double[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.nextDouble();\n    }\n\n    public static void feedArr(int[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.nextInt();\n    }\n\n    public static void feedArr(String[] arr, InputReader sc) {\n        for (int i = 0; i < arr.length; i++) arr[i] = sc.next();\n    }\n\n    public static String printArr(int[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (int i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    public static String printArr(long[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (long i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    public static String printArr(String[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (String i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    public static String printArr(double[] arr) {\n        StringBuilder sbr = new StringBuilder();\n        for (double i : arr) sbr.append(i + \" \");\n        return sbr.toString();\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens() ) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine() );\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next() );\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next() );\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n    }\n}\n"}
{"id": "Java/109", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        String C = sc.next();\n\n        System.out.println((char) (C.charAt(0) + 1));\n    }\n}\n", "test_IO": {"input": ["a\n"], "output": ["b\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        String C = sc.next();\n\n        System.out.println((char) (C.charAt(0) + 1) );\n    }\n}\n"}
{"id": "Java/110", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String S = scanner.nextLine();\n        String T = scanner.nextLine();\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i <= S.length() - T.length(); i++) {\n            min = Math.min(min, find(S.substring(i, i + T.length()), T));\n        }\n        if (min != Integer.MAX_VALUE) {\n            System.out.println(min);\n        } else {\n            System.out.println(T.length());\n        }\n    }\n\n    public static int find(String a, String b) {\n        int calc = 0;\n        for (int x = 0; x < a.length(); x++) {\n            if (a.charAt(x) != b.charAt(x)) {\n                calc++;\n            }\n        }\n        return calc;\n    }\n}\n", "test_IO": {"input": ["cabacc\nabc\n"], "output": ["1\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String S = scanner.nextLine();\n        String T = scanner.nextLine();\n        int min = Integer.MAX_VALUE;\n        for (int i = 0; i <= S.length() - T.length(); i++) {\n            min = Math.min(min, find(S.substring(i, i + T.length() ), T) );\n        }\n        if (min != Integer.MAX_VALUE) {\n            System.out.println(min);\n        } else {\n            System.out.println(T.length() );\n        }\n    }\n\n    public static int find(String a, String b) {\n        int calc = 0;\n        for (int x = 0; x < a.length(); x++) {\n            if (a.charAt(x) != b.charAt(x) ) {\n                calc++;\n            }\n        }\n        return calc;\n    }\n}\n"}
{"id": "Java/111", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n        long MOD = 1000000007;\n        long dp[][] = new long[S.length() + 1][13];\n        dp[0][0] = 1;\n        for (int i = 0; i < S.length(); i++) {\n            if (S.substring(i, i + 1).equals(\"?\")) {\n                for (int j = 0; j < 10; j++) {\n                    for (int k = 0; k < 13; k++) {\n                        dp[i + 1][(k * 10 + j) % 13] += dp[i][k];\n                        dp[i + 1][(k * 10 + j) % 13] %= MOD;\n                    }\n                }\n            } else {\n                for (int k = 0; k < 13; k++) {\n                    int x = Integer.parseInt(S.substring(i, i + 1));\n                    dp[i + 1][(k * 10 + x) % 13] += dp[i][k];\n                    dp[i + 1][(k * 10 + x) % 13] %= MOD;\n                }\n            }\n        }\n        System.out.println(dp[S.length()][5]);\n    }\n}\n", "test_IO": {"input": ["??2??5\n"], "output": ["768\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String S = sc.next();\n        long MOD = 1000000007;\n        long dp[][] = new long[S.length() + 1][13];\n        dp[0][0] = 1;\n        for (int i = 0; i < S.length(); i++) {\n            if (S.substring(i, i + 1).equals(\"?\") ) {\n                for (int j = 0; j < 10; j++) {\n                    for (int k = 0; k < 13; k++) {\n                        dp[i + 1][(k * 10 + j) % 13] += dp[i][k];\n                        dp[i + 1][(k * 10 + j) % 13] %= MOD;\n                    }\n                }\n            } else {\n                for (int k = 0; k < 13; k++) {\n                    int x = Integer.parseInt(S.substring(i, i + 1) );\n                    dp[i + 1][(k * 10 + x) % 13] += dp[i][k];\n                    dp[i + 1][(k * 10 + x) % 13] %= MOD;\n                }\n            }\n        }\n        System.out.println(dp[S.length()][5]);\n    }\n}\n"}
{"id": "Java/115", "code": "import java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\npublic class SampleSolution {\n    List<Long> constraints = new ArrayList<>();\n    long N;\n    long result;\n\n    SampleSolution() throws IOException {\n        InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n        BufferedReader in = new BufferedReader(reader);\n        this.N = Long.parseLong(in.readLine());\n        for (int i = 0; i < 5; ++i) {\n            this.constraints.add(Long.parseLong(in.readLine()));\n        }\n        in.close();\n\n        this.calc();\n    }\n\n    void calc() {\n        long min = Long.MAX_VALUE;\n        for (Long c : this.constraints) {\n            min = Math.min(min, c);\n        }\n        long time = this.N / min;\n        if (this.N % min != 0) {\n            ++time;\n        }\n        time += 4;\n        this.result = time;\n    }\n\n    public static void main(String[] args) throws IOException {\n        SampleSolution ins = new SampleSolution();\n        System.out.println(ins.result);\n    }\n}\n", "test_IO": {"input": ["5\n3\n2\n4\n3\n5\n"], "output": ["7\n"]}, "modified_context": "import java.io.*;\nimport java.nio.charset.StandardCharsets;\nimport java.util.*;\n\npublic class SampleSolution {\n    List<Long> constraints = new ArrayList<>();\n    long N;\n    long result;\n\n    SampleSolution() throws IOException {\n        InputStreamReader reader = new InputStreamReader(System.in, StandardCharsets.UTF_8);\n        BufferedReader in = new BufferedReader(reader);\n        this.N = Long.parseLong(in.readLine() );\n        for (int i = 0; i < 5; ++i) {\n            this.constraints.add(Long.parseLong(in.readLine() ) );\n        }\n        in.close();\n\n        this.calc();\n    }\n\n    void calc() {\n        long min = Long.MAX_VALUE;\n        for (Long c : this.constraints) {\n            min = Math.min(min, c);\n        }\n        long time = this.N / min;\n        if (this.N % min != 0) {\n            ++time;\n        }\n        time += 4;\n        this.result = time;\n    }\n\n    public static void main(String[] args) throws IOException {\n        SampleSolution ins = new SampleSolution();\n        System.out.println(ins.result);\n    }\n}\n"}
{"id": "Java/116", "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        List<Integer> numbers = new ArrayList();\n\n        for (int i = 0; i < N; i++) {\n            numbers.add(Integer.parseInt(scanner.next()));\n        }\n\n        int count = 0;\n\n        do {\n            numbers =\n                    numbers.stream()\n                            .filter(i -> (i % 2) == 0)\n                            .map(i -> i / 2)\n                            .collect(Collectors.toList());\n            if (numbers.size() == N) count++;\n        } while (numbers.size() == N);\n\n        System.out.println(count);\n    }\n}\n", "test_IO": {"input": ["3\n8 12 40\n"], "output": ["2\n"]}, "modified_context": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.stream.Collectors;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        List<Integer> numbers = new ArrayList();\n\n        for (int i = 0; i < N; i++) {\n            numbers.add(Integer.parseInt(scanner.next() ) );\n        }\n\n        int count = 0;\n\n        do {\n            numbers =\n                    numbers.stream()\n                            .filter(i -> (i % 2) == 0)\n                            .map(i -> i / 2)\n                            .collect(Collectors.toList() );\n            if (numbers.size() == N) count++;\n        } while (numbers.size() == N);\n\n        System.out.println(count);\n    }\n}\n"}
{"id": "Java/120", "code": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver(in, out);\n        solver.solve();\n\n        out.close();\n    }\n\n    static class Solver {\n        MyInput in;\n        PrintWriter out;\n\n        public Solver(MyInput in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n        }\n\n        public void solve() {\n            int H = ni();\n            int W = ni();\n            char[][] C = new char[H + 2][W + 2];\n            char[] c;\n            for (int i = 0; i < H; i++) {\n                c = ns().toCharArray();\n                for (int j = 0; j < W; j++) {\n                    C[i + 1][j + 1] = c[j];\n                }\n            }\n            if (H == 1 && W == 1) {\n                prn(\"No\");\n                return;\n            }\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (C[i][j] == '#'\n                            && C[i - 1][j] != '#'\n                            && C[i + 1][j] != '#'\n                            && C[i][j - 1] != '#'\n                            && C[i][j + 1] != '#') {\n                        prn(\"No\");\n                        return;\n                    }\n                }\n            }\n            prn(\"Yes\");\n        }\n\n        static class MapCounter {\n            private TreeMap<Integer, Integer> map;\n\n            public MapCounter() {\n                map = new TreeMap<>();\n            }\n\n            public MapCounter(boolean reverse) {\n                if (reverse) {\n                    map = new TreeMap<Integer, Integer>(Collections.reverseOrder());\n                } else {\n                    map = new TreeMap<>();\n                }\n            }\n\n            public void add(Integer key) {\n                add(key, 1);\n            }\n\n            public void add(Integer key, int cnt) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    map.put(key, cnt);\n                } else {\n                    map.put(key, val + cnt);\n                }\n            }\n\n            public void remove(Integer key) {\n                sub(key, 1, false);\n            }\n\n            public void sub(Integer key) {\n                sub(key, 1);\n            }\n\n            public void sub(Integer key, int cnt) {\n                sub(key, cnt, true);\n            }\n\n            public void sub(Integer key, int cnt, boolean minus) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    if (minus) {\n                        map.put(key, -cnt);\n                    }\n                } else if (val > cnt || minus) {\n                    map.put(key, val - cnt);\n                } else {\n                    map.remove(key);\n                }\n            }\n\n            public void set(Integer key, int cnt) {\n                map.put(key, cnt);\n            }\n\n            public Integer getCountwithNull(Integer key) {\n                return map.get(key);\n            }\n\n            public Integer getCount(Integer key) {\n                Integer val = map.get(key);\n                if (val == null) return 0;\n                else return val;\n            }\n\n            public Set<Integer> getKey() {\n                return map.keySet();\n            }\n\n            public int getKeyCount() {\n                return map.keySet().size();\n            }\n\n            public Integer getFirstKey() {\n                return map.firstKey();\n            }\n\n            public Integer getLastKey() {\n                return map.lastKey();\n            }\n\n            public void clear() {\n                map.clear();\n            }\n        }\n\n        boolean isRightMin(int[] a, boolean f, int index, int key) {\n            if (f && a[index] >= key) return true;\n            else if (!f && a[index] > key) return true;\n            else return false;\n        }\n\n        int binarySearchRightMin(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isRightMin(a, f, mid, key)) ok = mid;\n                else ng = mid;\n            }\n            return ok;\n        }\n\n        boolean isLeftMax(int[] a, boolean f, int index, int key) {\n            if (f && a[index] <= key) return true;\n            else if (!f && a[index] < key) return true;\n            else return false;\n        }\n\n        int binarySearchLeftMax(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isLeftMax(a, f, mid, key)) ng = mid;\n                else ok = mid;\n            }\n            return ng;\n        }\n\n        static class EulerTour {\n            Graph g;\n            List<Integer> euler_tour = new ArrayList<>();\n            int[] begin, end;\n            int k = 0, root = 0;\n\n            void dfs(int v, int p, PrintWriter out) {\n                out.println(\"v = \" + v + \"  p = \" + p);\n                begin[v] = k;\n                euler_tour.add(v);\n                k++;\n                if (!g.contains(v)) {\n                    return;\n                }\n                for (int i : g.get(v)) {\n                    if (i != p) {\n                        dfs(i, v, out);\n                        euler_tour.add(v);\n                        k++;\n                    }\n                }\n                end[v] = k;\n            }\n\n            public void init(int p_cnt, int root, Graph g, PrintWriter out) {\n                begin = new int[p_cnt + 1];\n                end = new int[p_cnt + 1];\n                this.root = root;\n                this.g = g;\n                dfs(root, -1, out);\n            }\n\n            public List getPartTour(int v) {\n                return euler_tour.subList(begin[v], end[v]);\n            }\n\n            public List<Integer> getPartList(int v) {\n                Set<Integer> set = new TreeSet<>();\n                set.addAll(getPartTour(v));\n                List<Integer> ans = new ArrayList<>();\n                for (Integer p : set) {\n                    ans.add(p);\n                }\n                return ans;\n            }\n        }\n\n        class Graph {\n\n            private Map<Integer, List<Integer>> data = new HashMap<Integer, List<Integer>>();\n\n            void add(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    list = new ArrayList<Integer>();\n                    data.put(from, list);\n                }\n                list.add(to);\n            }\n\n            void del(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    return;\n                }\n                if (list.contains(to)) {\n                    list.remove((Object) to);\n                }\n            }\n\n            List<Integer> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<Integer> list = data.get(key_1);\n                if (list == null) return false;\n                else return list.contains(key_2);\n            }\n\n            List<PP> distList(int key) {\n                List<PP> dist = new ArrayList<>();\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0));\n                while (!stack.isEmpty()) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist.add(new PP(pp, dd));\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next)) continue;\n                        stack.push(new PP(next, dd + 1));\n                    }\n                }\n                return dist;\n            }\n\n            int[] distV(int key) {\n                int[] dist = new int[data.keySet().size() + 1];\n                Arrays.fill(dist, -1);\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0));\n                while (!stack.isEmpty()) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist[pp] = dd;\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next)) continue;\n                        stack.push(new PP(next, dd + 1));\n                    }\n                }\n                return dist;\n            }\n\n            Map<Integer, Integer> mapCnt = new HashMap<>();\n            Map<Integer, Integer> mapLow = new HashMap<>();\n\n            Set<Integer> mark = new HashSet<>();\n            int number;\n\n            int bridgeDfs(int now, int pre) {\n\n                mark.add(now);\n                mapCnt.put(now, number);\n                mapLow.put(now, number);\n                int low;\n                for (int next : get(now)) {\n                    if (next == pre) continue;\n                    if (mark.contains(next)) {\n                        if (mapLow.get(now) > mapLow.get(next)) {\n\n                            mapLow.put(now, mapLow.get(next));\n                        }\n                        continue;\n                    }\n                    number++;\n                    low = bridgeDfs(next, now);\n                    if (mapLow.get(now) > low) {\n                        mapLow.put(now, low);\n                    }\n                }\n                return mapLow.get(now);\n            }\n\n            int bridgeCnt(int start) {\n                mapCnt.clear();\n                mapLow.clear();\n                mark.clear();\n                number = 0;\n                bridgeDfs(start, start);\n                int ans = 0;\n                for (int key : mapCnt.keySet()) {\n                    if (mapCnt.get(key) == mapLow.get(key)) {\n                        ans++;\n                    }\n                }\n                return ans - 1;\n            }\n\n            void dump(PrintWriter out) {\n                for (int key : data.keySet()) {\n                    out.print(key + \" : \");\n                    for (int val : data.get(key)) {\n                        out.print(val + \" \");\n                    }\n                    out.println(\"\");\n                }\n            }\n        }\n\n        static class GraphWith {\n\n            private Map<Integer, List<PP>> data = new HashMap<Integer, List<PP>>();\n\n            void add(int key, PP p) {\n                List<PP> list = data.get(key);\n                if (list == null) {\n                    list = new ArrayList<PP>();\n                    data.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PP> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<PP> list = data.get(key_1);\n                if (list == null) return false;\n                boolean ans = false;\n                for (PP p : list) {\n                    if (p.getKey() == key_2) {\n                        ans = true;\n                        break;\n                    }\n                }\n                return ans;\n            }\n\n            int distance(int key_1, int key_2) {\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key_1, 0));\n                PP wk;\n                int key, val;\n                List<PP> list;\n                while (!stack.isEmpty()) {\n                    wk = stack.pop();\n                    key = wk.getKey();\n                    val = wk.getVal();\n                    mark.add(key);\n                    if (key == key_2) return val;\n\n                    list = get(key);\n                    if (list == null) continue;\n                    for (PP pp : list) {\n                        if (mark.contains(pp.getKey())) continue;\n                        stack.push(new PP(pp.getKey(), val + pp.getVal()));\n                    }\n                }\n                return Integer.MAX_VALUE;\n            }\n        }\n\n        static class GraphLong {\n            private Map<Long, List<Long>> G = new HashMap<Long, List<Long>>();\n\n            void add(long key, long value) {\n                List<Long> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<Long>();\n                    G.put(key, list);\n                }\n                list.add(value);\n            }\n\n            List<Long> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        static class GraphLongWith {\n            private Map<Long, List<PPL>> G = new HashMap<Long, List<PPL>>();\n\n            void add(long key, PPL p) {\n                List<PPL> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<PPL>();\n                    G.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PPL> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        void prn(String s) {\n            out.println(s);\n        }\n\n        void prn(int i) {\n            out.println(i);\n        }\n\n        void prn(long i) {\n            out.println(i);\n        }\n\n        void prr(String s) {\n            out.print(s);\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        double nd() {\n            return in.nextDouble();\n        }\n\n        String ns() {\n            return in.nextString();\n        }\n\n        int[] ndi(int n) {\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ni();\n            }\n            return ans;\n        }\n\n        long[] ndl(int n) {\n            long[] ans = new long[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nl();\n            }\n            return ans;\n        }\n\n        double[] ndd(int n) {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nd();\n            }\n            return ans;\n        }\n\n        String[] nds(int n) {\n            String[] ans = new String[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ns();\n            }\n            return ans;\n        }\n\n        int[][] nddi(int n, int m) {\n            int[][] ans = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = ni();\n                }\n            }\n            return ans;\n        }\n\n        long[][] nddl(int n, int m) {\n            long[][] ans = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = nl();\n                }\n            }\n            return ans;\n        }\n    }\n\n    static class PP {\n        public int key, val;\n\n        public PP(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        public void setVal(int val) {\n            this.val = val;\n        }\n    }\n\n    static class PPP {\n        public int key, val1, val2;\n\n        public PPP(int key, int val1, int val2) {\n            this.key = key;\n            this.val1 = val1;\n            this.val2 = val2;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal1() {\n            return val1;\n        }\n\n        public void setVal1(int val1) {\n            this.val1 = val1;\n        }\n\n        public int getVal2() {\n            return val2;\n        }\n\n        public void setVal2(int val2) {\n            this.val2 = val2;\n        }\n    }\n\n    static class PPL {\n        public long key, val;\n\n        public PPL(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        public void setVal(long val) {\n            this.val = val;\n        }\n    }\n\n    static class PPDL {\n        public long key;\n        public long[] val;\n\n        public PPDL(long key, long[] val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long[] getVal() {\n            return val;\n        }\n\n        public void setVal(long[] val) {\n            this.val = val;\n        }\n\n        public void dump(PrintWriter out) {\n            out.print(\"key = \" + key + \"  val \");\n            for (int i = 0; i < val.length; i++) {\n                out.print(\"[\" + val[i] + \"] \");\n            }\n            out.println(\"\");\n        }\n    }\n\n    static final class PPKEY {\n        private final int key, val;\n\n        public PPKEY(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static final class PPLKEY {\n        private final long key, val;\n\n        public PPLKEY(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            double ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            int cnt = 0;\n            for (; i < len; i++) {\n                if (str[i] == '.') {\n                    cnt = 10;\n                    continue;\n                }\n                if (cnt == 0) {\n                    ret = ret * 10 + str[i] - '0';\n                } else {\n                    ret = ret + ((double) (str[i] - '0') / cnt);\n                    cnt *= 10;\n                }\n            }\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar()).trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n", "test_IO": {"input": ["3 3\n.#.\n###\n.#.\n"], "output": ["Yes\n"]}, "modified_context": "import static java.util.Comparator.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyInput in = new MyInput(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n\n        Solver solver = new Solver(in, out);\n        solver.solve();\n\n        out.close();\n    }\n\n    static class Solver {\n        MyInput in;\n        PrintWriter out;\n\n        public Solver(MyInput in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n        }\n\n        public void solve() {\n            int H = ni();\n            int W = ni();\n            char[][] C = new char[H + 2][W + 2];\n            char[] c;\n            for (int i = 0; i < H; i++) {\n                c = ns().toCharArray();\n                for (int j = 0; j < W; j++) {\n                    C[i + 1][j + 1] = c[j];\n                }\n            }\n            if (H == 1 && W == 1) {\n                prn(\"No\");\n                return;\n            }\n            for (int i = 1; i <= H; i++) {\n                for (int j = 1; j <= W; j++) {\n                    if (C[i][j] == '#'\n                            && C[i - 1][j] != '#'\n                            && C[i + 1][j] != '#'\n                            && C[i][j - 1] != '#'\n                            && C[i][j + 1] != '#') {\n                        prn(\"No\");\n                        return;\n                    }\n                }\n            }\n            prn(\"Yes\");\n        }\n\n        static class MapCounter {\n            private TreeMap<Integer, Integer> map;\n\n            public MapCounter() {\n                map = new TreeMap<>();\n            }\n\n            public MapCounter(boolean reverse) {\n                if (reverse) {\n                    map = new TreeMap<Integer, Integer>(Collections.reverseOrder() );\n                } else {\n                    map = new TreeMap<>();\n                }\n            }\n\n            public void add(Integer key) {\n                add(key, 1);\n            }\n\n            public void add(Integer key, int cnt) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    map.put(key, cnt);\n                } else {\n                    map.put(key, val + cnt);\n                }\n            }\n\n            public void remove(Integer key) {\n                sub(key, 1, false);\n            }\n\n            public void sub(Integer key) {\n                sub(key, 1);\n            }\n\n            public void sub(Integer key, int cnt) {\n                sub(key, cnt, true);\n            }\n\n            public void sub(Integer key, int cnt, boolean minus) {\n                Integer val = map.get(key);\n                if (val == null) {\n                    if (minus) {\n                        map.put(key, -cnt);\n                    }\n                } else if (val > cnt || minus) {\n                    map.put(key, val - cnt);\n                } else {\n                    map.remove(key);\n                }\n            }\n\n            public void set(Integer key, int cnt) {\n                map.put(key, cnt);\n            }\n\n            public Integer getCountwithNull(Integer key) {\n                return map.get(key);\n            }\n\n            public Integer getCount(Integer key) {\n                Integer val = map.get(key);\n                if (val == null) return 0;\n                else return val;\n            }\n\n            public Set<Integer> getKey() {\n                return map.keySet();\n            }\n\n            public int getKeyCount() {\n                return map.keySet().size();\n            }\n\n            public Integer getFirstKey() {\n                return map.firstKey();\n            }\n\n            public Integer getLastKey() {\n                return map.lastKey();\n            }\n\n            public void clear() {\n                map.clear();\n            }\n        }\n\n        boolean isRightMin(int[] a, boolean f, int index, int key) {\n            if (f && a[index] >= key) return true;\n            else if (!f && a[index] > key) return true;\n            else return false;\n        }\n\n        int binarySearchRightMin(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isRightMin(a, f, mid, key) ) ok = mid;\n                else ng = mid;\n            }\n            return ok;\n        }\n\n        boolean isLeftMax(int[] a, boolean f, int index, int key) {\n            if (f && a[index] <= key) return true;\n            else if (!f && a[index] < key) return true;\n            else return false;\n        }\n\n        int binarySearchLeftMax(int[] a, boolean f, int key) {\n            int ng = -1;\n            int ok = (int) a.length;\n\n            while (Math.abs(ok - ng) > 1) {\n                int mid = (ok + ng) / 2;\n\n                if (isLeftMax(a, f, mid, key) ) ng = mid;\n                else ok = mid;\n            }\n            return ng;\n        }\n\n        static class EulerTour {\n            Graph g;\n            List<Integer> euler_tour = new ArrayList<>();\n            int[] begin, end;\n            int k = 0, root = 0;\n\n            void dfs(int v, int p, PrintWriter out) {\n                out.println(\"v = \" + v + \"  p = \" + p);\n                begin[v] = k;\n                euler_tour.add(v);\n                k++;\n                if (!g.contains(v) ) {\n                    return;\n                }\n                for (int i : g.get(v) ) {\n                    if (i != p) {\n                        dfs(i, v, out);\n                        euler_tour.add(v);\n                        k++;\n                    }\n                }\n                end[v] = k;\n            }\n\n            public void init(int p_cnt, int root, Graph g, PrintWriter out) {\n                begin = new int[p_cnt + 1];\n                end = new int[p_cnt + 1];\n                this.root = root;\n                this.g = g;\n                dfs(root, -1, out);\n            }\n\n            public List getPartTour(int v) {\n                return euler_tour.subList(begin[v], end[v]);\n            }\n\n            public List<Integer> getPartList(int v) {\n                Set<Integer> set = new TreeSet<>();\n                set.addAll(getPartTour(v) );\n                List<Integer> ans = new ArrayList<>();\n                for (Integer p : set) {\n                    ans.add(p);\n                }\n                return ans;\n            }\n        }\n\n        class Graph {\n\n            private Map<Integer, List<Integer>> data = new HashMap<Integer, List<Integer>>();\n\n            void add(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    list = new ArrayList<Integer>();\n                    data.put(from, list);\n                }\n                list.add(to);\n            }\n\n            void del(int from, int to) {\n                List<Integer> list = data.get(from);\n                if (list == null) {\n                    return;\n                }\n                if (list.contains(to) ) {\n                    list.remove((Object) to);\n                }\n            }\n\n            List<Integer> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<Integer> list = data.get(key_1);\n                if (list == null) return false;\n                else return list.contains(key_2);\n            }\n\n            List<PP> distList(int key) {\n                List<PP> dist = new ArrayList<>();\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0) );\n                while (!stack.isEmpty() ) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist.add(new PP(pp, dd) );\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next) ) continue;\n                        stack.push(new PP(next, dd + 1) );\n                    }\n                }\n                return dist;\n            }\n\n            int[] distV(int key) {\n                int[] dist = new int[data.keySet().size() + 1];\n                Arrays.fill(dist, -1);\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key, 0) );\n                while (!stack.isEmpty() ) {\n                    PP wk = stack.pop();\n                    int pp = wk.getKey();\n                    int dd = wk.getVal();\n                    mark.add(pp);\n                    dist[pp] = dd;\n                    List<Integer> list = get(pp);\n                    for (int next : list) {\n                        if (mark.contains(next) ) continue;\n                        stack.push(new PP(next, dd + 1) );\n                    }\n                }\n                return dist;\n            }\n\n            Map<Integer, Integer> mapCnt = new HashMap<>();\n            Map<Integer, Integer> mapLow = new HashMap<>();\n\n            Set<Integer> mark = new HashSet<>();\n            int number;\n\n            int bridgeDfs(int now, int pre) {\n\n                mark.add(now);\n                mapCnt.put(now, number);\n                mapLow.put(now, number);\n                int low;\n                for (int next : get(now) ) {\n                    if (next == pre) continue;\n                    if (mark.contains(next) ) {\n                        if (mapLow.get(now) > mapLow.get(next) ) {\n\n                            mapLow.put(now, mapLow.get(next) );\n                        }\n                        continue;\n                    }\n                    number++;\n                    low = bridgeDfs(next, now);\n                    if (mapLow.get(now) > low) {\n                        mapLow.put(now, low);\n                    }\n                }\n                return mapLow.get(now);\n            }\n\n            int bridgeCnt(int start) {\n                mapCnt.clear();\n                mapLow.clear();\n                mark.clear();\n                number = 0;\n                bridgeDfs(start, start);\n                int ans = 0;\n                for (int key : mapCnt.keySet() ) {\n                    if (mapCnt.get(key) == mapLow.get(key) ) {\n                        ans++;\n                    }\n                }\n                return ans - 1;\n            }\n\n            void dump(PrintWriter out) {\n                for (int key : data.keySet() ) {\n                    out.print(key + \" : \");\n                    for (int val : data.get(key) ) {\n                        out.print(val + \" \");\n                    }\n                    out.println(\"\");\n                }\n            }\n        }\n\n        static class GraphWith {\n\n            private Map<Integer, List<PP>> data = new HashMap<Integer, List<PP>>();\n\n            void add(int key, PP p) {\n                List<PP> list = data.get(key);\n                if (list == null) {\n                    list = new ArrayList<PP>();\n                    data.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PP> get(int key) {\n                return data.get(key);\n            }\n\n            boolean contains(int key) {\n                return data.containsKey(key);\n            }\n\n            Set<Integer> getAllKeys() {\n                return data.keySet();\n            }\n\n            boolean isConnect(int key_1, int key_2) {\n                List<PP> list = data.get(key_1);\n                if (list == null) return false;\n                boolean ans = false;\n                for (PP p : list) {\n                    if (p.getKey() == key_2) {\n                        ans = true;\n                        break;\n                    }\n                }\n                return ans;\n            }\n\n            int distance(int key_1, int key_2) {\n                Set<Integer> mark = new HashSet<>();\n                Stack<PP> stack = new Stack<>();\n                stack.push(new PP(key_1, 0) );\n                PP wk;\n                int key, val;\n                List<PP> list;\n                while (!stack.isEmpty() ) {\n                    wk = stack.pop();\n                    key = wk.getKey();\n                    val = wk.getVal();\n                    mark.add(key);\n                    if (key == key_2) return val;\n\n                    list = get(key);\n                    if (list == null) continue;\n                    for (PP pp : list) {\n                        if (mark.contains(pp.getKey() ) ) continue;\n                        stack.push(new PP(pp.getKey(), val + pp.getVal() ) );\n                    }\n                }\n                return Integer.MAX_VALUE;\n            }\n        }\n\n        static class GraphLong {\n            private Map<Long, List<Long>> G = new HashMap<Long, List<Long>>();\n\n            void add(long key, long value) {\n                List<Long> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<Long>();\n                    G.put(key, list);\n                }\n                list.add(value);\n            }\n\n            List<Long> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        static class GraphLongWith {\n            private Map<Long, List<PPL>> G = new HashMap<Long, List<PPL>>();\n\n            void add(long key, PPL p) {\n                List<PPL> list = G.get(key);\n                if (list == null) {\n                    list = new ArrayList<PPL>();\n                    G.put(key, list);\n                }\n                list.add(p);\n            }\n\n            List<PPL> get(long key) {\n                return G.get(key);\n            }\n        }\n\n        void prn(String s) {\n            out.println(s);\n        }\n\n        void prn(int i) {\n            out.println(i);\n        }\n\n        void prn(long i) {\n            out.println(i);\n        }\n\n        void prr(String s) {\n            out.print(s);\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        long nl() {\n            return in.nextLong();\n        }\n\n        double nd() {\n            return in.nextDouble();\n        }\n\n        String ns() {\n            return in.nextString();\n        }\n\n        int[] ndi(int n) {\n            int[] ans = new int[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ni();\n            }\n            return ans;\n        }\n\n        long[] ndl(int n) {\n            long[] ans = new long[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nl();\n            }\n            return ans;\n        }\n\n        double[] ndd(int n) {\n            double[] ans = new double[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = nd();\n            }\n            return ans;\n        }\n\n        String[] nds(int n) {\n            String[] ans = new String[n];\n            for (int i = 0; i < n; i++) {\n                ans[i] = ns();\n            }\n            return ans;\n        }\n\n        int[][] nddi(int n, int m) {\n            int[][] ans = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = ni();\n                }\n            }\n            return ans;\n        }\n\n        long[][] nddl(int n, int m) {\n            long[][] ans = new long[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    ans[i][j] = nl();\n                }\n            }\n            return ans;\n        }\n    }\n\n    static class PP {\n        public int key, val;\n\n        public PP(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        public void setVal(int val) {\n            this.val = val;\n        }\n    }\n\n    static class PPP {\n        public int key, val1, val2;\n\n        public PPP(int key, int val1, int val2) {\n            this.key = key;\n            this.val1 = val1;\n            this.val2 = val2;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public void setKey(int key) {\n            this.key = key;\n        }\n\n        public int getVal1() {\n            return val1;\n        }\n\n        public void setVal1(int val1) {\n            this.val1 = val1;\n        }\n\n        public int getVal2() {\n            return val2;\n        }\n\n        public void setVal2(int val2) {\n            this.val2 = val2;\n        }\n    }\n\n    static class PPL {\n        public long key, val;\n\n        public PPL(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        public void setVal(long val) {\n            this.val = val;\n        }\n    }\n\n    static class PPDL {\n        public long key;\n        public long[] val;\n\n        public PPDL(long key, long[] val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public void setKey(long key) {\n            this.key = key;\n        }\n\n        public long[] getVal() {\n            return val;\n        }\n\n        public void setVal(long[] val) {\n            this.val = val;\n        }\n\n        public void dump(PrintWriter out) {\n            out.print(\"key = \" + key + \"  val \");\n            for (int i = 0; i < val.length; i++) {\n                out.print(\"[\" + val[i] + \"] \");\n            }\n            out.println(\"\");\n        }\n    }\n\n    static final class PPKEY {\n        private final int key, val;\n\n        public PPKEY(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public int getKey() {\n            return key;\n        }\n\n        public int getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static final class PPLKEY {\n        private final long key, val;\n\n        public PPLKEY(long key, long val) {\n            this.key = key;\n            this.val = val;\n        }\n\n        public long getKey() {\n            return key;\n        }\n\n        public long getVal() {\n            return val;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof PPKEY) {\n                PPKEY dest = (PPKEY) obj;\n                return this.key == dest.key && this.val == dest.val;\n            } else {\n                return false;\n            }\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(key, val);\n        }\n    }\n\n    static class Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n        private static final long serialVersionUID = 6411527075103472113L;\n\n        public Pair(final K key, final V value) {\n            super(key, value);\n        }\n    }\n\n    static class MyInput {\n        private final BufferedReader in;\n        private static int pos;\n        private static int readLen;\n        private static final char[] buffer = new char[1024 * 8];\n        private static char[] str = new char[500 * 8 * 2];\n        private static boolean[] isDigit = new boolean[256];\n        private static boolean[] isSpace = new boolean[256];\n        private static boolean[] isLineSep = new boolean[256];\n\n        static {\n            for (int i = 0; i < 10; i++) {\n                isDigit['0' + i] = true;\n            }\n            isDigit['-'] = true;\n            isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true;\n            isLineSep['\\r'] = isLineSep['\\n'] = true;\n        }\n\n        public MyInput(InputStream is) {\n            in = new BufferedReader(new InputStreamReader(is) );\n        }\n\n        public int read() {\n            if (pos >= readLen) {\n                pos = 0;\n                try {\n                    readLen = in.read(buffer);\n                } catch (IOException e) {\n                    throw new RuntimeException();\n                }\n                if (readLen <= 0) {\n                    throw new MyInput.EndOfFileRuntimeException();\n                }\n            }\n            return buffer[pos++];\n        }\n\n        public int nextInt() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            int ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public long nextLong() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            long ret = 0L;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            for (; i < len; i++) ret = ret * 10 + str[i] - '0';\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public double nextDouble() {\n            int len = 0;\n            str[len++] = nextChar();\n            len = reads(len, isSpace);\n            int i = 0;\n            double ret = 0;\n            if (str[0] == '-') {\n                i = 1;\n            }\n            int cnt = 0;\n            for (; i < len; i++) {\n                if (str[i] == '.') {\n                    cnt = 10;\n                    continue;\n                }\n                if (cnt == 0) {\n                    ret = ret * 10 + str[i] - '0';\n                } else {\n                    ret = ret + ((double) (str[i] - '0') / cnt);\n                    cnt *= 10;\n                }\n            }\n            if (str[0] == '-') {\n                ret = -ret;\n            }\n            return ret;\n        }\n\n        public String nextString() {\n            String ret = new String(nextDChar() ).trim();\n            return ret;\n        }\n\n        public char[] nextDChar() {\n            int len = 0;\n            len = reads(len, isSpace);\n            char[] ret = new char[len + 1];\n            for (int i = 0; i < len; i++) ret[i] = str[i];\n            ret[len] = 0x00;\n            return ret;\n        }\n\n        public char nextChar() {\n            while (true) {\n                final int c = read();\n                if (!isSpace[c]) {\n                    return (char) c;\n                }\n            }\n        }\n\n        int reads(int len, boolean[] accept) {\n            try {\n                while (true) {\n                    final int c = read();\n                    if (accept[c]) {\n                        break;\n                    }\n                    if (str.length == len) {\n                        char[] rep = new char[str.length * 3 / 2];\n                        System.arraycopy(str, 0, rep, 0, str.length);\n                        str = rep;\n                    }\n                    str[len++] = (char) c;\n                }\n            } catch (MyInput.EndOfFileRuntimeException e) {\n            }\n            return len;\n        }\n\n        static class EndOfFileRuntimeException extends RuntimeException {}\n    }\n}\n"}
{"id": "Java/121", "code": "import java.math.*;\nimport java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n\n        try (Scanner sc = new Scanner(System.in)) {\n\n            int n = Integer.parseInt(sc.next());\n            int m = Integer.parseInt(sc.next());\n\n            HashMap<Integer, Integer> map = new HashMap<>();\n\n            int countAc = 0;\n            int countWaAll = 0;\n\n            for (int i = 0; i < m; i++) {\n                int question = Integer.parseInt(sc.next());\n                String waOrAc = sc.next();\n\n                if (!map.containsKey(question)) {\n                    if (waOrAc.equals(\"WA\")) map.put(question, 1);\n                    else {\n                        map.put(question, -1);\n                        countAc++;\n                    }\n                } else {\n                    int countWa = map.get(question);\n                    if (countWa < 0)\n                        ;\n                    else {\n                        if (waOrAc.equals(\"WA\")) map.replace(question, countWa, countWa + 1);\n                        else {\n                            map.replace(question, countWa, -countWa);\n                            countAc++;\n                            countWaAll += countWa;\n                        }\n                    }\n                }\n            }\n\n            System.out.println(countAc + \" \" + countWaAll);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n", "test_IO": {"input": ["2 5\n1 WA\n1 AC\n2 WA\n2 AC\n2 WA\n"], "output": ["2 2\n"]}, "modified_context": "import java.math.*;\nimport java.util.*;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n\n        try (Scanner sc = new Scanner(System.in) ) {\n\n            int n = Integer.parseInt(sc.next() );\n            int m = Integer.parseInt(sc.next() );\n\n            HashMap<Integer, Integer> map = new HashMap<>();\n\n            int countAc = 0;\n            int countWaAll = 0;\n\n            for (int i = 0; i < m; i++) {\n                int question = Integer.parseInt(sc.next() );\n                String waOrAc = sc.next();\n\n                if (!map.containsKey(question) ) {\n                    if (waOrAc.equals(\"WA\") ) map.put(question, 1);\n                    else {\n                        map.put(question, -1);\n                        countAc++;\n                    }\n                } else {\n                    int countWa = map.get(question);\n                    if (countWa < 0)\n                        ;\n                    else {\n                        if (waOrAc.equals(\"WA\") ) map.replace(question, countWa, countWa + 1);\n                        else {\n                            map.replace(question, countWa, -countWa);\n                            countAc++;\n                            countWaAll += countWa;\n                        }\n                    }\n                }\n            }\n\n            System.out.println(countAc + \" \" + countWaAll);\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": "Java/122", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] arr = new int[n][3];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3; j++) arr[i][j] = sc.nextInt();\n        }\n\n        int ans = 0;\n\n        ans = dpx(arr, n);\n        System.out.println(ans);\n    }\n\n    static int min(int[] arr, int n) {\n        if (n == 1) return 0;\n        if (n == 2) return Math.abs(arr[n - 1] - arr[n - 2]);\n        int op1 = Math.abs(arr[n - 1] - arr[n - 2]) + min(arr, n - 1);\n        int op2 = Math.abs(arr[n - 1] - arr[n - 3]) + min(arr, n - 2);\n        int res = Math.min(op1, op2);\n\n        return res;\n    }\n\n    static int dpc(int[][] arr, int i, int n, int row) {\n        if (row == n) return 0;\n        int j = 0;\n        int k = 0;\n        if (i == 1) {\n            j = 0;\n            k = 2;\n        } else if (i == 0) {\n            j = 1;\n            k = 2;\n        } else {\n            j = 0;\n            k = 1;\n        }\n\n        return arr[row][i] + Math.max(dpc(arr, j, n, row + 1), dpc(arr, k, n, row + 1));\n    }\n\n    static int dpx(int[][] arr, int n) {\n        int[][] dp = new int[n][3];\n\n        dp[0][0] = arr[0][0];\n        dp[0][1] = arr[0][1];\n        dp[0][2] = arr[0][2];\n\n        for (int i = 1; i < n; i++) {\n            for (int in = 0; in < 3; in++) {\n                int j = 0, k = 0;\n                if (in == 1) {\n                    j = 0;\n                    k = 2;\n                } else if (in == 0) {\n                    j = 1;\n                    k = 2;\n                } else {\n                    j = 0;\n                    k = 1;\n                }\n                dp[i][in] = Math.max(dp[i - 1][k], dp[i - 1][j]) + arr[i][in];\n            }\n        }\n\n        return Math.max(dp[n - 1][0], Math.max(dp[n - 1][1], dp[n - 1][2]));\n    }\n}\n", "test_IO": {"input": ["3\n10 40 70\n20 50 80\n30 60 90\n"], "output": ["210\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int[][] arr = new int[n][3];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 3; j++) arr[i][j] = sc.nextInt();\n        }\n\n        int ans = 0;\n\n        ans = dpx(arr, n);\n        System.out.println(ans);\n    }\n\n    static int min(int[] arr, int n) {\n        if (n == 1) return 0;\n        if (n == 2) return Math.abs(arr[n - 1] - arr[n - 2]);\n        int op1 = Math.abs(arr[n - 1] - arr[n - 2]) + min(arr, n - 1);\n        int op2 = Math.abs(arr[n - 1] - arr[n - 3]) + min(arr, n - 2);\n        int res = Math.min(op1, op2);\n\n        return res;\n    }\n\n    static int dpc(int[][] arr, int i, int n, int row) {\n        if (row == n) return 0;\n        int j = 0;\n        int k = 0;\n        if (i == 1) {\n            j = 0;\n            k = 2;\n        } else if (i == 0) {\n            j = 1;\n            k = 2;\n        } else {\n            j = 0;\n            k = 1;\n        }\n\n        return arr[row][i] + Math.max(dpc(arr, j, n, row + 1), dpc(arr, k, n, row + 1) );\n    }\n\n    static int dpx(int[][] arr, int n) {\n        int[][] dp = new int[n][3];\n\n        dp[0][0] = arr[0][0];\n        dp[0][1] = arr[0][1];\n        dp[0][2] = arr[0][2];\n\n        for (int i = 1; i < n; i++) {\n            for (int in = 0; in < 3; in++) {\n                int j = 0, k = 0;\n                if (in == 1) {\n                    j = 0;\n                    k = 2;\n                } else if (in == 0) {\n                    j = 1;\n                    k = 2;\n                } else {\n                    j = 0;\n                    k = 1;\n                }\n                dp[i][in] = Math.max(dp[i - 1][k], dp[i - 1][j]) + arr[i][in];\n            }\n        }\n\n        return Math.max(dp[n - 1][0], Math.max(dp[n - 1][1], dp[n - 1][2]) );\n    }\n}\n"}
{"id": "Java/123", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        int min = Integer.MAX_VALUE;\n        int count = 0;\n        long sum = 0;\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n            if (A[i] < 0) count++;\n            min = Math.min(min, Math.abs(A[i]));\n            sum += Math.abs(A[i]);\n        }\n        sc.close();\n\n        if (count % 2 == 0) System.out.println(sum);\n        else {\n            System.out.println(sum - min * 2);\n        }\n    }\n}\n", "test_IO": {"input": ["3\n-10 5 -4\n"], "output": ["19\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int[] A = new int[N];\n        int min = Integer.MAX_VALUE;\n        int count = 0;\n        long sum = 0;\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n            if (A[i] < 0) count++;\n            min = Math.min(min, Math.abs(A[i]) );\n            sum += Math.abs(A[i]);\n        }\n        sc.close();\n\n        if (count % 2 == 0) System.out.println(sum);\n        else {\n            System.out.println(sum - min * 2);\n        }\n    }\n}\n"}
{"id": "Java/124", "code": "import java.util.*;\n\npublic class SampleSolution {\n    static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] $) {\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        String[] ans = new String[h];\n        for (int i = 0; i < h; i++) {\n            ans[i] = \"#\" + scanner.next() + \"#\";\n        }\n        System.out.println(String.valueOf(new char[w + 2]).replace('\\0', '#'));\n        for (String s : ans) {\n            System.out.println(s);\n        }\n        System.out.println(String.valueOf(new char[w + 2]).replace('\\0', '#'));\n    }\n}\n", "test_IO": {"input": ["2 3\nabc\narc\n"], "output": ["#####\n#abc#\n#arc#\n#####\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] $) {\n        int h = scanner.nextInt();\n        int w = scanner.nextInt();\n        String[] ans = new String[h];\n        for (int i = 0; i < h; i++) {\n            ans[i] = \"#\" + scanner.next() + \"#\";\n        }\n        System.out.println(String.valueOf(new char[w + 2]).replace('\\0', '#') );\n        for (String s : ans) {\n            System.out.println(s);\n        }\n        System.out.println(String.valueOf(new char[w + 2]).replace('\\0', '#') );\n    }\n}\n"}
{"id": "Java/127", "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass UnionFind {\n    int Parent[];\n\n    UnionFind(int n) {\n        Parent = new int[n];\n        Arrays.fill(Parent, -1);\n    }\n\n    int root(int A) {\n        if (Parent[A] < 0) return A;\n        return Parent[A] = root(Parent[A]);\n    }\n\n    int size(int A) {\n        return -Parent[root(A)];\n    }\n\n    boolean connect(int A, int B) {\n        A = root(A);\n        B = root(B);\n        if (A == B) return false;\n        if (size(A) < size(B)) {\n            int C = 0;\n            C = B;\n            B = A;\n            A = C;\n        }\n        Parent[A] += Parent[B];\n        Parent[B] = A;\n        return true;\n    }\n}\n\npublic class SampleSolution {\n    static FastScanner scan = new FastScanner();\n    static Scanner scanner = new Scanner(System.in);\n    static Random rand = new Random();\n    static long mod = 1000000007;\n    static double eps = 1.0E-14;\n    static int big = Integer.MAX_VALUE;\n    static double PI = 3.14159265358979323846262338327950288;\n\n    static long modlcm(long a, long b) {\n        return a * b * modint(gcd(a, b), mod);\n    }\n\n    static long gcd(long a, long b) {\n        return b > 0 ? gcd(b, a % b) : a;\n    }\n\n    static long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    static int max(int a, int b) {\n        return a > b ? a : b;\n    }\n\n    static int min(int a, int b) {\n        return a < b ? a : b;\n    }\n\n    static long lmax(long a, long b) {\n        return Math.max(a, b);\n    }\n\n    static long lmin(long a, long b) {\n        return Math.min(a, b);\n    }\n\n    static long factorial(int i) {\n        return i == 1 ? 1 : i * factorial(i - 1);\n    }\n\n    public static void main(String[] args) throws IOException {\n        String str = scan.next();\n        System.out.println(\n                str.charAt(2) == str.charAt(3) && str.charAt(4) == str.charAt(5) ? \"Yes\" : \"No\");\n    }\n\n    static int lower_bound(int a[], int key) {\n        int right = a.length;\n        int left = 0;\n        while (right - left > 1) {\n            int mid = (right + left) / 2;\n            if (a[mid] < key) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    static int upper_bound(int a[], int key) {\n        int right = a.length;\n        int left = 0;\n        while (right - left > 1) {\n            int mid = (right + left) / 2;\n            if (a[mid] <= key) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    static boolean isPrime(long n) {\n        if (n == 2) return true;\n        if (n < 2 || n % 2 == 0) return false;\n        double d = Math.sqrt(n);\n        for (int i = 3; i <= d; i += 2)\n            if (n % i == 0) {\n                return false;\n            }\n        return true;\n    }\n\n    static int upper_division(int a, int b) {\n        if (a % b == 0) {\n            return a / b;\n        } else {\n            return a / b + 1;\n        }\n    }\n\n    static long lupper_division(long a, long b) {\n        if (a % b == 0) {\n            return a / b;\n        } else {\n            return a / b + 1;\n        }\n    }\n\n    static int[] setArray(int a) {\n        int b[] = new int[a];\n        for (int i = 0; i < a; i++) {\n            b[i] = scan.nextInt();\n        }\n        return b;\n    }\n\n    static long[] lsetArray(int a) {\n        long b[] = new long[a];\n        for (int i = 0; i < a; i++) {\n            b[i] = scan.nextLong();\n        }\n        return b;\n    }\n\n    static String reverse(String str) {\n        char ch[] = new char[str.length()];\n        char chch[] = str.toCharArray();\n        int a = str.length();\n        for (int i = 0; i < upper_division(a, 2); i++) {\n            ch[i] = chch[ch.length - i - 1];\n            ch[ch.length - 1 - i] = chch[i];\n        }\n        return String.valueOf(ch);\n    }\n\n    public static void printArray(int[] que) {\n        for (int i = 0; i < que.length - 1; i++) {\n            System.out.print(que[i] + \" \");\n        }\n        System.out.println(que[que.length - 1]);\n    }\n\n    public static int[][] doublesort(int[][] a) {\n        Arrays.sort(a, (x, y) -> Integer.compare(x[0], y[0]));\n        return a;\n    }\n\n    public static long[][] ldoublesort(long[][] a) {\n        Arrays.sort(a, (x, y) -> Long.compare(x[0], y[0]));\n        return a;\n    }\n\n    static long modpow(long x, long n, long mo) {\n        long sum = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                sum = sum * x % mo;\n            }\n            x = x * x % mo;\n            n >>= 1;\n        }\n        return sum;\n    }\n\n    public static char[] revch(char ch[]) {\n        char ret[] = new char[ch.length];\n        for (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n            ret[j] = ch[i];\n        }\n        return ret;\n    }\n\n    public static int[] revint(int ch[]) {\n        int ret[] = new int[ch.length];\n        for (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n            ret[j] = ch[i];\n        }\n        return ret;\n    }\n\n    public static void warshall_floyd(int v[][], int n) {\n        for (int k = 0; k < n; k++)\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++) v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n    }\n\n    public static long modint(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while (b != 0) {\n            long t = a / b;\n            a -= t * b;\n            long x = a;\n            a = b;\n            b = x;\n\n            u -= t * v;\n            x = u;\n            u = v;\n            v = x;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextchar() {\n        try {\n            return (char) System.in.read();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "test_IO": {"input": ["sippuu\n"], "output": ["Yes\n"]}, "modified_context": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass UnionFind {\n    int Parent[];\n\n    UnionFind(int n) {\n        Parent = new int[n];\n        Arrays.fill(Parent, -1);\n    }\n\n    int root(int A) {\n        if (Parent[A] < 0) return A;\n        return Parent[A] = root(Parent[A]);\n    }\n\n    int size(int A) {\n        return -Parent[root(A)];\n    }\n\n    boolean connect(int A, int B) {\n        A = root(A);\n        B = root(B);\n        if (A == B) return false;\n        if (size(A) < size(B) ) {\n            int C = 0;\n            C = B;\n            B = A;\n            A = C;\n        }\n        Parent[A] += Parent[B];\n        Parent[B] = A;\n        return true;\n    }\n}\n\npublic class SampleSolution {\n    static FastScanner scan = new FastScanner();\n    static Scanner scanner = new Scanner(System.in);\n    static Random rand = new Random();\n    static long mod = 1000000007;\n    static double eps = 1.0E-14;\n    static int big = Integer.MAX_VALUE;\n    static double PI = 3.14159265358979323846262338327950288;\n\n    static long modlcm(long a, long b) {\n        return a * b * modint(gcd(a, b), mod);\n    }\n\n    static long gcd(long a, long b) {\n        return b > 0 ? gcd(b, a % b) : a;\n    }\n\n    static long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    static int max(int a, int b) {\n        return a > b ? a : b;\n    }\n\n    static int min(int a, int b) {\n        return a < b ? a : b;\n    }\n\n    static long lmax(long a, long b) {\n        return Math.max(a, b);\n    }\n\n    static long lmin(long a, long b) {\n        return Math.min(a, b);\n    }\n\n    static long factorial(int i) {\n        return i == 1 ? 1 : i * factorial(i - 1);\n    }\n\n    public static void main(String[] args) throws IOException {\n        String str = scan.next();\n        System.out.println(\n                str.charAt(2) == str.charAt(3) && str.charAt(4) == str.charAt(5) ? \"Yes\" : \"No\");\n    }\n\n    static int lower_bound(int a[], int key) {\n        int right = a.length;\n        int left = 0;\n        while (right - left > 1) {\n            int mid = (right + left) / 2;\n            if (a[mid] < key) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    static int upper_bound(int a[], int key) {\n        int right = a.length;\n        int left = 0;\n        while (right - left > 1) {\n            int mid = (right + left) / 2;\n            if (a[mid] <= key) {\n                left = mid;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n\n    static boolean isPrime(long n) {\n        if (n == 2) return true;\n        if (n < 2 || n % 2 == 0) return false;\n        double d = Math.sqrt(n);\n        for (int i = 3; i <= d; i += 2)\n            if (n % i == 0) {\n                return false;\n            }\n        return true;\n    }\n\n    static int upper_division(int a, int b) {\n        if (a % b == 0) {\n            return a / b;\n        } else {\n            return a / b + 1;\n        }\n    }\n\n    static long lupper_division(long a, long b) {\n        if (a % b == 0) {\n            return a / b;\n        } else {\n            return a / b + 1;\n        }\n    }\n\n    static int[] setArray(int a) {\n        int b[] = new int[a];\n        for (int i = 0; i < a; i++) {\n            b[i] = scan.nextInt();\n        }\n        return b;\n    }\n\n    static long[] lsetArray(int a) {\n        long b[] = new long[a];\n        for (int i = 0; i < a; i++) {\n            b[i] = scan.nextLong();\n        }\n        return b;\n    }\n\n    static String reverse(String str) {\n        char ch[] = new char[str.length()];\n        char chch[] = str.toCharArray();\n        int a = str.length();\n        for (int i = 0; i < upper_division(a, 2); i++) {\n            ch[i] = chch[ch.length - i - 1];\n            ch[ch.length - 1 - i] = chch[i];\n        }\n        return String.valueOf(ch);\n    }\n\n    public static void printArray(int[] que) {\n        for (int i = 0; i < que.length - 1; i++) {\n            System.out.print(que[i] + \" \");\n        }\n        System.out.println(que[que.length - 1]);\n    }\n\n    public static int[][] doublesort(int[][] a) {\n        Arrays.sort(a, (x, y) -> Integer.compare(x[0], y[0]) );\n        return a;\n    }\n\n    public static long[][] ldoublesort(long[][] a) {\n        Arrays.sort(a, (x, y) -> Long.compare(x[0], y[0]) );\n        return a;\n    }\n\n    static long modpow(long x, long n, long mo) {\n        long sum = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                sum = sum * x % mo;\n            }\n            x = x * x % mo;\n            n >>= 1;\n        }\n        return sum;\n    }\n\n    public static char[] revch(char ch[]) {\n        char ret[] = new char[ch.length];\n        for (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n            ret[j] = ch[i];\n        }\n        return ret;\n    }\n\n    public static int[] revint(int ch[]) {\n        int ret[] = new int[ch.length];\n        for (int i = ch.length - 1, j = 0; i >= 0; i--, j++) {\n            ret[j] = ch[i];\n        }\n        return ret;\n    }\n\n    public static void warshall_floyd(int v[][], int n) {\n        for (int k = 0; k < n; k++)\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++) v[i][j] = min(v[i][j], v[i][k] + v[k][j]);\n    }\n\n    public static long modint(long a, long m) {\n        long b = m, u = 1, v = 0;\n        while (b != 0) {\n            long t = a / b;\n            a -= t * b;\n            long x = a;\n            a = b;\n            b = x;\n\n            u -= t * v;\n            x = u;\n            u = v;\n            v = x;\n        }\n        u %= m;\n        if (u < 0) u += m;\n        return u;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte() ) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b) ) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b) ) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n\n    public char nextchar() {\n        try {\n            return (char) System.in.read();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n"}
{"id": "Java/129", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isUpperCase(c)) {\n                c += 32;\n                System.out.print(c);\n            } else if (Character.isLowerCase(c)) {\n                c -= 32;\n                System.out.print(c);\n            } else System.out.print(c);\n        }\n        System.out.println();\n        sc.close();\n    }\n}\n", "test_IO": {"input": ["fAIR, LATER, OCCASIONALLY CLOUDY.\n"], "output": ["Fair, later, occasionally cloudy.\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (Character.isUpperCase(c) ) {\n                c += 32;\n                System.out.print(c);\n            } else if (Character.isLowerCase(c) ) {\n                c -= 32;\n                System.out.print(c);\n            } else System.out.print(c);\n        }\n        System.out.println();\n        sc.close();\n    }\n}\n"}
{"id": "Java/134", "code": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    void tr(Object... os) {\n        System.err.println(deepToString(os));\n    }\n\n    Scanner sc = new Scanner(System.in);\n\n    public void run() {\n        for (; sc.hasNext(); ) {\n            int my1 = sc.nextInt();\n            int my2 = sc.nextInt();\n            int enemy1 = sc.nextInt();\n            boolean[] used = new boolean[11];\n            used[my1] = true;\n            used[my2] = true;\n            used[enemy1] = true;\n            int all = 0;\n            int safe = 0;\n            for (int i = 1; i <= 10; i++)\n                if (!used[i]) {\n                    all++;\n                    if (my1 + my2 + i <= 20) safe++;\n                }\n            if (safe * 2 >= all) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n    }\n\n    char solve(int[][] a) {\n        char[] s = {'d', 'o', 'x'};\n        for (int side = 1; side <= 2; side++) {\n            for (int i = 0; i < 3; i++) {\n                if (a[i][0] == side && a[i][1] == side && a[i][2] == side) return s[side];\n                if (a[0][i] == side && a[1][i] == side && a[2][i] == side) return s[side];\n            }\n            if (a[0][0] == side && a[1][1] == side && a[2][2] == side) return s[side];\n            if (a[0][2] == side && a[1][1] == side && a[2][0] == side) return s[side];\n        }\n        return 'd';\n    }\n}\n", "test_IO": {"input": ["1 2 3\n5 6 9\n8 9 10\n"], "output": ["YES\nYES\nNO\n"]}, "modified_context": "import static java.util.Arrays.deepToString;\n\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    void tr(Object... os) {\n        System.err.println(deepToString(os) );\n    }\n\n    Scanner sc = new Scanner(System.in);\n\n    public void run() {\n        for (; sc.hasNext(); ) {\n            int my1 = sc.nextInt();\n            int my2 = sc.nextInt();\n            int enemy1 = sc.nextInt();\n            boolean[] used = new boolean[11];\n            used[my1] = true;\n            used[my2] = true;\n            used[enemy1] = true;\n            int all = 0;\n            int safe = 0;\n            for (int i = 1; i <= 10; i++)\n                if (!used[i]) {\n                    all++;\n                    if (my1 + my2 + i <= 20) safe++;\n                }\n            if (safe * 2 >= all) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n    }\n\n    char solve(int[][] a) {\n        char[] s = {'d', 'o', 'x'};\n        for (int side = 1; side <= 2; side++) {\n            for (int i = 0; i < 3; i++) {\n                if (a[i][0] == side && a[i][1] == side && a[i][2] == side) return s[side];\n                if (a[0][i] == side && a[1][i] == side && a[2][i] == side) return s[side];\n            }\n            if (a[0][0] == side && a[1][1] == side && a[2][2] == side) return s[side];\n            if (a[0][2] == side && a[1][1] == side && a[2][0] == side) return s[side];\n        }\n        return 'd';\n    }\n}\n"}
{"id": "Java/136", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static void solve() {\n        String tmp = ns();\n        char s[] = tmp.toCharArray();\n        int n = s.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'S') {\n                cnt++;\n            } else {\n                if (cnt == 0) continue;\n                ans++;\n                cnt--;\n            }\n        }\n        out.println(n - 2 * ans);\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i));\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName()));\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1)) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte()) != -1 && isSpaceChar(b))\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b))) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b))) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n", "test_IO": {"input": ["TSTTSS\n"], "output": ["4\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static void solve() {\n        String tmp = ns();\n        char s[] = tmp.toCharArray();\n        int n = s.length;\n        int ans = 0;\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            if (s[i] == 'S') {\n                cnt++;\n            } else {\n                if (cnt == 0) continue;\n                ans++;\n                cnt--;\n            }\n        }\n        out.println(n - 2 * ans);\n    }\n\n    static final long mod = (long) 1e9 + 7;\n    static final int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n    static final int[] dx8 = {-1, -1, -1, 0, 0, 1, 1, 1}, dy8 = {-1, 0, 1, -1, 1, -1, 0, 1};\n    static final int inf = Integer.MAX_VALUE / 2;\n    static final long linf = Long.MAX_VALUE / 3;\n    static final double dinf = Double.MAX_VALUE / 3;\n    static final double eps = 1e-10;\n    static final double pi = Math.PI;\n    static StringBuilder sb = new StringBuilder();\n    static InputStream is;\n    static PrintWriter out;\n    static String INPUT = \"\";\n\n    static void reverse(int ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(long ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(double ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void reverse(char ar[]) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static String getReverse(String s) {\n        char c[] = s.toCharArray();\n        reverse(c);\n        s = String.valueOf(c);\n        return s;\n    }\n\n    static <T> void reverse(List<T> ls) {\n        int sz = ls.size();\n        for (int i = 0; i < sz / 2; i++) {\n            T t = ls.get(i);\n            ls.set(i, ls.get(sz - 1 - i) );\n            ls.set(sz - 1 - i, t);\n        }\n    }\n\n    static <T> void reverse(T[] ar) {\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            T t = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = t;\n        }\n    }\n\n    static void sbnl() {\n        sb.append(\"\\n\");\n    }\n\n    static int lowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(int[] a, int x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(long[] a, long x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(double[] a, double x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int lowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] < x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int upperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] <= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rlowerBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] > x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static int rupperBound(char[] a, char x) {\n        int l = -1, r = a.length;\n        while (r - l > 1) {\n            int c = (l + r) / 2;\n            if (a[c] >= x) {\n                l = c;\n            } else {\n                r = c;\n            }\n        }\n        return r;\n    }\n\n    static <T> int lowerBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) >= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) >= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int upperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) > 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) > 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rupperBound(List<T> ls, T x) throws RuntimeException {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) < 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) < 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static <T> int rlowerBound(List<T> ls, T x) {\n        if (ls.size() == 0) return -1;\n        if (ls.get(0) instanceof Integer) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Integer) t1).compareTo((Integer) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Long) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Long) t1).compareTo((Long) t2) <= 0 ? 1 : -1);\n        } else if (ls.get(0) instanceof Double) {\n            return ~Collections.binarySearch(\n                    ls, x, (t1, t2) -> ((Double) t1).compareTo((Double) t2) <= 0 ? 1 : -1);\n        } else {\n            System.err.println(\n                    String.format(\n                            \"%s: Performing binary search on a non-numeric list.\",\n                            Thread.currentThread().getStackTrace()[1].getMethodName() ) );\n            throw new RuntimeException();\n        }\n    }\n\n    static int[] concat(int x, int arr[]) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static int[] concat(int arr[], int x) {\n        int ret[] = new int[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static long[] concat(long x, long arr[]) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 1, ret.length - 1);\n        ret[0] = x;\n        return ret;\n    }\n\n    static long[] concat(long arr[], long x) {\n        long ret[] = new long[arr.length + 1];\n        System.arraycopy(arr, 0, ret, 0, ret.length - 1);\n        ret[ret.length - 1] = x;\n        return ret;\n    }\n\n    static int max(int x, int y) {\n        return Math.max(x, y);\n    }\n\n    static int min(int x, int y) {\n        return Math.min(x, y);\n    }\n\n    static int max(int x, int y, int z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static int min(int x, int y, int z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static long max(long x, long y) {\n        return Math.max(x, y);\n    }\n\n    static long min(long x, long y) {\n        return Math.min(x, y);\n    }\n\n    static long max(long x, long y, long z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static long min(long x, long y, long z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static double max(double x, double y) {\n        return Math.max(x, y);\n    }\n\n    static double min(double x, double y) {\n        return Math.min(x, y);\n    }\n\n    static double max(double x, double y, double z) {\n        x = Math.max(x, y);\n        x = Math.max(x, z);\n        return x;\n    }\n\n    static double min(double x, double y, double z) {\n        x = Math.min(x, y);\n        x = Math.min(x, z);\n        return x;\n    }\n\n    static void sort(int[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(long[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(double[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void sort(char[] ar) {\n        Arrays.sort(ar);\n    }\n\n    static void rsort(int[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            int tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(long[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            long tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(double[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            double tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void rsort(char[] ar) {\n        Arrays.sort(ar);\n        int len = ar.length;\n        for (int i = 0; i < len / 2; i++) {\n            char tmp = ar[i];\n            ar[i] = ar[len - 1 - i];\n            ar[len - 1 - i] = tmp;\n        }\n    }\n\n    static void fill(int arr[], int x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(long arr[], long x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(boolean arr[], boolean x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(double arr[], double x) {\n        Arrays.fill(arr, x);\n    }\n\n    static void fill(int arr[][], int x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(long arr[][], long x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(double arr[][], double x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static void fill(boolean arr[][], boolean x) {\n        for (int i = 0; i < arr.length; i++) Arrays.fill(arr[i], x);\n    }\n\n    static long plus(long x, long y) {\n        long res = (x + y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long sub(long x, long y) {\n        long res = (x - y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long mul(long x, long y) {\n        long res = (x * y) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long div(long x, long y) {\n        long res = x * pow(y, mod - 2) % mod;\n        return res < 0 ? res + mod : res;\n    }\n\n    static long pow(long x, long y) {\n        if (y < 0) return 0;\n        if (y == 0) return 1;\n        if (y % 2 == 1) return (x * pow(x, y - 1) ) % mod;\n        long root = pow(x, y / 2);\n        return root * root % mod;\n    }\n\n    public static void main(String[] args) throws Exception {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes() );\n        out = new PrintWriter(System.out);\n        solve();\n        out.flush();\n    }\n\n    private static byte[] inbuf = new byte[1024];\n    static int lenbuf = 0, ptrbuf = 0;\n\n    private static int readByte() {\n        if (lenbuf == -1) throw new InputMismatchException();\n        if (ptrbuf >= lenbuf) {\n            ptrbuf = 0;\n            try {\n                lenbuf = is.read(inbuf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (lenbuf <= 0) return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n\n    private static boolean isSpaceChar(int c) {\n        return !(c >= 33 && c <= 126);\n    }\n\n    private static int skip() {\n        int b;\n        while ((b = readByte() ) != -1 && isSpaceChar(b) )\n            ;\n        return b;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static double nd() {\n        return Double.parseDouble(ns() );\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char nc() {\n        return (char) skip();\n    }\n\n    private static String ns() {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while (!(isSpaceChar(b) ) ) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    private static char[] ns(int n) {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while (p < n && !(isSpaceChar(b) ) ) {\n            buf[p++] = (char) b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static char[][] nm(int n, int m) {\n        char[][] map = new char[n][];\n        for (int i = 0; i < n; i++) map[i] = ns(m);\n        return map;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int[] na(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = ni();\n        return a;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long[] nla(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nl();\n        return a;\n    }\n\n    private static int ni() {\n        int num = 0, b;\n        boolean minus = false;\n        while ((b = readByte() ) != -1 && !((b >= '0' && b <= '9') || b == '-') )\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static long nl() {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while ((b = readByte() ) != -1 && !((b >= '0' && b <= '9') || b == '-') )\n            ;\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n\n        while (true) {\n            if (b >= '0' && b <= '9') {\n                num = num * 10 + (b - '0');\n            } else {\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n}\n"}
{"id": "Java/140", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String array[] = new String[n];\n        int cnt = 0;\n        int cnt2 = 0;\n\n        for (int i = 0; i < n; i++) {\n            array[i] = sc.next();\n        }\n\n        Arrays.sort(array);\n\n        String a = array[0];\n        cnt++;\n        for (int i = 0; i < n; i++) {\n\n            if (a.equals(array[i])) {\n\n            } else {\n                cnt++;\n            }\n            a = array[i];\n        }\n        System.out.println(cnt);\n    }\n}\n", "test_IO": {"input": ["3\napple\norange\napple\n"], "output": ["2\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String array[] = new String[n];\n        int cnt = 0;\n        int cnt2 = 0;\n\n        for (int i = 0; i < n; i++) {\n            array[i] = sc.next();\n        }\n\n        Arrays.sort(array);\n\n        String a = array[0];\n        cnt++;\n        for (int i = 0; i < n; i++) {\n\n            if (a.equals(array[i]) ) {\n\n            } else {\n                cnt++;\n            }\n            a = array[i];\n        }\n        System.out.println(cnt);\n    }\n}\n"}
{"id": "Java/142", "code": "import java.util.*;\n\nclass SampleSolution {\n\n    public static void main(String[] args) throws java.lang.Exception {\n\n        Scanner sc = new Scanner(System.in);\n        int count = sc.nextInt();\n\n        for (int i = 0; count > i; i++) {\n            int y = sc.nextInt();\n            int m = sc.nextInt();\n            int d = sc.nextInt();\n\n            System.out.println(Answer(y, m, d));\n        }\n    }\n\n    public static int Answer(int y, int m, int d) {\n        int result = 1;\n\n        if (y % 3 == 0) {\n            result += 20 - d;\n        } else if (m % 2 == 0) {\n            result += 19 - d;\n        } else {\n            result += 20 - d;\n        }\n\n        for (m += 1; m <= 10; m++) {\n            if (y % 3 == 0) {\n                result += 20;\n            } else {\n                if (m % 2 == 0) {\n                    result += 19;\n                } else {\n                    result += 20;\n                }\n            }\n        }\n\n        for (y += 1; y < 1000; y++) {\n            if (y % 3 == 0) {\n                result += 200;\n            } else {\n                result += 195;\n            }\n        }\n        return result;\n    }\n}\n", "test_IO": {"input": ["8\n1 1 1\n344 3 1\n696 5 1\n182 9 5\n998 8 7\n344 2 19\n696 4 19\n999 10 20\n"], "output": ["196470\n128976\n59710\n160715\n252\n128977\n59712\n1\n"]}, "modified_context": "import java.util.*;\n\nclass SampleSolution {\n\n    public static void main(String[] args) throws java.lang.Exception {\n\n        Scanner sc = new Scanner(System.in);\n        int count = sc.nextInt();\n\n        for (int i = 0; count > i; i++) {\n            int y = sc.nextInt();\n            int m = sc.nextInt();\n            int d = sc.nextInt();\n\n            System.out.println(Answer(y, m, d) );\n        }\n    }\n\n    public static int Answer(int y, int m, int d) {\n        int result = 1;\n\n        if (y % 3 == 0) {\n            result += 20 - d;\n        } else if (m % 2 == 0) {\n            result += 19 - d;\n        } else {\n            result += 20 - d;\n        }\n\n        for (m += 1; m <= 10; m++) {\n            if (y % 3 == 0) {\n                result += 20;\n            } else {\n                if (m % 2 == 0) {\n                    result += 19;\n                } else {\n                    result += 20;\n                }\n            }\n        }\n\n        for (y += 1; y < 1000; y++) {\n            if (y % 3 == 0) {\n                result += 200;\n            } else {\n                result += 195;\n            }\n        }\n        return result;\n    }\n}\n"}
{"id": "Java/146", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static PrintWriter pw;\n    static Scanner sc;\n    static ArrayList<Integer>[] adj;\n    static boolean[] visit;\n    static HashMap<Pair, Integer> dp;\n\n    static long ceildiv(long x, long y) {\n        return (x + y - 1) / y;\n    }\n\n    static int mod(long x, int m) {\n        return (int) ((x % m + m) % m);\n    }\n\n    static HashMap<Integer, Integer> map;\n\n    static long gcd(long x, long y) {\n        return y == 0 ? x : gcd(y, x % y);\n    }\n\n    static int Int(boolean x) {\n        return x ? 1 : 0;\n    }\n\n    static void put(TreeMap<Pair, Integer> map, Pair p) {\n        if (map.containsKey(p)) map.replace(p, map.get(p) + 1);\n        else map.put(p, 1);\n    }\n\n    static void rem(TreeMap<Pair, Integer> map, Pair p) {\n        if (map.get(p) == 1) map.remove(p);\n        else map.replace(p, map.get(p) - 1);\n    }\n\n    public static void main(String[] args) throws Exception {\n        sc = new Scanner(System.in);\n        pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        Integer[] arr = sc.nextsort(n);\n        Arrays.sort(arr, Collections.reverseOrder());\n        if (n >= 3) {\n            TreeMap<Pair, Integer> map = new TreeMap<>(Collections.reverseOrder());\n            long ans = arr[0] + arr[1];\n            map.put(new Pair(arr[0], arr[1]), 1);\n            Pair p1 = new Pair(arr[2], arr[1]), p2 = new Pair(arr[2], arr[0]);\n            put(map, p1);\n            put(map, p2);\n            for (int i = 3; i < n; i++) {\n                Pair p = map.firstKey();\n                rem(map, p);\n                ans += Math.min(p.x, p.y);\n                put(map, new Pair(p.x, arr[i]));\n                put(map, new Pair(p.y, arr[i]));\n            }\n            pw.println(ans);\n        } else {\n            pw.println(arr[0]);\n        }\n        pw.close();\n    }\n\n    static void fill(int[] arr, int x) {\n        for (int i = 0; i < 30; i++) arr[i] += Int(((1 << i) & x) != 0);\n    }\n\n    static long pow(long a, long pow) {\n        long ans = 1;\n        while (pow > 0) {\n            if ((pow & 1) == 1) ans *= a;\n            a *= a;\n            pow >>= 1;\n        }\n        return ans;\n    }\n\n    static int getpow(int x) throws Exception {\n        int pow = x;\n        pw.println(\"B \" + pow);\n        pw.flush();\n        sc.next();\n        pw.println(\"B \" + pow);\n        pw.flush();\n        if (sc.nextInt() == 1) {\n            pow *= x;\n            while (true) {\n                pw.println(\"B \" + pow);\n                pw.flush();\n                if (sc.nextInt() == 0) return pow / x;\n                pow *= x;\n            }\n        } else {\n            return 1;\n        }\n    }\n\n    static int[] least;\n    static TreeSet<Integer> prime;\n\n    static void linearsieve(int x) {\n        least = new int[x + 1];\n        prime = new TreeSet<Integer>();\n        for (int i = 2; i <= x; i++) {\n            if (least[i] == 0) {\n                least[i] = i;\n                prime.add(i);\n            }\n            for (int y : prime) {\n                if (i * y <= x) least[i * y] = y;\n                else break;\n            }\n        }\n    }\n\n    static void printArr(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) pw.print(arr[i] + \" \");\n        pw.println(arr[arr.length - 1]);\n    }\n\n    static void printArr(long[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) pw.print(arr[i] + \" \");\n        pw.println(arr[arr.length - 1]);\n    }\n\n    static void printArr(Integer[] arr) {\n        for (int i = 0; i < arr.length; i++) pw.print(arr[i] + \" \");\n        pw.println();\n    }\n\n    static void printArr(char[] arr) {\n        for (int i = 0; i < arr.length; i++) pw.print(arr[i] == 0 ? '1' : arr[i]);\n        pw.println();\n    }\n\n    static void printArr(ArrayList<Integer> list) {\n        for (int i = 0; i < list.size(); i++) pw.print(list.get(i) + \" \");\n        pw.println();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        public int[] nextArr(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < arr.length; i++) arr[i] = nextInt();\n            return arr;\n        }\n\n        public Integer[] nextsort(int n) throws IOException {\n            Integer[] arr = new Integer[n];\n            for (int i = 0; i < n; i++) arr[i] = nextInt();\n            return arr;\n        }\n\n        public Pair nextPair() throws IOException {\n            return new Pair(nextInt(), nextInt());\n        }\n\n        public Pair[] nextPairArr(int n) throws IOException {\n            Pair[] arr = new Pair[n];\n            for (int i = 0; i < n; i++) arr[i] = nextPair();\n            return arr;\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int x;\n        int y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int hashCode() {\n            return (this.x * 1000 + this.y);\n        }\n\n        @Override\n        public int compareTo(Pair p) {\n            int min1 = Math.min(x, y), min2 = Math.min(p.x, p.y);\n            if (min1 != min2) return min1 - min2;\n            if (x == p.x) return y - p.y;\n            return x - p.x;\n        }\n\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (this.getClass() != obj.getClass()) {\n                return false;\n            }\n            Pair p = (Pair) obj;\n            return this.x == p.x && this.y == p.y;\n        }\n\n        public Pair clone() {\n            return new Pair(x, y);\n        }\n\n        public String toString() {\n            return this.x + \" \" + this.y;\n        }\n\n        public void add(Pair p) {\n            x += p.x;\n            y += p.y;\n        }\n    }\n}\n", "test_IO": {"input": ["4\n2 2 1 3\n"], "output": ["7\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static PrintWriter pw;\n    static Scanner sc;\n    static ArrayList<Integer>[] adj;\n    static boolean[] visit;\n    static HashMap<Pair, Integer> dp;\n\n    static long ceildiv(long x, long y) {\n        return (x + y - 1) / y;\n    }\n\n    static int mod(long x, int m) {\n        return (int) ((x % m + m) % m);\n    }\n\n    static HashMap<Integer, Integer> map;\n\n    static long gcd(long x, long y) {\n        return y == 0 ? x : gcd(y, x % y);\n    }\n\n    static int Int(boolean x) {\n        return x ? 1 : 0;\n    }\n\n    static void put(TreeMap<Pair, Integer> map, Pair p) {\n        if (map.containsKey(p) ) map.replace(p, map.get(p) + 1);\n        else map.put(p, 1);\n    }\n\n    static void rem(TreeMap<Pair, Integer> map, Pair p) {\n        if (map.get(p) == 1) map.remove(p);\n        else map.replace(p, map.get(p) - 1);\n    }\n\n    public static void main(String[] args) throws Exception {\n        sc = new Scanner(System.in);\n        pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        Integer[] arr = sc.nextsort(n);\n        Arrays.sort(arr, Collections.reverseOrder() );\n        if (n >= 3) {\n            TreeMap<Pair, Integer> map = new TreeMap<>(Collections.reverseOrder() );\n            long ans = arr[0] + arr[1];\n            map.put(new Pair(arr[0], arr[1]), 1);\n            Pair p1 = new Pair(arr[2], arr[1]), p2 = new Pair(arr[2], arr[0]);\n            put(map, p1);\n            put(map, p2);\n            for (int i = 3; i < n; i++) {\n                Pair p = map.firstKey();\n                rem(map, p);\n                ans += Math.min(p.x, p.y);\n                put(map, new Pair(p.x, arr[i]) );\n                put(map, new Pair(p.y, arr[i]) );\n            }\n            pw.println(ans);\n        } else {\n            pw.println(arr[0]);\n        }\n        pw.close();\n    }\n\n    static void fill(int[] arr, int x) {\n        for (int i = 0; i < 30; i++) arr[i] += Int(((1 << i) & x) != 0);\n    }\n\n    static long pow(long a, long pow) {\n        long ans = 1;\n        while (pow > 0) {\n            if ((pow & 1) == 1) ans *= a;\n            a *= a;\n            pow >>= 1;\n        }\n        return ans;\n    }\n\n    static int getpow(int x) throws Exception {\n        int pow = x;\n        pw.println(\"B \" + pow);\n        pw.flush();\n        sc.next();\n        pw.println(\"B \" + pow);\n        pw.flush();\n        if (sc.nextInt() == 1) {\n            pow *= x;\n            while (true) {\n                pw.println(\"B \" + pow);\n                pw.flush();\n                if (sc.nextInt() == 0) return pow / x;\n                pow *= x;\n            }\n        } else {\n            return 1;\n        }\n    }\n\n    static int[] least;\n    static TreeSet<Integer> prime;\n\n    static void linearsieve(int x) {\n        least = new int[x + 1];\n        prime = new TreeSet<Integer>();\n        for (int i = 2; i <= x; i++) {\n            if (least[i] == 0) {\n                least[i] = i;\n                prime.add(i);\n            }\n            for (int y : prime) {\n                if (i * y <= x) least[i * y] = y;\n                else break;\n            }\n        }\n    }\n\n    static void printArr(int[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) pw.print(arr[i] + \" \");\n        pw.println(arr[arr.length - 1]);\n    }\n\n    static void printArr(long[] arr) {\n        for (int i = 0; i < arr.length - 1; i++) pw.print(arr[i] + \" \");\n        pw.println(arr[arr.length - 1]);\n    }\n\n    static void printArr(Integer[] arr) {\n        for (int i = 0; i < arr.length; i++) pw.print(arr[i] + \" \");\n        pw.println();\n    }\n\n    static void printArr(char[] arr) {\n        for (int i = 0; i < arr.length; i++) pw.print(arr[i] == 0 ? '1' : arr[i]);\n        pw.println();\n    }\n\n    static void printArr(ArrayList<Integer> list) {\n        for (int i = 0; i < list.size(); i++) pw.print(list.get(i) + \" \");\n        pw.println();\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s) );\n        }\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens() ) st = new StringTokenizer(br.readLine() );\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next() );\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next() );\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            return Double.parseDouble(next() );\n        }\n\n        public int[] nextArr(int n) throws IOException {\n            int[] arr = new int[n];\n            for (int i = 0; i < arr.length; i++) arr[i] = nextInt();\n            return arr;\n        }\n\n        public Integer[] nextsort(int n) throws IOException {\n            Integer[] arr = new Integer[n];\n            for (int i = 0; i < n; i++) arr[i] = nextInt();\n            return arr;\n        }\n\n        public Pair nextPair() throws IOException {\n            return new Pair(nextInt(), nextInt() );\n        }\n\n        public Pair[] nextPairArr(int n) throws IOException {\n            Pair[] arr = new Pair[n];\n            for (int i = 0; i < n; i++) arr[i] = nextPair();\n            return arr;\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int x;\n        int y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int hashCode() {\n            return (this.x * 1000 + this.y);\n        }\n\n        @Override\n        public int compareTo(Pair p) {\n            int min1 = Math.min(x, y), min2 = Math.min(p.x, p.y);\n            if (min1 != min2) return min1 - min2;\n            if (x == p.x) return y - p.y;\n            return x - p.x;\n        }\n\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (this.getClass() != obj.getClass() ) {\n                return false;\n            }\n            Pair p = (Pair) obj;\n            return this.x == p.x && this.y == p.y;\n        }\n\n        public Pair clone() {\n            return new Pair(x, y);\n        }\n\n        public String toString() {\n            return this.x + \" \" + this.y;\n        }\n\n        public void add(Pair p) {\n            x += p.x;\n            y += p.y;\n        }\n    }\n}\n"}
{"id": "Java/149", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        StringTokenizer s = new StringTokenizer(br.readLine());\n\n        int n = Integer.parseInt(s.nextToken());\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        s = new StringTokenizer(br.readLine());\n        for (int i = 0; i < n; i++) {\n            int val = Integer.parseInt(s.nextToken());\n            hm.put(val, hm.getOrDefault(val, 0) + 1);\n        }\n        int ans = 0;\n        for (int val : hm.keySet()) {\n            int num = hm.get(val);\n            if (num > val) ans += num - val;\n            else if (num < val) ans += num;\n        }\n        pw.println(ans);\n        pw.close();\n    }\n}\n", "test_IO": {"input": ["4\n3 3 3 3\n"], "output": ["1\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out) ) );\n        StringTokenizer s = new StringTokenizer(br.readLine() );\n\n        int n = Integer.parseInt(s.nextToken() );\n        HashMap<Integer, Integer> hm = new HashMap<>();\n        s = new StringTokenizer(br.readLine() );\n        for (int i = 0; i < n; i++) {\n            int val = Integer.parseInt(s.nextToken() );\n            hm.put(val, hm.getOrDefault(val, 0) + 1);\n        }\n        int ans = 0;\n        for (int val : hm.keySet() ) {\n            int num = hm.get(val);\n            if (num > val) ans += num - val;\n            else if (num < val) ans += num;\n        }\n        pw.println(ans);\n        pw.close();\n    }\n}\n"}
{"id": "Java/151", "code": "import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution implements Runnable {\n    @Override\n    public void run() {\n        try {\n            new Solver().solve();\n            System.exit(0);\n        } catch (Exception | Error e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        new SampleSolution().run();\n    }\n}\n\nclass Solver {\n    final Helper hp;\n    final int MAXN = 1000_006;\n    final long MOD = (long) 1e9 + 7;\n\n    final Timer timer;\n    final TimerTask task;\n\n    Solver() {\n        hp = new Helper(MOD, MAXN);\n        hp.initIO(System.in, System.out);\n\n        timer = new Timer();\n        task =\n                new TimerTask() {\n                    @Override\n                    public void run() {\n                        try {\n                            hp.flush();\n                            System.exit(0);\n                        } catch (Exception e) {\n                        }\n                    }\n                };\n    }\n\n    void solve() throws Exception {\n        int tc = TESTCASES ? hp.getNextInt() : 1;\n        for (int tce = 1; tce <= tc; ++tce) solve(tce);\n        timer.cancel();\n        hp.flush();\n    }\n\n    boolean TESTCASES = false;\n\n    void solve(int tc) throws Exception {\n        int i, j, k;\n\n        int N = hp.getNextInt();\n        long K = hp.nextLong();\n        int[] A = hp.getIntArray(N);\n\n        ArrayList<Integer> straight = new ArrayList<>(), cycle = new ArrayList<>();\n        boolean[] vis = new boolean[N];\n        int curr = 0;\n        while (!vis[curr]) {\n            vis[curr] = true;\n            curr = A[curr] - 1;\n        }\n\n        int st = 0;\n        while (st != curr) {\n            straight.add(st);\n            st = A[st] - 1;\n        }\n\n        cycle.add(curr);\n        curr = A[curr] - 1;\n        while (curr != cycle.get(0)) {\n            cycle.add(curr);\n            curr = A[curr] - 1;\n        }\n\n        if (K < straight.size()) {\n            hp.println(straight.get((int) K) + 1);\n        } else {\n            K -= straight.size();\n            hp.println(cycle.get((int) (K % cycle.size())) + 1);\n        }\n    }\n}\n\nclass Helper {\n    final long MOD;\n    final int MAXN;\n    final Random rnd;\n\n    public Helper(long mod, int maxn) {\n        MOD = mod;\n        MAXN = maxn;\n        rnd = new Random();\n    }\n\n    public static int[] sieve;\n    public static ArrayList<Integer> primes;\n\n    public void setSieve() {\n        primes = new ArrayList<>();\n        sieve = new int[MAXN];\n        int i, j;\n        for (i = 2; i < MAXN; ++i)\n            if (sieve[i] == 0) {\n                primes.add(i);\n                for (j = i; j < MAXN; j += i) {\n                    sieve[j] = i;\n                }\n            }\n    }\n\n    public static long[] factorial;\n\n    public void setFactorial() {\n        factorial = new long[MAXN];\n        factorial[0] = 1;\n        for (int i = 1; i < MAXN; ++i) factorial[i] = factorial[i - 1] * i % MOD;\n    }\n\n    public long getFactorial(int n) {\n        if (factorial == null) setFactorial();\n        return factorial[n];\n    }\n\n    public long ncr(int n, int r) {\n        if (r > n) return 0;\n        if (factorial == null) setFactorial();\n        long numerator = factorial[n];\n        long denominator = factorial[r] * factorial[n - r] % MOD;\n        return numerator * pow(denominator, MOD - 2, MOD) % MOD;\n    }\n\n    public long[] getLongArray(int size) throws Exception {\n        long[] ar = new long[size];\n        for (int i = 0; i < size; ++i) ar[i] = nextLong();\n        return ar;\n    }\n\n    public int[] getIntArray(int size) throws Exception {\n        int[] ar = new int[size];\n        for (int i = 0; i < size; ++i) ar[i] = getNextInt();\n        return ar;\n    }\n\n    public String[] getStringArray(int size) throws Exception {\n        String[] ar = new String[size];\n        for (int i = 0; i < size; ++i) ar[i] = next();\n        return ar;\n    }\n\n    public String joinElements(long... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (long itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(int... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (int itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(String... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (String itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(Object... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (Object itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public long max(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public int max(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public long min(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public int min(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public long sum(long... ar) {\n        long sum = 0;\n        for (long itr : ar) sum += itr;\n        return sum;\n    }\n\n    public long sum(int... ar) {\n        long sum = 0;\n        for (int itr : ar) sum += itr;\n        return sum;\n    }\n\n    public void shuffle(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void shuffle(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public long pow(long base, long exp, long MOD) {\n        base %= MOD;\n        long ret = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) ret = ret * base % MOD;\n            base = base * base % MOD;\n            exp >>= 1;\n        }\n        return ret;\n    }\n\n    static final int BUFSIZE = 1 << 20;\n    static byte[] buf;\n    static int index, total;\n    static InputStream in;\n    static BufferedWriter bw;\n\n    public void initIO(InputStream is, OutputStream os) {\n        try {\n            in = is;\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    public void initIO(String inputFile, String outputFile) {\n        try {\n            in = new FileInputStream(inputFile);\n            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile)));\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    private int scan() throws Exception {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) return -1;\n        }\n        return buf[index++];\n    }\n\n    public String next() throws Exception {\n        int c;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan()) sb.append((char) c);\n        return sb.toString();\n    }\n\n    public int getNextInt() throws Exception {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan()) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public long nextLong() throws Exception {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan())\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan()) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public void print(Object a) throws Exception {\n        bw.write(a.toString());\n    }\n\n    public void printsp(Object a) throws Exception {\n        print(a);\n        print(\" \");\n    }\n\n    public void println() throws Exception {\n        bw.write(\"\\n\");\n    }\n\n    public void println(Object a) throws Exception {\n        print(a);\n        println();\n    }\n\n    public void flush() throws Exception {\n        bw.flush();\n    }\n}\n", "test_IO": {"input": ["4 5\n3 2 4 1\n"], "output": ["4\n"]}, "modified_context": "import java.awt.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution implements Runnable {\n    @Override\n    public void run() {\n        try {\n            new Solver().solve();\n            System.exit(0);\n        } catch (Exception | Error e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static void main(String[] args) {\n\n        new SampleSolution().run();\n    }\n}\n\nclass Solver {\n    final Helper hp;\n    final int MAXN = 1000_006;\n    final long MOD = (long) 1e9 + 7;\n\n    final Timer timer;\n    final TimerTask task;\n\n    Solver() {\n        hp = new Helper(MOD, MAXN);\n        hp.initIO(System.in, System.out);\n\n        timer = new Timer();\n        task =\n                new TimerTask() {\n                    @Override\n                    public void run() {\n                        try {\n                            hp.flush();\n                            System.exit(0);\n                        } catch (Exception e) {\n                        }\n                    }\n                };\n    }\n\n    void solve() throws Exception {\n        int tc = TESTCASES ? hp.getNextInt() : 1;\n        for (int tce = 1; tce <= tc; ++tce) solve(tce);\n        timer.cancel();\n        hp.flush();\n    }\n\n    boolean TESTCASES = false;\n\n    void solve(int tc) throws Exception {\n        int i, j, k;\n\n        int N = hp.getNextInt();\n        long K = hp.nextLong();\n        int[] A = hp.getIntArray(N);\n\n        ArrayList<Integer> straight = new ArrayList<>(), cycle = new ArrayList<>();\n        boolean[] vis = new boolean[N];\n        int curr = 0;\n        while (!vis[curr]) {\n            vis[curr] = true;\n            curr = A[curr] - 1;\n        }\n\n        int st = 0;\n        while (st != curr) {\n            straight.add(st);\n            st = A[st] - 1;\n        }\n\n        cycle.add(curr);\n        curr = A[curr] - 1;\n        while (curr != cycle.get(0) ) {\n            cycle.add(curr);\n            curr = A[curr] - 1;\n        }\n\n        if (K < straight.size() ) {\n            hp.println(straight.get((int) K) + 1);\n        } else {\n            K -= straight.size();\n            hp.println(cycle.get((int) (K % cycle.size() ) ) + 1);\n        }\n    }\n}\n\nclass Helper {\n    final long MOD;\n    final int MAXN;\n    final Random rnd;\n\n    public Helper(long mod, int maxn) {\n        MOD = mod;\n        MAXN = maxn;\n        rnd = new Random();\n    }\n\n    public static int[] sieve;\n    public static ArrayList<Integer> primes;\n\n    public void setSieve() {\n        primes = new ArrayList<>();\n        sieve = new int[MAXN];\n        int i, j;\n        for (i = 2; i < MAXN; ++i)\n            if (sieve[i] == 0) {\n                primes.add(i);\n                for (j = i; j < MAXN; j += i) {\n                    sieve[j] = i;\n                }\n            }\n    }\n\n    public static long[] factorial;\n\n    public void setFactorial() {\n        factorial = new long[MAXN];\n        factorial[0] = 1;\n        for (int i = 1; i < MAXN; ++i) factorial[i] = factorial[i - 1] * i % MOD;\n    }\n\n    public long getFactorial(int n) {\n        if (factorial == null) setFactorial();\n        return factorial[n];\n    }\n\n    public long ncr(int n, int r) {\n        if (r > n) return 0;\n        if (factorial == null) setFactorial();\n        long numerator = factorial[n];\n        long denominator = factorial[r] * factorial[n - r] % MOD;\n        return numerator * pow(denominator, MOD - 2, MOD) % MOD;\n    }\n\n    public long[] getLongArray(int size) throws Exception {\n        long[] ar = new long[size];\n        for (int i = 0; i < size; ++i) ar[i] = nextLong();\n        return ar;\n    }\n\n    public int[] getIntArray(int size) throws Exception {\n        int[] ar = new int[size];\n        for (int i = 0; i < size; ++i) ar[i] = getNextInt();\n        return ar;\n    }\n\n    public String[] getStringArray(int size) throws Exception {\n        String[] ar = new String[size];\n        for (int i = 0; i < size; ++i) ar[i] = next();\n        return ar;\n    }\n\n    public String joinElements(long... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (long itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(int... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (int itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(String... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (String itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public String joinElements(Object... ar) {\n        StringBuilder sb = new StringBuilder();\n        for (Object itr : ar) sb.append(itr).append(\" \");\n        return sb.toString().trim();\n    }\n\n    public long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    public long max(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public int max(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.max(ret, itr);\n        return ret;\n    }\n\n    public long min(long... ar) {\n        long ret = ar[0];\n        for (long itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public int min(int... ar) {\n        int ret = ar[0];\n        for (int itr : ar) ret = Math.min(ret, itr);\n        return ret;\n    }\n\n    public long sum(long... ar) {\n        long sum = 0;\n        for (long itr : ar) sum += itr;\n        return sum;\n    }\n\n    public long sum(int... ar) {\n        long sum = 0;\n        for (int itr : ar) sum += itr;\n        return sum;\n    }\n\n    public void shuffle(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void shuffle(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = rnd.nextInt(ar.length);\n            if (r != i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(int[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public void reverse(long[] ar) {\n        int r;\n        for (int i = 0; i < ar.length; ++i) {\n            r = ar.length - 1 - i;\n            if (r > i) {\n                ar[i] ^= ar[r];\n                ar[r] ^= ar[i];\n                ar[i] ^= ar[r];\n            }\n        }\n    }\n\n    public long pow(long base, long exp, long MOD) {\n        base %= MOD;\n        long ret = 1;\n        while (exp > 0) {\n            if ((exp & 1) == 1) ret = ret * base % MOD;\n            base = base * base % MOD;\n            exp >>= 1;\n        }\n        return ret;\n    }\n\n    static final int BUFSIZE = 1 << 20;\n    static byte[] buf;\n    static int index, total;\n    static InputStream in;\n    static BufferedWriter bw;\n\n    public void initIO(InputStream is, OutputStream os) {\n        try {\n            in = is;\n            bw = new BufferedWriter(new OutputStreamWriter(os) );\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    public void initIO(String inputFile, String outputFile) {\n        try {\n            in = new FileInputStream(inputFile);\n            bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(outputFile) ) );\n            buf = new byte[BUFSIZE];\n        } catch (Exception e) {\n        }\n    }\n\n    private int scan() throws Exception {\n        if (index >= total) {\n            index = 0;\n            total = in.read(buf);\n            if (total <= 0) return -1;\n        }\n        return buf[index++];\n    }\n\n    public String next() throws Exception {\n        int c;\n        for (c = scan(); c <= 32; c = scan() )\n            ;\n        StringBuilder sb = new StringBuilder();\n        for (; c > 32; c = scan() ) sb.append((char) c);\n        return sb.toString();\n    }\n\n    public int getNextInt() throws Exception {\n        int c, val = 0;\n        for (c = scan(); c <= 32; c = scan() )\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan() ) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public long nextLong() throws Exception {\n        int c;\n        long val = 0;\n        for (c = scan(); c <= 32; c = scan() )\n            ;\n        boolean neg = c == '-';\n        if (c == '-' || c == '+') c = scan();\n        for (; c >= '0' && c <= '9'; c = scan() ) val = (val << 3) + (val << 1) + (c & 15);\n        return neg ? -val : val;\n    }\n\n    public void print(Object a) throws Exception {\n        bw.write(a.toString() );\n    }\n\n    public void printsp(Object a) throws Exception {\n        print(a);\n        print(\" \");\n    }\n\n    public void println() throws Exception {\n        bw.write(\"\\n\");\n    }\n\n    public void println(Object a) throws Exception {\n        print(a);\n        println();\n    }\n\n    public void flush() throws Exception {\n        bw.flush();\n    }\n}\n"}
{"id": "Java/152", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        solve(sc, out);\n\n        out.flush();\n    }\n\n    public static void solve(FastScanner sc, PrintWriter out) {\n        String s = sc.next();\n\n        String[] a = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n\n        for (String str : a) {\n            if (str.equalsIgnoreCase(s)) {\n                out.println(\"vowel\");\n                return;\n            }\n        }\n\n        out.println(\"consonant\");\n    }\n\n    public static int gcd(int a, int b) {\n        if (a < b) return gcd(b, a);\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static long gcd(long a, long b) {\n        if (a < b) return gcd(b, a);\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static int lcm(int a, int b) {\n        return (a * b) / gcd(a, b);\n    }\n}\n\nclass Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n    public Pair(final K key, final V value) {\n        super(key, value);\n    }\n\n    public Pair<V, K> swap() {\n        return new Pair<V, K>(getValue(), getKey());\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in));\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    public long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n}\n", "test_IO": {"input": ["a\n"], "output": ["vowel\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.AbstractMap;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        solve(sc, out);\n\n        out.flush();\n    }\n\n    public static void solve(FastScanner sc, PrintWriter out) {\n        String s = sc.next();\n\n        String[] a = {\"a\", \"e\", \"i\", \"o\", \"u\"};\n\n        for (String str : a) {\n            if (str.equalsIgnoreCase(s) ) {\n                out.println(\"vowel\");\n                return;\n            }\n        }\n\n        out.println(\"consonant\");\n    }\n\n    public static int gcd(int a, int b) {\n        if (a < b) return gcd(b, a);\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static long gcd(long a, long b) {\n        if (a < b) return gcd(b, a);\n        if (b == 0) return a;\n        return gcd(b, a % b);\n    }\n\n    public static int lcm(int a, int b) {\n        return (a * b) / gcd(a, b);\n    }\n}\n\nclass Pair<K, V> extends AbstractMap.SimpleEntry<K, V> {\n\n    public Pair(final K key, final V value) {\n        super(key, value);\n    }\n\n    public Pair<V, K> swap() {\n        return new Pair<V, K>(getValue(), getKey() );\n    }\n}\n\nclass FastScanner {\n    private BufferedReader reader = null;\n    private StringTokenizer tokenizer = null;\n\n    public FastScanner(InputStream in) {\n        reader = new BufferedReader(new InputStreamReader(in) );\n        tokenizer = null;\n    }\n\n    public String next() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens() ) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine() );\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens() ) {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        return tokenizer.nextToken(\"\\n\");\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next() );\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next() );\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    public long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n}\n"}
{"id": "Java/153", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        if (s.equals(\"Sunny\")) {\n            System.out.println(\"Cloudy\");\n        } else if (s.equals(\"Cloudy\")) {\n            System.out.println(\"Rainy\");\n        } else {\n            System.out.println(\"Sunny\");\n        }\n        sc.close();\n    }\n}\n", "test_IO": {"input": ["Sunny\n"], "output": ["Cloudy\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        if (s.equals(\"Sunny\") ) {\n            System.out.println(\"Cloudy\");\n        } else if (s.equals(\"Cloudy\") ) {\n            System.out.println(\"Rainy\");\n        } else {\n            System.out.println(\"Sunny\");\n        }\n        sc.close();\n    }\n}\n"}
{"id": "Java/154", "code": "import java.util.*;\n\nclass calArea {\n    int Area(int w, int h) {\n        int area = w * h;\n        return area;\n    }\n}\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Integer> arr = new ArrayList<>();\n\n        for (int i = 0; i < 4; i++) {\n            arr.add(Integer.parseInt(sc.next()));\n        }\n\n        calArea ab = new calArea();\n        int area1 = ab.Area(arr.get(0), arr.get(1));\n        int area2 = ab.Area(arr.get(2), arr.get(3));\n\n        if (area1 > area2) {\n            System.out.println(area1);\n        } else if (area1 < area2) {\n            System.out.println(area2);\n        } else if (area1 == area2) {\n            System.out.println(area1);\n        }\n    }\n}\n", "test_IO": {"input": ["3 5 2 7\n"], "output": ["15\n"]}, "modified_context": "import java.util.*;\n\nclass calArea {\n    int Area(int w, int h) {\n        int area = w * h;\n        return area;\n    }\n}\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Integer> arr = new ArrayList<>();\n\n        for (int i = 0; i < 4; i++) {\n            arr.add(Integer.parseInt(sc.next() ) );\n        }\n\n        calArea ab = new calArea();\n        int area1 = ab.Area(arr.get(0), arr.get(1) );\n        int area2 = ab.Area(arr.get(2), arr.get(3) );\n\n        if (area1 > area2) {\n            System.out.println(area1);\n        } else if (area1 < area2) {\n            System.out.println(area2);\n        } else if (area1 == area2) {\n            System.out.println(area1);\n        }\n    }\n}\n"}
{"id": "Java/156", "code": "import java.awt.geom.*;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String args[]) {\n        try {\n            FastReader s = new FastReader();\n            BufferedWriter w = new BufferedWriter(new OutputStreamWriter(System.out));\n            int i, j;\n            int m, n, t, max, k, x, y, min, correct_ans, num, num_penal;\n            long a, b, sum;\n\n            String str;\n\n            n = s.nextInt();\n            m = s.nextInt();\n\n            int penal[] = new int[n + 1];\n            boolean solved[] = new boolean[n + 1];\n            Arrays.fill(solved, false);\n\n            for (i = 0; i < m; i++) {\n                num = s.nextInt();\n                str = s.next();\n                if (str.charAt(0) == 'A') {\n                    solved[num] = true;\n                } else if (solved[num] == false) penal[num]++;\n            }\n\n            correct_ans = 0;\n            num_penal = 0;\n            for (i = 1; i <= n; i++) {\n                if (solved[i] == true) {\n                    correct_ans++;\n                    num_penal += penal[i];\n                }\n            }\n\n            w.write(correct_ans + \" \" + num_penal + \"\\n\");\n            w.close();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    Double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n", "test_IO": {"input": ["2 5\n1 WA\n1 AC\n2 WA\n2 AC\n2 WA\n"], "output": ["2 2\n"]}, "modified_context": "import java.awt.geom.*;\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public static void main(String args[]) {\n        try {\n            FastReader s = new FastReader();\n            BufferedWriter w = new BufferedWriter(new OutputStreamWriter(System.out) );\n            int i, j;\n            int m, n, t, max, k, x, y, min, correct_ans, num, num_penal;\n            long a, b, sum;\n\n            String str;\n\n            n = s.nextInt();\n            m = s.nextInt();\n\n            int penal[] = new int[n + 1];\n            boolean solved[] = new boolean[n + 1];\n            Arrays.fill(solved, false);\n\n            for (i = 0; i < m; i++) {\n                num = s.nextInt();\n                str = s.next();\n                if (str.charAt(0) == 'A') {\n                    solved[num] = true;\n                } else if (solved[num] == false) penal[num]++;\n            }\n\n            correct_ans = 0;\n            num_penal = 0;\n            for (i = 1; i <= n; i++) {\n                if (solved[i] == true) {\n                    correct_ans++;\n                    num_penal += penal[i];\n                }\n            }\n\n            w.write(correct_ans + \" \" + num_penal + \"\\n\");\n            w.close();\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n\nclass FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in) );\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements() ) {\n            try {\n                st = new StringTokenizer(br.readLine() );\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next() );\n    }\n\n    long nextLong() {\n        return Long.parseLong(next() );\n    }\n\n    Double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n"}
{"id": "Java/157", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        if (s.equals(\"Sunny\")) {\n            System.out.println(\"Cloudy\");\n        } else if (s.equals(\"Cloudy\")) {\n            System.out.println(\"Rainy\");\n        } else {\n            System.out.println(\"Sunny\");\n        }\n    }\n}\n", "test_IO": {"input": ["Sunny\n"], "output": ["Cloudy\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        if (s.equals(\"Sunny\") ) {\n            System.out.println(\"Cloudy\");\n        } else if (s.equals(\"Cloudy\") ) {\n            System.out.println(\"Rainy\");\n        } else {\n            System.out.println(\"Sunny\");\n        }\n    }\n}\n"}
{"id": "Java/160", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder s, t;\n        s = new StringBuilder(sc.next());\n        t = new StringBuilder(sc.next());\n        boolean flag = false;\n        for (int i = 0; i < s.length(); i++) {\n            s = new StringBuilder(Rotate(s));\n            if (t.toString().equals(s.toString())) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag == true) System.out.println(\"Yes\");\n        else System.out.println(\"No\");\n    }\n\n    public static StringBuilder Rotate(StringBuilder str) {\n        int len = str.length();\n        char t = str.charAt(0);\n        for (int i = 0; i < len - 1; i++) {\n            str.setCharAt(i, str.charAt(i + 1));\n        }\n        str.setCharAt(len - 1, t);\n        return str;\n    }\n}\n", "test_IO": {"input": ["kyoto\ntokyo\n"], "output": ["Yes\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder s, t;\n        s = new StringBuilder(sc.next() );\n        t = new StringBuilder(sc.next() );\n        boolean flag = false;\n        for (int i = 0; i < s.length(); i++) {\n            s = new StringBuilder(Rotate(s) );\n            if (t.toString().equals(s.toString() ) ) {\n                flag = true;\n                break;\n            }\n        }\n        if (flag == true) System.out.println(\"Yes\");\n        else System.out.println(\"No\");\n    }\n\n    public static StringBuilder Rotate(StringBuilder str) {\n        int len = str.length();\n        char t = str.charAt(0);\n        for (int i = 0; i < len - 1; i++) {\n            str.setCharAt(i, str.charAt(i + 1) );\n        }\n        str.setCharAt(len - 1, t);\n        return str;\n    }\n}\n"}
{"id": "Java/161", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class Graph0n {\n        private ArrayList<Node0n> dt = new ArrayList<>();\n\n        Graph0n(int sz) {\n            for (int i = 0; i < sz; i++) {\n                Node0n node1 = new Node0n();\n                dt.add(node1);\n            }\n        }\n\n        public void add(int vn, int val) {\n            dt.get(vn).add(val);\n        }\n\n        public void add2(int vn, int val) {\n            dt.get(vn).add(val);\n            dt.get(val).add(vn);\n        }\n\n        public int get(int vn, int index) {\n            return dt.get(vn).get(index);\n        }\n\n        public ArrayList<Integer> get(int vn) {\n            return dt.get(vn).getAll();\n        }\n\n        public int sizeOf(int vn) {\n            return dt.get(vn).size();\n        }\n\n        public void clear() {\n            for (int i = 0; i < dt.size(); i++) {\n                dt.get(i).clear();\n            }\n        }\n    }\n\n    static class Node0n {\n        private ArrayList<Integer> next_vs = new ArrayList<>();\n\n        public void add(int val) {\n            next_vs.add(val);\n        }\n\n        public int get(int ad) {\n            return next_vs.get(ad);\n        }\n\n        public ArrayList<Integer> getAll() {\n            return next_vs;\n        }\n\n        public int size() {\n            return next_vs.size();\n        }\n\n        public void clear() {\n            next_vs.clear();\n        }\n    }\n\n    static class Edge {\n        int from = -1, v2 = -1;\n        long weight;\n\n        public Edge(int vn, long w) {\n            this.v2 = vn;\n            this.weight = w;\n        }\n\n        public Edge(int cm, int vn, long w) {\n            this.from = cm;\n            this.v2 = vn;\n            this.weight = w;\n        }\n    }\n\n    static class Edge2 {\n        int v2;\n        long cost1, cost2;\n\n        public Edge2(int vn, long w1, long w2) {\n            this.v2 = vn;\n            this.cost1 = w1;\n            this.cost2 = w2;\n        }\n    }\n\n    static class Comparator_Edge implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return b.v2 - a.v2;\n        }\n    }\n\n    static class V2Comp implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return -1;\n            else if (a.v2 < b.v2) return 1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class antiV2 implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return 1;\n            else if (a.v2 < b.v2) return -1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class Vector {\n        int x, y;\n\n        public Vector(int sx, int sy) {\n            this.x = sx;\n            this.y = sy;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nexI();\n        String s = sc.next();\n        boolean[] flaged = new boolean[n];\n        fill(flaged, false);\n\n        long pop1st = 0L;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                flaged[i] = true;\n                pop1st++;\n            }\n        }\n\n        long surp1 = 0;\n\n        for (int i = 0; i < n; i++) {\n            surp1 *= 2L;\n            if (flaged[i]) surp1++;\n            surp1 %= (pop1st + 1L);\n        }\n\n        long surp9 = 0L;\n        if (pop1st > 1) {\n            for (int i = 0; i < n; i++) {\n                surp9 *= 2L;\n                if (flaged[i]) surp9++;\n                surp9 %= (pop1st - 1L);\n            }\n        }\n\n        for (int p = 0; p < n; p++) {\n            if (flaged[p]) {\n                if (pop1st == 1) {\n                    out.println(0);\n                    continue;\n                }\n                long dw = surp9;\n\n                long dif = pow10E97(2, n - p - 1, pop1st - 1);\n                dw -= dif;\n                dw += (pop1st - 1L);\n                dw %= (pop1st - 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            } else {\n                long dw = surp1;\n\n                long dif = pow10E97(2, n - p - 1, pop1st + 1);\n                dw += dif;\n                dw %= (pop1st + 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            }\n        }\n\n        out.flush();\n    }\n\n    private static int INF = (int) 1e8;\n    private static long INFL = (long) 1e17;\n    private static long e97 = (long) 1e9 + 7;\n\n    void assertion(boolean b) {\n        if (!b) throw new AssertionError();\n    }\n\n    private static int abs(int a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static long abs(long a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static double abs(double a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static int min(int a, int b) {\n        return (a > b) ? b : a;\n    }\n\n    private static long min(long a, long b) {\n        return (a > b) ? b : a;\n    }\n\n    private static double min(double a, double b) {\n        return (a > b) ? b : a;\n    }\n\n    private static int max(int a, int b) {\n        return (a > b) ? a : b;\n    }\n\n    private static long max(long a, long b) {\n        return (a > b) ? a : b;\n    }\n\n    private static double max(double a, double b) {\n        return (a > b) ? a : b;\n    }\n\n    private static int minN(int... ins) {\n        int min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static int maxN(int... ins) {\n        int max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static long minN(long... ins) {\n        long min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static long maxN(long... ins) {\n        long max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static int minExAd(int[] dt, int ad) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExAd(long[] dt, int ad) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int minExVal(int[] dt, int ex_val) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExVal(long[] dt, long ex_val) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min)) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int maxExAd(int[] dt, int ad) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExAd(long[] dt, int ad) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int maxExVal(int[] dt, int ex_val) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExVal(long[] dt, long ex_val) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max)) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int sumA(int[] dt) {\n        int sum = 0;\n        for (int e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static long sumA(long[] dt) {\n        long sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static int sumA(List<Integer> dt) {\n        int sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static boolean same3(long a, long b, long c) {\n        if (a != b) return false;\n        if (b != c) return false;\n        if (c != a) return false;\n        return true;\n    }\n\n    private static boolean dif3(long a, long b, long c) {\n        if (a == b) return false;\n        if (b == c) return false;\n        if (c == a) return false;\n        return true;\n    }\n\n    private static boolean triangle_inequality(int a, int b, int c) {\n        if ((a + b) < c) return false;\n        if ((b + c) < a) return false;\n        if ((c + a) < b) return false;\n        return true;\n    }\n\n    private static double hypod(double a, double b) {\n        return Math.sqrt(a * a + b * b);\n    }\n\n    private static long factorial(int n) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n        }\n        return ans;\n    }\n\n    private static long facP(int n, long p) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n            ans %= p;\n        }\n        return ans;\n    }\n\n    private static long lcm(long m, long n) {\n        long ans = m / gcd(m, n);\n        ans *= n;\n        return ans;\n    }\n\n    private static long gcd(long m, long n) {\n        if (m < n) return gcd(n, m);\n        if (n == 0) return m;\n        return gcd(n, m % n);\n    }\n\n    private static boolean is_prime(long a) {\n        if (a == 1) return false;\n        for (long i = 2L; i <= Math.sqrt(a); i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    private static long modinv(long a, long p) {\n        long b = p, u = 1L, v = 0L;\n        while (b > 0) {\n            long t = a / b;\n            long pe = a % b;\n            a = b;\n            b = pe;\n            pe = u - t * v;\n            u = v;\n            v = pe;\n        }\n        u %= p;\n        if (u < 0) u += p;\n        return u;\n    }\n\n    private static int pow(int n, int k) {\n        int ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static long pow(long n, int k) {\n        long ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static int pow2(int in) {\n        return in * in;\n    }\n\n    private static long pow2(long in) {\n        return in * in;\n    }\n\n    private static double pow2(double in) {\n        return in * in;\n    }\n\n    private static int getDigit2(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf = (1L << d);\n        }\n\n        return d;\n    }\n\n    private static int getDigit10(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf *= 10;\n        }\n        return d;\n    }\n\n    private static boolean isINF(int in) {\n        if (((long) in * 20) > INF) return true;\n        else return false;\n    }\n\n    private static boolean isINFL(long in) {\n        if ((in * 10000) > INFL) return true;\n        else return false;\n    }\n\n    private static long pow10E97(long ob, long soeji, long p) {\n        if (ob == 0) return 0;\n        if (soeji == 0) return 1;\n        if (soeji == 2) return (ob * ob) % p;\n\n        int d = getDigit2(soeji);\n        long[] ob_pow_2pow = new long[d];\n\n        ob_pow_2pow[0] = ob;\n        for (int i = 1; i < d; i++) {\n            ob_pow_2pow[i] = (ob_pow_2pow[i - 1] * ob_pow_2pow[i - 1]) % p;\n        }\n\n        long ans = 1;\n        for (int i = d - 1; i >= 0; i--) {\n            if (soeji >= (long) (1 << i)) {\n                soeji -= (long) (1 << i);\n                ans = (ans * ob_pow_2pow[i]) % p;\n            }\n        }\n        return ans % p;\n    }\n\n    private static long flag(long pos) {\n        return (1L << pos);\n    }\n\n    private static boolean isFlaged(int bit, int pos) {\n        if ((bit & (1 << pos)) > 0) return true;\n        else return false;\n    }\n\n    private static boolean isFlaged(long bit, int pos) {\n        if ((bit & (1L << pos)) > 0) return true;\n        else return false;\n    }\n\n    private static int deflag(int bit, int pos) {\n        return bit & ~(1 << pos);\n    }\n\n    private static int countFlaged(int bit) {\n        int ans = 0;\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1 << i)) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static int countFlaged(long bit) {\n        int ans = 0;\n        for (long i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1L << i)) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static void showflag(int bit) {\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if (isFlaged(bit, i)) System.out.print(\"O\");\n            else System.out.print(\".\");\n        }\n        System.out.println();\n    }\n\n    public static int biSearch(int[] dt, int target) {\n        int left = 0, right = dt.length - 1;\n        int mid = -1;\n        while (left <= right) {\n            mid = (right + left) / 2;\n            if (dt[mid] == target) return mid;\n            if (dt[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return -1;\n    }\n\n    public static int biSearchMax(long[] dt, long target) {\n        int left = -1, right = dt.length;\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt[mid] <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    public static int biSearchMaxAL(ArrayList<Integer> dt, long target) {\n        int left = -1, right = dt.size();\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt.get(mid) <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    private static void fill_parent(int[] ob) {\n        for (int i = 0; i < ob.length; i++) ob[i] = i;\n    }\n\n    private static int get_root_uf(int[] parent, int index) {\n        if (parent[index] == index) return index;\n        int root = get_root_uf(parent, parent[index]);\n        parent[index] = root;\n        return root;\n    }\n\n    private static boolean is_same_uf(int[] parent, int x, int y) {\n        if (get_root_uf(parent, x) == get_root_uf(parent, y)) return true;\n        else return false;\n    }\n\n    private static void unite_uf(int[] parent, int receiver, int attacker) {\n        parent[get_root_uf(parent, attacker)] = get_root_uf(parent, receiver);\n    }\n\n    private static int[] Xdir4 = {1, 0, 0, -1};\n    private static int[] Ydir4 = {0, 1, -1, 0};\n\n    private static int[] Xdir8 = {1, 1, 1, 0, 0, -1, -1, -1};\n    private static int[] Ydir8 = {1, 0, -1, 1, -1, 1, 0, -1};\n\n    private static boolean is_in_area(int y, int x, int h, int w) {\n        if (y < 0) return false;\n        if (x < 0) return false;\n        if (y >= h) return false;\n        if (x >= w) return false;\n        return true;\n    }\n\n    static void show2(boolean[][] dt, int lit_x, int lit_y) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int j = 0; j < dt.length; j++) {\n            for (int i = 0; i < dt[j].length; i++) {\n                if ((i == lit_y) && (j == lit_x)) out.print(\"X\");\n                else if (dt[j][i]) out.print(\"O\");\n                else out.print(\".\");\n            }\n            out.println();\n        }\n        out.flush();\n    }\n\n    static void show2(int[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void show2(long[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void disp_que(ArrayDeque<Long> dt) {\n        long a = 0;\n        while (dt.size() > 0) {\n            a = dt.removeFirst();\n            System.out.print(a);\n        }\n        System.out.println(\"\\n\");\n    }\n\n    static void disp_list(List dt) {\n        for (int i = 0; i < dt.size(); i++) {\n            System.out.print(dt.get(i) + \",\");\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void prtlnas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtlnas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtspas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(List as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as.get(0));\n        for (int i = 1; i < as.size(); i++) {\n            out.print(\" \" + as.get(i));\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void fill(boolean[] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(int[] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(long[] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(char[] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(double[] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(boolean[][] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(long[][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(char[][] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(double[][] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    private static void fill(long[][][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext()) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nexL() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b) || b == ':') {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nexI() {\n            long nl = nexL();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nexD() {\n            return Double.parseDouble(next());\n        }\n\n        public void ni(long[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(long[] as, long[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexL();\n                bs[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs, int[] cs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n                cs[i] = nexI();\n            }\n            return;\n        }\n\n        public void nisan(int[][] as) {\n            for (int i = 0; i < as.length; i++) {\n                for (int j = 0; j < as[0].length; j++) {\n                    as[i][j] = nexI();\n                }\n            }\n            return;\n        }\n    }\n}\n", "test_IO": {"input": ["3\n011\n"], "output": ["2\n1\n1\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    static class Graph0n {\n        private ArrayList<Node0n> dt = new ArrayList<>();\n\n        Graph0n(int sz) {\n            for (int i = 0; i < sz; i++) {\n                Node0n node1 = new Node0n();\n                dt.add(node1);\n            }\n        }\n\n        public void add(int vn, int val) {\n            dt.get(vn).add(val);\n        }\n\n        public void add2(int vn, int val) {\n            dt.get(vn).add(val);\n            dt.get(val).add(vn);\n        }\n\n        public int get(int vn, int index) {\n            return dt.get(vn).get(index);\n        }\n\n        public ArrayList<Integer> get(int vn) {\n            return dt.get(vn).getAll();\n        }\n\n        public int sizeOf(int vn) {\n            return dt.get(vn).size();\n        }\n\n        public void clear() {\n            for (int i = 0; i < dt.size(); i++) {\n                dt.get(i).clear();\n            }\n        }\n    }\n\n    static class Node0n {\n        private ArrayList<Integer> next_vs = new ArrayList<>();\n\n        public void add(int val) {\n            next_vs.add(val);\n        }\n\n        public int get(int ad) {\n            return next_vs.get(ad);\n        }\n\n        public ArrayList<Integer> getAll() {\n            return next_vs;\n        }\n\n        public int size() {\n            return next_vs.size();\n        }\n\n        public void clear() {\n            next_vs.clear();\n        }\n    }\n\n    static class Edge {\n        int from = -1, v2 = -1;\n        long weight;\n\n        public Edge(int vn, long w) {\n            this.v2 = vn;\n            this.weight = w;\n        }\n\n        public Edge(int cm, int vn, long w) {\n            this.from = cm;\n            this.v2 = vn;\n            this.weight = w;\n        }\n    }\n\n    static class Edge2 {\n        int v2;\n        long cost1, cost2;\n\n        public Edge2(int vn, long w1, long w2) {\n            this.v2 = vn;\n            this.cost1 = w1;\n            this.cost2 = w2;\n        }\n    }\n\n    static class Comparator_Edge implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return b.v2 - a.v2;\n        }\n    }\n\n    static class V2Comp implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return -1;\n            else if (a.v2 < b.v2) return 1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class antiV2 implements Comparator<Edge> {\n        public int compare(Edge a, Edge b) {\n            if (a.v2 > b.v2) return 1;\n            else if (a.v2 < b.v2) return -1;\n            else if (a.weight > b.weight) return -1;\n            else if (a.weight < b.weight) return 1;\n            else return 0;\n        }\n    }\n\n    static class Vector {\n        int x, y;\n\n        public Vector(int sx, int sy) {\n            this.x = sx;\n            this.y = sy;\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nexI();\n        String s = sc.next();\n        boolean[] flaged = new boolean[n];\n        fill(flaged, false);\n\n        long pop1st = 0L;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '1') {\n                flaged[i] = true;\n                pop1st++;\n            }\n        }\n\n        long surp1 = 0;\n\n        for (int i = 0; i < n; i++) {\n            surp1 *= 2L;\n            if (flaged[i]) surp1++;\n            surp1 %= (pop1st + 1L);\n        }\n\n        long surp9 = 0L;\n        if (pop1st > 1) {\n            for (int i = 0; i < n; i++) {\n                surp9 *= 2L;\n                if (flaged[i]) surp9++;\n                surp9 %= (pop1st - 1L);\n            }\n        }\n\n        for (int p = 0; p < n; p++) {\n            if (flaged[p]) {\n                if (pop1st == 1) {\n                    out.println(0);\n                    continue;\n                }\n                long dw = surp9;\n\n                long dif = pow10E97(2, n - p - 1, pop1st - 1);\n                dw -= dif;\n                dw += (pop1st - 1L);\n                dw %= (pop1st - 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            } else {\n                long dw = surp1;\n\n                long dif = pow10E97(2, n - p - 1, pop1st + 1);\n                dw += dif;\n                dw %= (pop1st + 1L);\n\n                int ans = 1;\n                while (dw != 0) {\n                    if (dw < 0) out.println(1 / 0);\n                    int count = countFlaged(dw);\n                    dw %= count;\n                    ans++;\n                }\n                out.println(ans);\n            }\n        }\n\n        out.flush();\n    }\n\n    private static int INF = (int) 1e8;\n    private static long INFL = (long) 1e17;\n    private static long e97 = (long) 1e9 + 7;\n\n    void assertion(boolean b) {\n        if (!b) throw new AssertionError();\n    }\n\n    private static int abs(int a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static long abs(long a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static double abs(double a) {\n        return (a >= 0) ? a : -a;\n    }\n\n    private static int min(int a, int b) {\n        return (a > b) ? b : a;\n    }\n\n    private static long min(long a, long b) {\n        return (a > b) ? b : a;\n    }\n\n    private static double min(double a, double b) {\n        return (a > b) ? b : a;\n    }\n\n    private static int max(int a, int b) {\n        return (a > b) ? a : b;\n    }\n\n    private static long max(long a, long b) {\n        return (a > b) ? a : b;\n    }\n\n    private static double max(double a, double b) {\n        return (a > b) ? a : b;\n    }\n\n    private static int minN(int... ins) {\n        int min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static int maxN(int... ins) {\n        int max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static long minN(long... ins) {\n        long min = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] < min) min = ins[i];\n        }\n        return min;\n    }\n\n    private static long maxN(long... ins) {\n        long max = ins[0];\n        for (int i = 1; i < ins.length; i++) {\n            if (ins[i] > max) max = ins[i];\n        }\n        return max;\n    }\n\n    private static int minExAd(int[] dt, int ad) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min) ) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExAd(long[] dt, int ad) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] < min) ) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int minExVal(int[] dt, int ex_val) {\n        int min = INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min) ) min = dt[i];\n        }\n        return min;\n    }\n\n    private static long minExVal(long[] dt, long ex_val) {\n        long min = INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] < min) ) min = dt[i];\n        }\n        return min;\n    }\n\n    private static int maxExAd(int[] dt, int ad) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max) ) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExAd(long[] dt, int ad) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((i != ad) && (dt[i] > max) ) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int maxExVal(int[] dt, int ex_val) {\n        int max = -INF;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max) ) max = dt[i];\n        }\n        return max;\n    }\n\n    private static long maxExVal(long[] dt, long ex_val) {\n        long max = -INFL;\n        for (int i = 0; i < dt.length; i++) {\n            if ((dt[i] != ex_val) && (dt[i] > max) ) max = dt[i];\n        }\n        return max;\n    }\n\n    private static int sumA(int[] dt) {\n        int sum = 0;\n        for (int e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static long sumA(long[] dt) {\n        long sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static int sumA(List<Integer> dt) {\n        int sum = 0;\n        for (long e : dt) {\n            sum += e;\n        }\n        return sum;\n    }\n\n    private static boolean same3(long a, long b, long c) {\n        if (a != b) return false;\n        if (b != c) return false;\n        if (c != a) return false;\n        return true;\n    }\n\n    private static boolean dif3(long a, long b, long c) {\n        if (a == b) return false;\n        if (b == c) return false;\n        if (c == a) return false;\n        return true;\n    }\n\n    private static boolean triangle_inequality(int a, int b, int c) {\n        if ((a + b) < c) return false;\n        if ((b + c) < a) return false;\n        if ((c + a) < b) return false;\n        return true;\n    }\n\n    private static double hypod(double a, double b) {\n        return Math.sqrt(a * a + b * b);\n    }\n\n    private static long factorial(int n) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n        }\n        return ans;\n    }\n\n    private static long facP(int n, long p) {\n        long ans = 1;\n        for (long i = n; i > 0; i--) {\n            ans *= i;\n            ans %= p;\n        }\n        return ans;\n    }\n\n    private static long lcm(long m, long n) {\n        long ans = m / gcd(m, n);\n        ans *= n;\n        return ans;\n    }\n\n    private static long gcd(long m, long n) {\n        if (m < n) return gcd(n, m);\n        if (n == 0) return m;\n        return gcd(n, m % n);\n    }\n\n    private static boolean is_prime(long a) {\n        if (a == 1) return false;\n        for (long i = 2L; i <= Math.sqrt(a); i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    private static long modinv(long a, long p) {\n        long b = p, u = 1L, v = 0L;\n        while (b > 0) {\n            long t = a / b;\n            long pe = a % b;\n            a = b;\n            b = pe;\n            pe = u - t * v;\n            u = v;\n            v = pe;\n        }\n        u %= p;\n        if (u < 0) u += p;\n        return u;\n    }\n\n    private static int pow(int n, int k) {\n        int ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static long pow(long n, int k) {\n        long ans = 1;\n        for (int i = 0; i < k; i++) ans *= n;\n        return ans;\n    }\n\n    private static int pow2(int in) {\n        return in * in;\n    }\n\n    private static long pow2(long in) {\n        return in * in;\n    }\n\n    private static double pow2(double in) {\n        return in * in;\n    }\n\n    private static int getDigit2(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf = (1L << d);\n        }\n\n        return d;\n    }\n\n    private static int getDigit10(long num) {\n        long cf = 1;\n        int d = 0;\n        while (num >= cf) {\n            d++;\n            cf *= 10;\n        }\n        return d;\n    }\n\n    private static boolean isINF(int in) {\n        if (((long) in * 20) > INF) return true;\n        else return false;\n    }\n\n    private static boolean isINFL(long in) {\n        if ((in * 10000) > INFL) return true;\n        else return false;\n    }\n\n    private static long pow10E97(long ob, long soeji, long p) {\n        if (ob == 0) return 0;\n        if (soeji == 0) return 1;\n        if (soeji == 2) return (ob * ob) % p;\n\n        int d = getDigit2(soeji);\n        long[] ob_pow_2pow = new long[d];\n\n        ob_pow_2pow[0] = ob;\n        for (int i = 1; i < d; i++) {\n            ob_pow_2pow[i] = (ob_pow_2pow[i - 1] * ob_pow_2pow[i - 1]) % p;\n        }\n\n        long ans = 1;\n        for (int i = d - 1; i >= 0; i--) {\n            if (soeji >= (long) (1 << i) ) {\n                soeji -= (long) (1 << i);\n                ans = (ans * ob_pow_2pow[i]) % p;\n            }\n        }\n        return ans % p;\n    }\n\n    private static long flag(long pos) {\n        return (1L << pos);\n    }\n\n    private static boolean isFlaged(int bit, int pos) {\n        if ((bit & (1 << pos) ) > 0) return true;\n        else return false;\n    }\n\n    private static boolean isFlaged(long bit, int pos) {\n        if ((bit & (1L << pos) ) > 0) return true;\n        else return false;\n    }\n\n    private static int deflag(int bit, int pos) {\n        return bit & ~(1 << pos);\n    }\n\n    private static int countFlaged(int bit) {\n        int ans = 0;\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1 << i) ) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static int countFlaged(long bit) {\n        int ans = 0;\n        for (long i = 0; i < getDigit2(bit); i++) {\n            if ((bit & (1L << i) ) > 0) ans++;\n        }\n        return ans;\n    }\n\n    private static void showflag(int bit) {\n        for (int i = 0; i < getDigit2(bit); i++) {\n            if (isFlaged(bit, i) ) System.out.print(\"O\");\n            else System.out.print(\".\");\n        }\n        System.out.println();\n    }\n\n    public static int biSearch(int[] dt, int target) {\n        int left = 0, right = dt.length - 1;\n        int mid = -1;\n        while (left <= right) {\n            mid = (right + left) / 2;\n            if (dt[mid] == target) return mid;\n            if (dt[mid] < target) left = mid + 1;\n            else right = mid - 1;\n        }\n        return -1;\n    }\n\n    public static int biSearchMax(long[] dt, long target) {\n        int left = -1, right = dt.length;\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt[mid] <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    public static int biSearchMaxAL(ArrayList<Integer> dt, long target) {\n        int left = -1, right = dt.size();\n        int mid = -1;\n\n        while ((right - left) > 1) {\n            mid = left + (right - left) / 2;\n            if (dt.get(mid) <= target) left = mid;\n            else right = mid;\n        }\n        return left;\n    }\n\n    private static void fill_parent(int[] ob) {\n        for (int i = 0; i < ob.length; i++) ob[i] = i;\n    }\n\n    private static int get_root_uf(int[] parent, int index) {\n        if (parent[index] == index) return index;\n        int root = get_root_uf(parent, parent[index]);\n        parent[index] = root;\n        return root;\n    }\n\n    private static boolean is_same_uf(int[] parent, int x, int y) {\n        if (get_root_uf(parent, x) == get_root_uf(parent, y) ) return true;\n        else return false;\n    }\n\n    private static void unite_uf(int[] parent, int receiver, int attacker) {\n        parent[get_root_uf(parent, attacker)] = get_root_uf(parent, receiver);\n    }\n\n    private static int[] Xdir4 = {1, 0, 0, -1};\n    private static int[] Ydir4 = {0, 1, -1, 0};\n\n    private static int[] Xdir8 = {1, 1, 1, 0, 0, -1, -1, -1};\n    private static int[] Ydir8 = {1, 0, -1, 1, -1, 1, 0, -1};\n\n    private static boolean is_in_area(int y, int x, int h, int w) {\n        if (y < 0) return false;\n        if (x < 0) return false;\n        if (y >= h) return false;\n        if (x >= w) return false;\n        return true;\n    }\n\n    static void show2(boolean[][] dt, int lit_x, int lit_y) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int j = 0; j < dt.length; j++) {\n            for (int i = 0; i < dt[j].length; i++) {\n                if ((i == lit_y) && (j == lit_x) ) out.print(\"X\");\n                else if (dt[j][i]) out.print(\"O\");\n                else out.print(\".\");\n            }\n            out.println();\n        }\n        out.flush();\n    }\n\n    static void show2(int[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void show2(long[][] dt, String cmnt) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < dt.length; i++) {\n            for (int j = 0; j < dt[i].length; j++) {\n                out.print(dt[i][j] + \",\");\n            }\n            out.println(\"<-\" + cmnt + \":\" + i);\n        }\n        out.flush();\n    }\n\n    static void disp_que(ArrayDeque<Long> dt) {\n        long a = 0;\n        while (dt.size() > 0) {\n            a = dt.removeFirst();\n            System.out.print(a);\n        }\n        System.out.println(\"\\n\");\n    }\n\n    static void disp_list(List dt) {\n        for (int i = 0; i < dt.size(); i++) {\n            System.out.print(dt.get(i) + \",\");\n        }\n        System.out.println(\"\\n\");\n    }\n\n    private static void prtlnas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtlnas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < as.length; i++) {\n            out.println(as[i]);\n        }\n        out.flush();\n    }\n\n    private static void prtspas(int[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(long[] as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as[0]);\n        for (int i = 1; i < as.length; i++) {\n            out.print(\" \" + as[i]);\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void prtspas(List as) {\n        PrintWriter out = new PrintWriter(System.out);\n        out.print(as.get(0) );\n        for (int i = 1; i < as.size(); i++) {\n            out.print(\" \" + as.get(i) );\n        }\n        out.println();\n        out.flush();\n    }\n\n    private static void fill(boolean[] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(int[] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(long[] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(char[] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(double[] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            ob[i] = res;\n        }\n    }\n\n    private static void fill(boolean[][] ob, boolean res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(long[][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(char[][] ob, char res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(double[][] ob, double res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                ob[i][j] = res;\n            }\n        }\n    }\n\n    private static void fill(int[][][] ob, int res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    private static void fill(long[][][] ob, long res) {\n        for (int i = 0; i < ob.length; i++) {\n            for (int j = 0; j < ob[0].length; j++) {\n                for (int k = 0; k < ob[0][0].length; k++) {\n                    ob[i][j][k] = res;\n                }\n            }\n        }\n    }\n\n    static class FastScanner {\n        private final InputStream in = System.in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        private boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        private int readByte() {\n            if (hasNextByte() ) return buffer[ptr++];\n            else return -1;\n        }\n\n        private static boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        public boolean hasNext() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n            return hasNextByte();\n        }\n\n        public String next() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b) ) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        public long nexL() {\n            if (!hasNext() ) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b) || b == ':') {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        public int nexI() {\n            long nl = nexL();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public double nexD() {\n            return Double.parseDouble(next() );\n        }\n\n        public void ni(long[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] array2) {\n            for (int i = 0; i < array2.length; i++) {\n                array2[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n            }\n            return;\n        }\n\n        public void ni(long[] as, long[] bs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexL();\n                bs[i] = nexL();\n            }\n            return;\n        }\n\n        public void ni(int[] as, int[] bs, int[] cs) {\n            for (int i = 0; i < as.length; i++) {\n                as[i] = nexI();\n                bs[i] = nexI();\n                cs[i] = nexI();\n            }\n            return;\n        }\n\n        public void nisan(int[][] as) {\n            for (int i = 0; i < as.length; i++) {\n                for (int j = 0; j < as[0].length; j++) {\n                    as[i][j] = nexI();\n                }\n            }\n            return;\n        }\n    }\n}\n"}
{"id": "Java/162", "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int ans = 100;\n    static int[][] balls;\n    static int N;\n    static boolean[] taken;\n\n    public static void main(String[] args) {\n\n        FastScanner I = new FastScanner();\n        OutPut O = new OutPut();\n        N = I.nextInt();\n        ans = N;\n        balls = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            balls[i][0] = I.nextInt();\n            balls[i][1] = I.nextInt();\n        }\n        Arrays.sort(balls, (a, b) -> Integer.compare(a[0], b[0]));\n        solve();\n        for (int i = 0; i < N; i++) {\n            int x = balls[i][0];\n            int y = balls[i][1];\n            balls[i][0] = y;\n            balls[i][1] = x;\n        }\n        Arrays.sort(balls, (a, b) -> Integer.compare(a[0], b[0]));\n        solve();\n        O.pln(ans);\n    }\n\n    public static void solve() {\n        for (int add = 1; add < N; add++) {\n            taken = new boolean[N];\n            int p = balls[add][0] - balls[0][0];\n            int q = balls[add][1] - balls[0][1];\n            ans = min(ans, check(p, q));\n        }\n    }\n\n    public static int check(int p, int q) {\n        int ret = 0;\n        while (true) {\n            boolean added = false;\n            int start = 0;\n            int x = -1;\n            int y = -1;\n            for (int i = 0; i < N; i++) {\n                if (!taken[i]) {\n                    added = true;\n                    ret++;\n                    start = i;\n                    taken[i] = true;\n                    x = balls[i][0] + p;\n                    y = balls[i][1] + q;\n                    break;\n                }\n            }\n            if (!added) break;\n            for (int i = start + 1; i < N; i++) {\n                if (balls[i][0] == x && balls[i][1] == y) {\n                    taken[i] = true;\n                    x += p;\n                    y += q;\n                }\n            }\n        }\n        return ret;\n    }\n\n    public static double max(double a, double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(double a, double b) {\n        return Math.min(a, b);\n    }\n\n    public static long min(long a, long b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(long a, long b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    public static long abs(long x) {\n        return Math.abs(x);\n    }\n\n    public static long ceil(long num, long den) {\n        long ans = num / den;\n        if (num % den != 0) ans++;\n        return ans;\n    }\n\n    public static long GCD(long a, long b) {\n        if (a == 0 || b == 0) return max(a, b);\n        return GCD(min(a, b), max(a, b) % min(a, b));\n    }\n\n    public static long FastExp(long base, long exp, long mod) {\n        long ans = 1;\n        while (exp > 0) {\n            if (exp % 2 == 1) ans *= base;\n            exp /= 2;\n            base *= base;\n            base %= mod;\n            ans %= mod;\n        }\n        return ans;\n    }\n\n    public static long ModInv(long num, long mod) {\n        return FastExp(num, mod - 2, mod);\n    }\n\n    public static int pop(long x) {\n        int cnt = 0;\n        while (x > 0) {\n            if (x % 2 == 1) cnt++;\n            x /= 2;\n        }\n        return cnt;\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        ;\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    static class OutPut {\n        PrintWriter w = new PrintWriter(System.out);\n\n        void pln(double x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(boolean x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(int x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(long x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(String x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(char x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(StringBuilder x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(BigInteger x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void p(int x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(long x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(String x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(char x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(StringBuilder x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(BigInteger x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(double x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(boolean x) {\n            w.print(x);\n            w.flush();\n        }\n    }\n}\n", "test_IO": {"input": ["2\n1 1\n2 2\n"], "output": ["1\n"]}, "modified_context": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    static int ans = 100;\n    static int[][] balls;\n    static int N;\n    static boolean[] taken;\n\n    public static void main(String[] args) {\n\n        FastScanner I = new FastScanner();\n        OutPut O = new OutPut();\n        N = I.nextInt();\n        ans = N;\n        balls = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            balls[i][0] = I.nextInt();\n            balls[i][1] = I.nextInt();\n        }\n        Arrays.sort(balls, (a, b) -> Integer.compare(a[0], b[0]) );\n        solve();\n        for (int i = 0; i < N; i++) {\n            int x = balls[i][0];\n            int y = balls[i][1];\n            balls[i][0] = y;\n            balls[i][1] = x;\n        }\n        Arrays.sort(balls, (a, b) -> Integer.compare(a[0], b[0]) );\n        solve();\n        O.pln(ans);\n    }\n\n    public static void solve() {\n        for (int add = 1; add < N; add++) {\n            taken = new boolean[N];\n            int p = balls[add][0] - balls[0][0];\n            int q = balls[add][1] - balls[0][1];\n            ans = min(ans, check(p, q) );\n        }\n    }\n\n    public static int check(int p, int q) {\n        int ret = 0;\n        while (true) {\n            boolean added = false;\n            int start = 0;\n            int x = -1;\n            int y = -1;\n            for (int i = 0; i < N; i++) {\n                if (!taken[i]) {\n                    added = true;\n                    ret++;\n                    start = i;\n                    taken[i] = true;\n                    x = balls[i][0] + p;\n                    y = balls[i][1] + q;\n                    break;\n                }\n            }\n            if (!added) break;\n            for (int i = start + 1; i < N; i++) {\n                if (balls[i][0] == x && balls[i][1] == y) {\n                    taken[i] = true;\n                    x += p;\n                    y += q;\n                }\n            }\n        }\n        return ret;\n    }\n\n    public static double max(double a, double b) {\n        return Math.max(a, b);\n    }\n\n    public static double min(double a, double b) {\n        return Math.min(a, b);\n    }\n\n    public static long min(long a, long b) {\n        return Math.min(a, b);\n    }\n\n    public static long max(long a, long b) {\n        return Math.max(a, b);\n    }\n\n    public static int min(int a, int b) {\n        return Math.min(a, b);\n    }\n\n    public static int max(int a, int b) {\n        return Math.max(a, b);\n    }\n\n    public static long abs(long x) {\n        return Math.abs(x);\n    }\n\n    public static long ceil(long num, long den) {\n        long ans = num / den;\n        if (num % den != 0) ans++;\n        return ans;\n    }\n\n    public static long GCD(long a, long b) {\n        if (a == 0 || b == 0) return max(a, b);\n        return GCD(min(a, b), max(a, b) % min(a, b) );\n    }\n\n    public static long FastExp(long base, long exp, long mod) {\n        long ans = 1;\n        while (exp > 0) {\n            if (exp % 2 == 1) ans *= base;\n            exp /= 2;\n            base *= base;\n            base %= mod;\n            ans %= mod;\n        }\n        return ans;\n    }\n\n    public static long ModInv(long num, long mod) {\n        return FastExp(num, mod - 2, mod);\n    }\n\n    public static int pop(long x) {\n        int cnt = 0;\n        while (x > 0) {\n            if (x % 2 == 1) cnt++;\n            x /= 2;\n        }\n        return cnt;\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens() )\n                try {\n                    st = new StringTokenizer(br.readLine() );\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next() );\n        }\n\n        long nextLong() {\n            return Long.parseLong(next() );\n        }\n        ;\n\n        double nextDouble() {\n            return Double.parseDouble(next() );\n        }\n    }\n\n    static class OutPut {\n        PrintWriter w = new PrintWriter(System.out);\n\n        void pln(double x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(boolean x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(int x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(long x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(String x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(char x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(StringBuilder x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void pln(BigInteger x) {\n            w.println(x);\n            w.flush();\n        }\n\n        void p(int x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(long x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(String x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(char x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(StringBuilder x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(BigInteger x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(double x) {\n            w.print(x);\n            w.flush();\n        }\n\n        void p(boolean x) {\n            w.print(x);\n            w.flush();\n        }\n    }\n}\n"}
{"id": "Java/164", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int N = Integer.parseInt(sc.next());\n        String s[] = new String[N];\n        int a_num = 0;\n        int b_num = 0;\n        boolean flag = true;\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            s[i] = sc.next();\n            if (s[i].substring(0, 1).equals(\"B\")) {\n                b_num++;\n            }\n            if (s[i].substring(s[i].length() - 1, s[i].length()).equals(\"A\")) {\n                a_num++;\n            }\n            if (s[i].substring(0, 1).equals(\"B\")\n                    || s[i].substring(s[i].length() - 1, s[i].length()).equals(\"A\")) {\n                if (!(s[i].substring(0, 1).equals(\"B\")\n                        && s[i].substring(s[i].length() - 1, s[i].length()).equals(\"A\"))) {\n                    flag = false;\n                }\n            }\n            for (int j = 0; j < s[i].length() - 1; j++) {\n                if (s[i].substring(j, j + 2).equals(\"AB\")) ans++;\n            }\n        }\n        ans += Math.min(a_num, b_num);\n        if (Math.min(a_num, b_num) != 0 && flag) {\n            ans--;\n        }\n        System.out.println(ans);\n    }\n}\n", "test_IO": {"input": ["3\nABCA\nXBAZ\nBAD\n"], "output": ["2\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int N = Integer.parseInt(sc.next() );\n        String s[] = new String[N];\n        int a_num = 0;\n        int b_num = 0;\n        boolean flag = true;\n        int ans = 0;\n        for (int i = 0; i < N; i++) {\n            s[i] = sc.next();\n            if (s[i].substring(0, 1).equals(\"B\") ) {\n                b_num++;\n            }\n            if (s[i].substring(s[i].length() - 1, s[i].length() ).equals(\"A\") ) {\n                a_num++;\n            }\n            if (s[i].substring(0, 1).equals(\"B\")\n                    || s[i].substring(s[i].length() - 1, s[i].length() ).equals(\"A\") ) {\n                if (!(s[i].substring(0, 1).equals(\"B\")\n                        && s[i].substring(s[i].length() - 1, s[i].length() ).equals(\"A\") ) ) {\n                    flag = false;\n                }\n            }\n            for (int j = 0; j < s[i].length() - 1; j++) {\n                if (s[i].substring(j, j + 2).equals(\"AB\") ) ans++;\n            }\n        }\n        ans += Math.min(a_num, b_num);\n        if (Math.min(a_num, b_num) != 0 && flag) {\n            ans--;\n        }\n        System.out.println(ans);\n    }\n}\n"}
{"id": "Java/167", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    String[][] colorMtr;\n    int h;\n    int w;\n    int k;\n\n    public static void main(String[] args) throws IOException {\n        SampleSolution mainObj = new SampleSolution();\n        mainObj.solve();\n    }\n\n    public void solve() throws IOException {\n        FastScanner fs = new FastScanner();\n\n        h = fs.nextInt();\n        w = fs.nextInt();\n        k = fs.nextInt();\n\n        colorMtr = new String[h][];\n        for (int i = 0; i < h; i++) {\n            colorMtr[i] = fs.next().split(\"\");\n        }\n\n        int hPattern = pow(2, h);\n        int wPattern = pow(2, w);\n\n        int ans = 0;\n\n        for (int i = 0; i < hPattern; i++) {\n            for (int j = 0; j < wPattern; j++) {\n                if (judge(i, j)) {\n                    ans++;\n                }\n            }\n        }\n\n        System.out.println(ans);\n    }\n\n    boolean judge(int hPattern, int wPattern) {\n\n        int[] hBitArr = new int[h];\n        int[] wBitArr = new int[w];\n\n        for (int i = 0; i < h; i++) {\n            if (((hPattern >> i) & 1) == 1) {\n                hBitArr[i] = 1;\n            }\n        }\n\n        for (int i = 0; i < w; i++) {\n            if (((wPattern >> i) & 1) == 1) {\n                wBitArr[i] = 1;\n            }\n        }\n\n        int black = 0;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (hBitArr[i] == 1 || wBitArr[j] == 1) {\n                    continue;\n                }\n\n                if (colorMtr[i][j].equals(\"#\")) {\n                    black++;\n                }\n            }\n        }\n\n        if (black == k) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public int pow(int base, int n) {\n        int retVal = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                retVal *= base;\n            }\n            n >>= 1;\n            base *= base;\n        }\n        return retVal;\n    }\n\n    public class FastScanner {\n\n        BufferedReader reader;\n        private StringTokenizer st;\n\n        public FastScanner() {\n            st = null;\n            reader = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(reader.readLine());\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            st = null;\n            String readLine = null;\n            readLine = reader.readLine();\n            return readLine;\n        }\n\n        public int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws NumberFormatException, IOException {\n            return Long.parseLong(next());\n        }\n\n        public int[] nextIntArr(int n) throws NumberFormatException, IOException {\n            int[] retArr = new int[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextInt();\n            }\n            return retArr;\n        }\n\n        public long[] nextLongArr(int n) throws NumberFormatException, IOException {\n            long[] retArr = new long[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextLong();\n            }\n            return retArr;\n        }\n\n        public void close() throws IOException {\n            reader.close();\n        }\n    }\n}\n", "test_IO": {"input": ["2 3 2\n..#\n###\n"], "output": ["5\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class SampleSolution {\n\n    String[][] colorMtr;\n    int h;\n    int w;\n    int k;\n\n    public static void main(String[] args) throws IOException {\n        SampleSolution mainObj = new SampleSolution();\n        mainObj.solve();\n    }\n\n    public void solve() throws IOException {\n        FastScanner fs = new FastScanner();\n\n        h = fs.nextInt();\n        w = fs.nextInt();\n        k = fs.nextInt();\n\n        colorMtr = new String[h][];\n        for (int i = 0; i < h; i++) {\n            colorMtr[i] = fs.next().split(\"\");\n        }\n\n        int hPattern = pow(2, h);\n        int wPattern = pow(2, w);\n\n        int ans = 0;\n\n        for (int i = 0; i < hPattern; i++) {\n            for (int j = 0; j < wPattern; j++) {\n                if (judge(i, j) ) {\n                    ans++;\n                }\n            }\n        }\n\n        System.out.println(ans);\n    }\n\n    boolean judge(int hPattern, int wPattern) {\n\n        int[] hBitArr = new int[h];\n        int[] wBitArr = new int[w];\n\n        for (int i = 0; i < h; i++) {\n            if (((hPattern >> i) & 1) == 1) {\n                hBitArr[i] = 1;\n            }\n        }\n\n        for (int i = 0; i < w; i++) {\n            if (((wPattern >> i) & 1) == 1) {\n                wBitArr[i] = 1;\n            }\n        }\n\n        int black = 0;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (hBitArr[i] == 1 || wBitArr[j] == 1) {\n                    continue;\n                }\n\n                if (colorMtr[i][j].equals(\"#\") ) {\n                    black++;\n                }\n            }\n        }\n\n        if (black == k) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    public int pow(int base, int n) {\n        int retVal = 1;\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                retVal *= base;\n            }\n            n >>= 1;\n            base *= base;\n        }\n        return retVal;\n    }\n\n    public class FastScanner {\n\n        BufferedReader reader;\n        private StringTokenizer st;\n\n        public FastScanner() {\n            st = null;\n            reader = new BufferedReader(new InputStreamReader(System.in) );\n        }\n\n        public String next() throws IOException {\n            if (st == null || !st.hasMoreElements() ) {\n                st = new StringTokenizer(reader.readLine() );\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() throws IOException {\n            st = null;\n            String readLine = null;\n            readLine = reader.readLine();\n            return readLine;\n        }\n\n        public int nextInt() throws NumberFormatException, IOException {\n            return Integer.parseInt(next() );\n        }\n\n        public long nextLong() throws NumberFormatException, IOException {\n            return Long.parseLong(next() );\n        }\n\n        public int[] nextIntArr(int n) throws NumberFormatException, IOException {\n            int[] retArr = new int[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextInt();\n            }\n            return retArr;\n        }\n\n        public long[] nextLongArr(int n) throws NumberFormatException, IOException {\n            long[] retArr = new long[n];\n            for (int i = 0; i < n; i++) {\n                retArr[i] = nextLong();\n            }\n            return retArr;\n        }\n\n        public void close() throws IOException {\n            reader.close();\n        }\n    }\n}\n"}
{"id": "Java/168", "code": "import static java.lang.System.*;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\nclass SampleSolution {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand = new Random();\n\n    public void run() {\n        TCase:\n        while (true) {\n            int W = sc.nextInt(), H = sc.nextInt();\n            if (W == 0 && H == 0) return;\n            char[][] map = new char[H][W];\n\n            for (int h = 0; h < H; h++) {\n                map[h] = sc.next().toCharArray();\n            }\n\n            BigInteger[][] dp = new BigInteger[H][W];\n\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    BigInteger hprev = BigInteger.ZERO;\n                    if (h >= 1) {\n                        hprev = dp[h - 1][w];\n                    }\n                    BigInteger wprev = BigInteger.ZERO;\n                    if (w >= 1) {\n                        wprev = dp[h][w - 1];\n                    }\n                    if (Character.isDigit(map[h][w])) {\n                        BigInteger max;\n                        if (hprev.compareTo(wprev) > 0) {\n                            max = hprev;\n                        } else {\n                            max = wprev;\n                        }\n                        dp[h][w] = max.multiply(BigInteger.TEN).add(new BigInteger(map[h][w] + \"\"));\n                    } else {\n                        dp[h][w] = BigInteger.ZERO;\n                    }\n                }\n            BigInteger max = BigInteger.ZERO;\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    if (dp[h][w].compareTo(max) > 0) max = dp[h][w];\n                }\n            ln(max);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = sc.nextInt();\n        }\n        return res;\n    }\n\n    public static void pr(Object o) {\n        out.print(o);\n    }\n\n    public static void ln(Object o) {\n        out.println(o);\n    }\n\n    public static void ln() {\n        out.println();\n    }\n}\n", "test_IO": {"input": ["7 4\n9R2A993\n0E314A0\n8A900DE\n820R037\n6 7\nJH03HE\nID7722\n0DA1AH\n30C9G5\n99971A\nCA7EAI\nAHLBEM\n20 2\nA1234567891234CBDEGH\nBDEDF908034265091499\n0 0\n"], "output": ["23900037\n771971\n12345908034265091499\n"]}, "modified_context": "import static java.lang.System.*;\n\nimport java.math.BigInteger;\nimport java.util.*;\n\nclass SampleSolution {\n    public static Scanner sc = new Scanner(in);\n    public static Random rand = new Random();\n\n    public void run() {\n        TCase:\n        while (true) {\n            int W = sc.nextInt(), H = sc.nextInt();\n            if (W == 0 && H == 0) return;\n            char[][] map = new char[H][W];\n\n            for (int h = 0; h < H; h++) {\n                map[h] = sc.next().toCharArray();\n            }\n\n            BigInteger[][] dp = new BigInteger[H][W];\n\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    BigInteger hprev = BigInteger.ZERO;\n                    if (h >= 1) {\n                        hprev = dp[h - 1][w];\n                    }\n                    BigInteger wprev = BigInteger.ZERO;\n                    if (w >= 1) {\n                        wprev = dp[h][w - 1];\n                    }\n                    if (Character.isDigit(map[h][w]) ) {\n                        BigInteger max;\n                        if (hprev.compareTo(wprev) > 0) {\n                            max = hprev;\n                        } else {\n                            max = wprev;\n                        }\n                        dp[h][w] = max.multiply(BigInteger.TEN).add(new BigInteger(map[h][w] + \"\") );\n                    } else {\n                        dp[h][w] = BigInteger.ZERO;\n                    }\n                }\n            BigInteger max = BigInteger.ZERO;\n            for (int h = 0; h < H; h++)\n                for (int w = 0; w < W; w++) {\n                    if (dp[h][w].compareTo(max) > 0) max = dp[h][w];\n                }\n            ln(max);\n        }\n    }\n\n    public static void main(String[] args) {\n        new SampleSolution().run();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = sc.nextInt();\n        }\n        return res;\n    }\n\n    public static void pr(Object o) {\n        out.print(o);\n    }\n\n    public static void ln(Object o) {\n        out.println(o);\n    }\n\n    public static void ln() {\n        out.println();\n    }\n}\n"}
{"id": "Java/170", "code": "import java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            int a = sc.nextInt();\n            String op = sc.next();\n            int b = sc.nextInt();\n\n            if (op.equals(\"?\")) break;\n            if (op.equals(\"+\")) System.out.println(a + b);\n            if (op.equals(\"-\")) System.out.println(a - b);\n            if (op.equals(\"*\")) System.out.println(a * b);\n            if (op.equals(\"/\")) System.out.println(a / b);\n        }\n    }\n}\n", "test_IO": {"input": ["1 + 2\n56 - 18\n13 * 2\n100 / 10\n27 + 81\n0 ? 0\n"], "output": ["3\n38\n26\n10\n108\n"]}, "modified_context": "import java.util.Scanner;\n\nclass SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            int a = sc.nextInt();\n            String op = sc.next();\n            int b = sc.nextInt();\n\n            if (op.equals(\"?\") ) break;\n            if (op.equals(\"+\") ) System.out.println(a + b);\n            if (op.equals(\"-\") ) System.out.println(a - b);\n            if (op.equals(\"*\") ) System.out.println(a * b);\n            if (op.equals(\"/\") ) System.out.println(a / b);\n        }\n    }\n}\n"}
{"id": "Java/172", "code": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static final long INF = Long.MAX_VALUE / 2;\n    static final int MOD = 1_000_000_007;\n    static final int SIZE = 1_000_000;\n    long[] fac = new long[SIZE];\n    long[] inv = new long[SIZE];\n    long[] finv = new long[SIZE];\n    FastScanner sc = new FastScanner();\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    void solve() {\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            int s = sc.nextInt();\n            int c = sc.nextInt();\n            if (map.get(s) != null && map.get(s) != c) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n            map.put(s, c);\n        }\n\n        for (int i = 0; i < 1000; i++) {\n            String s = \"\" + i;\n            boolean flag = true;\n            if (s.length() < n) continue;\n            for (int j = 0; j < n; j++) {\n                if ((map.get(j + 1) != null\n                                && map.get(j + 1) != Character.getNumericValue(s.charAt(j)))\n                        || (map.get(j + 1) == null\n                                && Character.getNumericValue(s.charAt(j)) != 0)) {\n                    if (map.get(j + 1) == null\n                            && j == 0\n                            && Character.getNumericValue(s.charAt(j)) == 1) {\n                        continue;\n                    }\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag && s.length() == n) {\n                System.out.println(s);\n                System.exit(0);\n            }\n        }\n\n        System.out.println(-1);\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    long inv(long a) {\n        return pow(a, MOD - 2);\n    }\n\n    long pow(long a, long r) {\n        long sum = 1;\n        while (r > 0) {\n            if ((r & 1) == 1) {\n                sum *= a;\n                sum %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            r >>= 1;\n        }\n        return sum;\n    }\n\n    long modFact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * modFact(n - 1) % MOD;\n    }\n\n    long fact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * fact(n - 1);\n    }\n\n    void initCOMB() {\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for (int i = 2; i < SIZE; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    long modComb(int n, int r) {\n        if (n < r || n < 0 || r < 0) return 0;\n        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;\n    }\n\n    long comb(long n, long r) {\n        long num = 1;\n        for (long i = 1; i <= r; i++) {\n            num = num * (n - i + 1) / i;\n        }\n        return num;\n    }\n\n    boolean isPrime(long a) {\n        if (a <= 1) return false;\n        for (int i = 2; i * i <= a; i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    String nextPermutation(String s) {\n        ArrayList<Character> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) list.add(s.charAt(i));\n\n        int pivotPos = -1;\n        char pivot = 0;\n        for (int i = list.size() - 2; i >= 0; i--) {\n            if (list.get(i) < list.get(i + 1)) {\n                pivotPos = i;\n                pivot = list.get(i);\n                break;\n            }\n        }\n\n        if (pivotPos == -1 && pivot == 0) return null;\n\n        int L = pivotPos + 1;\n        int R = list.size() - 1;\n        int minPos = -1;\n        char min = Character.MAX_VALUE;\n        for (int i = R; i >= L; i--) {\n            if (pivot < list.get(i)) {\n                if (list.get(i) < min) {\n                    min = list.get(i);\n                    minPos = i;\n                }\n            }\n        }\n\n        Collections.swap(list, pivotPos, minPos);\n        Collections.sort(list.subList(L, R + 1));\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i));\n\n        return sb.toString();\n    }\n\n    boolean nextPermutation(long[] a) {\n        for (int i = a.length - 1; i > 0; i--) {\n            if (a[i - 1] < a[i]) {\n                int swapIndex = find(a[i - 1], a, i, a.length - 1);\n                long temp = a[swapIndex];\n                a[swapIndex] = a[i - 1];\n                a[i - 1] = temp;\n                Arrays.sort(a, i, a.length);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int find(long dest, long[] a, int s, int e) {\n        if (s == e) {\n            return s;\n        }\n        int m = (s + e + 1) / 2;\n        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n    }\n\n    void elimination(int[][] a, int[] b) {\n        int n = a.length;\n        double f;\n        for (int k = 0; k < n - 1; k++) {\n            for (int i = k + 1; i < n; i++) {\n                f = -a[i][k] / a[k][k];\n                for (int j = k + 1; j < n; j++) {\n                    a[i][j] += f * a[k][j];\n                }\n                b[i] += f * b[k];\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i + 1; j < n; j++) {\n                    b[i] -= a[i][j] * b[j];\n                }\n                b[i] = b[i] / a[i][i];\n            }\n        }\n    }\n}\n\nclass Pair implements Comparable<Pair> {\n    long a, b;\n\n    public Pair(long i, long j) {\n        a = i;\n        b = j;\n    }\n\n    @Override\n    public int compareTo(Pair p) {\n        if (this.b < p.b) return -1;\n        else if (this.b > p.b) return 1;\n        else return 0;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "test_IO": {"input": ["3 3\n1 7\n3 2\n1 7\n"], "output": ["702\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\nclass SampleSolution {\n    static final long INF = Long.MAX_VALUE / 2;\n    static final int MOD = 1_000_000_007;\n    static final int SIZE = 1_000_000;\n    long[] fac = new long[SIZE];\n    long[] inv = new long[SIZE];\n    long[] finv = new long[SIZE];\n    FastScanner sc = new FastScanner();\n\n    public static void main(String[] args) {\n        new SampleSolution().solve();\n    }\n\n    void solve() {\n\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Map<Integer, Integer> map = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            int s = sc.nextInt();\n            int c = sc.nextInt();\n            if (map.get(s) != null && map.get(s) != c) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n            map.put(s, c);\n        }\n\n        for (int i = 0; i < 1000; i++) {\n            String s = \"\" + i;\n            boolean flag = true;\n            if (s.length() < n) continue;\n            for (int j = 0; j < n; j++) {\n                if ((map.get(j + 1) != null\n                                && map.get(j + 1) != Character.getNumericValue(s.charAt(j) ) )\n                        || (map.get(j + 1) == null\n                                && Character.getNumericValue(s.charAt(j) ) != 0) ) {\n                    if (map.get(j + 1) == null\n                            && j == 0\n                            && Character.getNumericValue(s.charAt(j) ) == 1) {\n                        continue;\n                    }\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag && s.length() == n) {\n                System.out.println(s);\n                System.exit(0);\n            }\n        }\n\n        System.out.println(-1);\n    }\n\n    long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    long lcm(long a, long b) {\n        return a * b / gcd(a, b);\n    }\n\n    long inv(long a) {\n        return pow(a, MOD - 2);\n    }\n\n    long pow(long a, long r) {\n        long sum = 1;\n        while (r > 0) {\n            if ((r & 1) == 1) {\n                sum *= a;\n                sum %= MOD;\n            }\n            a *= a;\n            a %= MOD;\n            r >>= 1;\n        }\n        return sum;\n    }\n\n    long modFact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * modFact(n - 1) % MOD;\n    }\n\n    long fact(long n) {\n        if (n == 0) {\n            return 1;\n        }\n        return n * fact(n - 1);\n    }\n\n    void initCOMB() {\n        fac[0] = fac[1] = 1;\n        inv[1] = 1;\n        finv[0] = finv[1] = 1;\n        for (int i = 2; i < SIZE; i++) {\n            fac[i] = fac[i - 1] * i % MOD;\n            inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n            finv[i] = finv[i - 1] * inv[i] % MOD;\n        }\n    }\n\n    long modComb(int n, int r) {\n        if (n < r || n < 0 || r < 0) return 0;\n        return fac[n] * finv[r] % MOD * finv[n - r] % MOD;\n    }\n\n    long comb(long n, long r) {\n        long num = 1;\n        for (long i = 1; i <= r; i++) {\n            num = num * (n - i + 1) / i;\n        }\n        return num;\n    }\n\n    boolean isPrime(long a) {\n        if (a <= 1) return false;\n        for (int i = 2; i * i <= a; i++) {\n            if (a % i == 0) return false;\n        }\n        return true;\n    }\n\n    String nextPermutation(String s) {\n        ArrayList<Character> list = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) list.add(s.charAt(i) );\n\n        int pivotPos = -1;\n        char pivot = 0;\n        for (int i = list.size() - 2; i >= 0; i--) {\n            if (list.get(i) < list.get(i + 1) ) {\n                pivotPos = i;\n                pivot = list.get(i);\n                break;\n            }\n        }\n\n        if (pivotPos == -1 && pivot == 0) return null;\n\n        int L = pivotPos + 1;\n        int R = list.size() - 1;\n        int minPos = -1;\n        char min = Character.MAX_VALUE;\n        for (int i = R; i >= L; i--) {\n            if (pivot < list.get(i) ) {\n                if (list.get(i) < min) {\n                    min = list.get(i);\n                    minPos = i;\n                }\n            }\n        }\n\n        Collections.swap(list, pivotPos, minPos);\n        Collections.sort(list.subList(L, R + 1) );\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < list.size(); i++) sb.append(list.get(i) );\n\n        return sb.toString();\n    }\n\n    boolean nextPermutation(long[] a) {\n        for (int i = a.length - 1; i > 0; i--) {\n            if (a[i - 1] < a[i]) {\n                int swapIndex = find(a[i - 1], a, i, a.length - 1);\n                long temp = a[swapIndex];\n                a[swapIndex] = a[i - 1];\n                a[i - 1] = temp;\n                Arrays.sort(a, i, a.length);\n                return true;\n            }\n        }\n        return false;\n    }\n\n    int find(long dest, long[] a, int s, int e) {\n        if (s == e) {\n            return s;\n        }\n        int m = (s + e + 1) / 2;\n        return a[m] <= dest ? find(dest, a, s, m - 1) : find(dest, a, m, e);\n    }\n\n    void elimination(int[][] a, int[] b) {\n        int n = a.length;\n        double f;\n        for (int k = 0; k < n - 1; k++) {\n            for (int i = k + 1; i < n; i++) {\n                f = -a[i][k] / a[k][k];\n                for (int j = k + 1; j < n; j++) {\n                    a[i][j] += f * a[k][j];\n                }\n                b[i] += f * b[k];\n            }\n            for (int i = n - 1; i >= 0; i--) {\n                for (int j = i + 1; j < n; j++) {\n                    b[i] -= a[i][j] * b[j];\n                }\n                b[i] = b[i] / a[i][i];\n            }\n        }\n    }\n}\n\nclass Pair implements Comparable<Pair> {\n    long a, b;\n\n    public Pair(long i, long j) {\n        a = i;\n        b = j;\n    }\n\n    @Override\n    public int compareTo(Pair p) {\n        if (this.b < p.b) return -1;\n        else if (this.b > p.b) return 1;\n        else return 0;\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte() ) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b) ) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b) ) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n}\n"}
{"id": "Java/176", "code": "import java.util.*;\n\npublic class SampleSolution {\n\n    static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n\n        long n = nextLong();\n        long a = nextLong();\n        long b = nextLong();\n\n        long sa = Math.abs(a - b);\n\n        long ans = 0;\n\n        if (sa % 2 == 0) {\n            ans = sa / 2;\n        } else {\n            long AAA = Math.min((n - a), (a - 1));\n            long BBB = Math.min((n - b), (b - 1));\n\n            ans = Math.min(AAA, BBB);\n\n            sa -= 1;\n            ans += 1;\n\n            ans += sa / 2;\n        }\n\n        System.out.println(ans);\n    }\n\n    static String next() {\n        return sc.next();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(sc.next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(sc.next());\n    }\n\n    static double nextDouble() {\n        return Double.parseDouble(sc.next());\n    }\n\n    static String[] splitString(String s) {\n        return s.split(\"\");\n    }\n\n    static char[] splitChar(String s) {\n        return s.toCharArray();\n    }\n\n    static int charToInt(char aaa) {\n        return aaa - 48;\n    }\n\n    public static int maxInt(int[] a, int lng) {\n        int max = a[0];\n        for (int i = 1; i < lng; i++) {\n            max = Math.max(max, a[i]);\n        }\n        return max;\n    }\n\n    public static int minInt(int[] a, int lng) {\n        int min = a[0];\n        for (int i = 1; i < lng; i++) {\n            min = Math.min(min, a[i]);\n        }\n        return min;\n    }\n\n    public static long maxLong(long[] a, int lng) {\n        long max = a[0];\n        for (int i = 1; i < lng; i++) {\n            max = Math.max(max, a[i]);\n        }\n        return max;\n    }\n\n    public static long minLong(long[] a, int lng) {\n        long min = a[0];\n        for (int i = 1; i < lng; i++) {\n            min = Math.min(min, a[i]);\n        }\n        return min;\n    }\n}\n", "test_IO": {"input": ["5 2 4\n"], "output": ["1\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n\n    static Scanner sc = new Scanner(System.in);\n\n    public static void main(String[] args) {\n\n        long n = nextLong();\n        long a = nextLong();\n        long b = nextLong();\n\n        long sa = Math.abs(a - b);\n\n        long ans = 0;\n\n        if (sa % 2 == 0) {\n            ans = sa / 2;\n        } else {\n            long AAA = Math.min((n - a), (a - 1) );\n            long BBB = Math.min((n - b), (b - 1) );\n\n            ans = Math.min(AAA, BBB);\n\n            sa -= 1;\n            ans += 1;\n\n            ans += sa / 2;\n        }\n\n        System.out.println(ans);\n    }\n\n    static String next() {\n        return sc.next();\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(sc.next() );\n    }\n\n    static long nextLong() {\n        return Long.parseLong(sc.next() );\n    }\n\n    static double nextDouble() {\n        return Double.parseDouble(sc.next() );\n    }\n\n    static String[] splitString(String s) {\n        return s.split(\"\");\n    }\n\n    static char[] splitChar(String s) {\n        return s.toCharArray();\n    }\n\n    static int charToInt(char aaa) {\n        return aaa - 48;\n    }\n\n    public static int maxInt(int[] a, int lng) {\n        int max = a[0];\n        for (int i = 1; i < lng; i++) {\n            max = Math.max(max, a[i]);\n        }\n        return max;\n    }\n\n    public static int minInt(int[] a, int lng) {\n        int min = a[0];\n        for (int i = 1; i < lng; i++) {\n            min = Math.min(min, a[i]);\n        }\n        return min;\n    }\n\n    public static long maxLong(long[] a, int lng) {\n        long max = a[0];\n        for (int i = 1; i < lng; i++) {\n            max = Math.max(max, a[i]);\n        }\n        return max;\n    }\n\n    public static long minLong(long[] a, int lng) {\n        long min = a[0];\n        for (int i = 1; i < lng; i++) {\n            min = Math.min(min, a[i]);\n        }\n        return min;\n    }\n}\n"}
{"id": "Java/177", "code": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        boolean ju[] = new boolean[100001];\n        int pe[] = new int[100001];\n        int wa = 0;\n        int ac = 0;\n\n        for (int i = 0; i < b; i++) {\n            int n = sc.nextInt();\n            String res = sc.next();\n\n            if (res.equals(\"WA\") && ju[n - 1] != true) {\n                pe[n - 1]++;\n            }\n\n            if (res.equals(\"AC\")) {\n                ju[n - 1] = true;\n            }\n        }\n\n        for (int i = 0; i < a; i++) {\n            if (ju[i]) {\n                ac++;\n                wa += pe[i];\n            }\n        }\n\n        System.out.println(\"\" + ac + \" \" + wa);\n    }\n}\n", "test_IO": {"input": ["2 5\n1 WA\n1 AC\n2 WA\n2 AC\n2 WA\n"], "output": ["2 2\n"]}, "modified_context": "import java.util.*;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n        boolean ju[] = new boolean[100001];\n        int pe[] = new int[100001];\n        int wa = 0;\n        int ac = 0;\n\n        for (int i = 0; i < b; i++) {\n            int n = sc.nextInt();\n            String res = sc.next();\n\n            if (res.equals(\"WA\") && ju[n - 1] != true) {\n                pe[n - 1]++;\n            }\n\n            if (res.equals(\"AC\") ) {\n                ju[n - 1] = true;\n            }\n        }\n\n        for (int i = 0; i < a; i++) {\n            if (ju[i]) {\n                ac++;\n                wa += pe[i];\n            }\n        }\n\n        System.out.println(\"\" + ac + \" \" + wa);\n    }\n}\n"}
{"id": "Java/178", "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    static long[] dp;\n    static int mod = 1000000007;\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int s = sc.nextInt();\n        sc.close();\n\n        dp = new long[s + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 1;\n        System.out.println(dfs(s));\n    }\n\n    static long dfs(int s) {\n        if (dp[s] != -1) {\n            return dp[s];\n        }\n\n        long ret = 0;\n        for (int i = s - 3; i >= 0; i--) {\n            ret += dfs(i);\n            ret %= mod;\n        }\n        return dp[s] = ret;\n    }\n}\n", "test_IO": {"input": ["7\n"], "output": ["3\n"]}, "modified_context": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    static long[] dp;\n    static int mod = 1000000007;\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int s = sc.nextInt();\n        sc.close();\n\n        dp = new long[s + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 1;\n        System.out.println(dfs(s) );\n    }\n\n    static long dfs(int s) {\n        if (dp[s] != -1) {\n            return dp[s];\n        }\n\n        long ret = 0;\n        for (int i = s - 3; i >= 0; i--) {\n            ret += dfs(i);\n            ret %= mod;\n        }\n        return dp[s] = ret;\n    }\n}\n"}
{"id": "Java/181", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static final int BIG_NUM = 2000000000;\n    public static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int ans;\n\n        while (true) {\n\n            try {\n                String inputed = br.readLine();\n                if (inputed.length() == 1 && inputed.equals(\"0\")) break;\n\n                ans = 0;\n                for (int i = 0; i < inputed.length(); i++) {\n                    ans += inputed.charAt(i) - '0';\n                }\n\n                System.out.printf(\"%d\\n\", ans);\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "test_IO": {"input": ["123\n55\n1000\n0\n"], "output": ["6\n10\n1\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static final int BIG_NUM = 2000000000;\n    public static final int MOD = 1000000007;\n\n    public static void main(String[] args) {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n        int ans;\n\n        while (true) {\n\n            try {\n                String inputed = br.readLine();\n                if (inputed.length() == 1 && inputed.equals(\"0\") ) break;\n\n                ans = 0;\n                for (int i = 0; i < inputed.length(); i++) {\n                    ans += inputed.charAt(i) - '0';\n                }\n\n                System.out.printf(\"%d\\n\", ans);\n\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n"}
{"id": "Java/182", "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        String[] s = parseLine().split(\" \");\n        int a = Integer.parseInt(s[0]);\n        int b = Integer.parseInt(s[1]);\n        if (b % a == 0) {\n            System.out.println(a + b);\n        } else {\n            System.out.println(b - a);\n        }\n        return;\n    }\n\n    private static String parseLine() {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        try {\n            return reader.readLine();\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n}\n", "test_IO": {"input": ["4 12\n"], "output": ["16\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        String[] s = parseLine().split(\" \");\n        int a = Integer.parseInt(s[0]);\n        int b = Integer.parseInt(s[1]);\n        if (b % a == 0) {\n            System.out.println(a + b);\n        } else {\n            System.out.println(b - a);\n        }\n        return;\n    }\n\n    private static String parseLine() {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in) );\n        try {\n            return reader.readLine();\n        } catch (Exception e) {\n            return e.getMessage();\n        }\n    }\n}\n"}
{"id": "Java/189", "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        Scanner scan = new Scanner(System.in);\n        String mark;\n        int c = 0;\n        int b = 0;\n        int a[] = new int[100000];\n        int x = 0;\n        do {\n            c = scan.nextInt();\n            mark = scan.next();\n            b = scan.nextInt();\n            if (mark.equals(\"?\")) {\n                a[x] = 2000001;\n                break;\n            } else if (mark.equals(\"+\")) {\n                a[x] = c + b;\n            } else if (mark.equals(\"-\")) {\n                a[x] = c - b;\n            } else if (mark.equals(\"*\")) {\n                a[x] = c * b;\n            } else if (mark.equals(\"/\")) {\n                a[x] = c / b;\n            }\n            x++;\n        } while (true);\n        x = 0;\n        do {\n            if (a[x] == 2000001) break;\n            System.out.println(a[x]);\n            x++;\n        } while (true);\n        scan.close();\n    }\n}\n", "test_IO": {"input": ["1 + 2\n56 - 18\n13 * 2\n100 / 10\n27 + 81\n0 ? 0\n"], "output": ["3\n38\n26\n10\n108\n"]}, "modified_context": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) throws IOException {\n        Scanner scan = new Scanner(System.in);\n        String mark;\n        int c = 0;\n        int b = 0;\n        int a[] = new int[100000];\n        int x = 0;\n        do {\n            c = scan.nextInt();\n            mark = scan.next();\n            b = scan.nextInt();\n            if (mark.equals(\"?\") ) {\n                a[x] = 2000001;\n                break;\n            } else if (mark.equals(\"+\") ) {\n                a[x] = c + b;\n            } else if (mark.equals(\"-\") ) {\n                a[x] = c - b;\n            } else if (mark.equals(\"*\") ) {\n                a[x] = c * b;\n            } else if (mark.equals(\"/\") ) {\n                a[x] = c / b;\n            }\n            x++;\n        } while (true);\n        x = 0;\n        do {\n            if (a[x] == 2000001) break;\n            System.out.println(a[x]);\n            x++;\n        } while (true);\n        scan.close();\n    }\n}\n"}
{"id": "Java/190", "code": "import java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String sa = sc.next();\n        String sb = sc.next();\n        BigDecimal A = new BigDecimal(sa);\n        BigDecimal B = new BigDecimal(sb);\n        System.out.println(A.multiply(B).setScale(0, BigDecimal.ROUND_DOWN));\n    }\n}\n", "test_IO": {"input": ["198 1.10\n"], "output": ["217\n"]}, "modified_context": "import java.math.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        String sa = sc.next();\n        String sb = sc.next();\n        BigDecimal A = new BigDecimal(sa);\n        BigDecimal B = new BigDecimal(sb);\n        System.out.println(A.multiply(B).setScale(0, BigDecimal.ROUND_DOWN) );\n    }\n}\n"}
{"id": "Java/191", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        String S = sc.nextLine();\n        sc.close();\n\n        if (S.length() % 2 == 1) {\n            S = S.substring(0, S.length() - 1);\n        } else {\n            S = S.substring(0, S.length() - 2);\n        }\n\n        for (; S.length() > 0; S = S.substring(0, S.length() - 2)) {\n            if (isEvenString(S)) {\n                break;\n            }\n        }\n        System.out.println(S.length());\n    }\n\n    static boolean isEvenString(String s) {\n        String a = s.substring(0, s.length() / 2);\n        String b = s.substring(s.length() / 2);\n        if (a.equals(b)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n", "test_IO": {"input": ["abaababaab\n"], "output": ["6\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n        String S = sc.nextLine();\n        sc.close();\n\n        if (S.length() % 2 == 1) {\n            S = S.substring(0, S.length() - 1);\n        } else {\n            S = S.substring(0, S.length() - 2);\n        }\n\n        for (; S.length() > 0; S = S.substring(0, S.length() - 2) ) {\n            if (isEvenString(S) ) {\n                break;\n            }\n        }\n        System.out.println(S.length() );\n    }\n\n    static boolean isEvenString(String s) {\n        String a = s.substring(0, s.length() / 2);\n        String b = s.substring(s.length() / 2);\n        if (a.equals(b) ) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"}
{"id": "Java/192", "code": "import static java.lang.Integer.parseInt;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        String[] words;\n\n        line = br.readLine();\n\n        int N, M;\n        N = parseInt(line.substring(0, line.indexOf(' ')));\n        M = parseInt(line.substring(line.indexOf(' ') + 1));\n\n        int[] shortage = new int[M];\n\n        for (int i = 0; i < M; i++) {\n            line = br.readLine();\n            int A = parseInt(line.substring(0, line.indexOf(' ')));\n            shortage[i] = N > A ? N - A : 0;\n        }\n\n        Arrays.sort(shortage);\n\n        int ans = 0;\n\n        for (int i = 0; i < M - 1; i++) {\n            ans += shortage[i];\n        }\n\n        System.out.println(ans);\n    }\n}\n", "test_IO": {"input": ["4 5\n1 7\n6 2\n3 5\n4 4\n0 8\n"], "output": ["4\n"]}, "modified_context": "import static java.lang.Integer.parseInt;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n        String line;\n        String[] words;\n\n        line = br.readLine();\n\n        int N, M;\n        N = parseInt(line.substring(0, line.indexOf(' ') ) );\n        M = parseInt(line.substring(line.indexOf(' ') + 1) );\n\n        int[] shortage = new int[M];\n\n        for (int i = 0; i < M; i++) {\n            line = br.readLine();\n            int A = parseInt(line.substring(0, line.indexOf(' ') ) );\n            shortage[i] = N > A ? N - A : 0;\n        }\n\n        Arrays.sort(shortage);\n\n        int ans = 0;\n\n        for (int i = 0; i < M - 1; i++) {\n            ans += shortage[i];\n        }\n\n        System.out.println(ans);\n    }\n}\n"}
{"id": "Java/194", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = Integer.parseInt(sc.next());\n        int b = Integer.parseInt(sc.next());\n        int c = Integer.parseInt(sc.next());\n        int count = 0;\n        for (int i = a; i <= b; i++) {\n            if (c % i == 0) {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}\n", "test_IO": {"input": ["5 14 80\n"], "output": ["3\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int a = Integer.parseInt(sc.next() );\n        int b = Integer.parseInt(sc.next() );\n        int c = Integer.parseInt(sc.next() );\n        int count = 0;\n        for (int i = a; i <= b; i++) {\n            if (c % i == 0) {\n                count++;\n            }\n        }\n        System.out.println(count);\n    }\n}\n"}
{"id": "Java/195", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        Integer i, j, k, n = 0, m = 0, h = 0, w = 0, ans = 0;\n        long a = 0, b = 0, c = 0, d = 0, x = 0, y = 0, z = 0;\n        List<Integer> l = new ArrayList<>();\n        List<String> s = new ArrayList<>();\n        List<Pair> p = new ArrayList<>();\n\n        n = sc.nextInt();\n\n        for (i = 0; i < n; i++) {\n            l.add(sc.nextInt());\n        }\n\n        Collections.sort(l);\n\n        print(l.get(n / 2) - l.get(n / 2 - 1));\n\n        out.flush();\n    }\n\n    private static void print(Object o) {\n        System.out.println(o.toString());\n    }\n\n    private static long lcm(long m, long n) {\n        return m * n / gcd(m, n);\n    }\n\n    private static long gcd(long m, long n) {\n        if (m < n) return gcd(n, m);\n        if (n == 0) return m;\n        return gcd(n, m % n);\n    }\n\n    private static class Pair {\n        private int key;\n        private int value;\n\n        public Pair(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public int getValue() {\n            return this.value;\n        }\n\n        public int getKey() {\n            return this.key;\n        }\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte()) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b)) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}\n", "test_IO": {"input": ["6\n9 1 4 4 6 7\n"], "output": ["2\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n    public static final long MOD = 1000000007;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        Integer i, j, k, n = 0, m = 0, h = 0, w = 0, ans = 0;\n        long a = 0, b = 0, c = 0, d = 0, x = 0, y = 0, z = 0;\n        List<Integer> l = new ArrayList<>();\n        List<String> s = new ArrayList<>();\n        List<Pair> p = new ArrayList<>();\n\n        n = sc.nextInt();\n\n        for (i = 0; i < n; i++) {\n            l.add(sc.nextInt() );\n        }\n\n        Collections.sort(l);\n\n        print(l.get(n / 2) - l.get(n / 2 - 1) );\n\n        out.flush();\n    }\n\n    private static void print(Object o) {\n        System.out.println(o.toString() );\n    }\n\n    private static long lcm(long m, long n) {\n        return m * n / gcd(m, n);\n    }\n\n    private static long gcd(long m, long n) {\n        if (m < n) return gcd(n, m);\n        if (n == 0) return m;\n        return gcd(n, m % n);\n    }\n\n    private static class Pair {\n        private int key;\n        private int value;\n\n        public Pair(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public int getValue() {\n            return this.value;\n        }\n\n        public int getKey() {\n            return this.key;\n        }\n    }\n}\n\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        } else {\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private int readByte() {\n        if (hasNextByte() ) return buffer[ptr++];\n        else return -1;\n    }\n\n    private static boolean isPrintableChar(int c) {\n        return 33 <= c && c <= 126;\n    }\n\n    public boolean hasNext() {\n        while (hasNextByte() && !isPrintableChar(buffer[ptr]) ) ptr++;\n        return hasNextByte();\n    }\n\n    public String next() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b) ) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext() ) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while (true) {\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            } else if (b == -1 || !isPrintableChar(b) ) {\n                return minus ? -n : n;\n            } else {\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n\n    public int nextInt() {\n        long nl = nextLong();\n        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n        return (int) nl;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n}\n"}
{"id": "Java/197", "code": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int n = s.length();\n        long ans = 0;\n        for (int mask = 0; mask < 1 << (n - 1); mask++) {\n            long sum = 0;\n            String x = \"\" + s.charAt(0);\n            for (int i = 0; i < n - 1; i++) {\n                if ((mask & (1 << i)) >= 1) {\n                    x += \"+\" + s.charAt(i + 1);\n                } else {\n                    x += s.charAt(i + 1);\n                }\n            }\n            String[] split = x.split(\"\\\\+\");\n            for (int i = 0; i < split.length; i++) {\n                sum += Long.valueOf(split[i]);\n            }\n            ans += sum;\n        }\n        System.out.println(ans);\n    }\n}\n", "test_IO": {"input": ["125\n"], "output": ["176\n"]}, "modified_context": "import java.util.Scanner;\n\npublic class SampleSolution {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        int n = s.length();\n        long ans = 0;\n        for (int mask = 0; mask < 1 << (n - 1); mask++) {\n            long sum = 0;\n            String x = \"\" + s.charAt(0);\n            for (int i = 0; i < n - 1; i++) {\n                if ((mask & (1 << i) ) >= 1) {\n                    x += \"+\" + s.charAt(i + 1);\n                } else {\n                    x += s.charAt(i + 1);\n                }\n            }\n            String[] split = x.split(\"\\\\+\");\n            for (int i = 0; i < split.length; i++) {\n                sum += Long.valueOf(split[i]);\n            }\n            ans += sum;\n        }\n        System.out.println(ans);\n    }\n}\n"}
{"id": "Java/198", "code": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public SampleSolution(FastScanner in, PrintWriter out, int test) {\n        int N = in.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) A[i] = in.nextInt();\n        Arrays.sort(A);\n\n        long res = 0;\n\n        PriorityQueue<int[]> q =\n                new PriorityQueue<>(\n                        Comparator.comparingInt((int[] e) -> Math.min(e[0], e[1])).reversed());\n        q.add(new int[] {A[N - 1], A[N - 1]});\n\n        for (int i = N - 2; i >= 0; i--) {\n            int a = A[i];\n            int[] place = q.remove();\n            res += Math.min(place[0], place[1]);\n            q.add(new int[] {place[0], a});\n            q.add(new int[] {a, place[1]});\n        }\n        out.println(res);\n    }\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        FastScanner in = new FastScanner(System.in);\n\n        for (int t = 1; t <= 1; t++) {\n            SampleSolution sol = new SampleSolution(in, out, t);\n        }\n\n        out.close();\n    }\n}\n\nclass FastScanner {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public FastScanner(InputStream stream) {\n        this.stream = stream;\n    }\n\n    int read() {\n        if (numChars == -1) throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) return -1;\n        }\n        return buf[curChar++];\n    }\n\n    boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    boolean isEndline(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String next() {\n        int c = read();\n        while (isSpaceChar(c)) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    String nextLine() {\n        int c = read();\n        while (isEndline(c)) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndline(c));\n        return res.toString();\n    }\n}\n", "test_IO": {"input": ["4\n2 2 1 3\n"], "output": ["7\n"]}, "modified_context": "import java.io.*;\nimport java.util.*;\n\npublic class SampleSolution {\n\n    public SampleSolution(FastScanner in, PrintWriter out, int test) {\n        int N = in.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) A[i] = in.nextInt();\n        Arrays.sort(A);\n\n        long res = 0;\n\n        PriorityQueue<int[]> q =\n                new PriorityQueue<>(\n                        Comparator.comparingInt((int[] e) -> Math.min(e[0], e[1]) ).reversed() );\n        q.add(new int[] {A[N - 1], A[N - 1]});\n\n        for (int i = N - 2; i >= 0; i--) {\n            int a = A[i];\n            int[] place = q.remove();\n            res += Math.min(place[0], place[1]);\n            q.add(new int[] {place[0], a});\n            q.add(new int[] {a, place[1]});\n        }\n        out.println(res);\n    }\n\n    public static void main(String[] args) {\n        PrintWriter out = new PrintWriter(System.out);\n\n        FastScanner in = new FastScanner(System.in);\n\n        for (int t = 1; t <= 1; t++) {\n            SampleSolution sol = new SampleSolution(in, out, t);\n        }\n\n        out.close();\n    }\n}\n\nclass FastScanner {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n\n    public FastScanner(InputStream stream) {\n        this.stream = stream;\n    }\n\n    int read() {\n        if (numChars == -1) throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) return -1;\n        }\n        return buf[curChar++];\n    }\n\n    boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    boolean isEndline(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next() );\n    }\n\n    long nextLong() {\n        return Long.parseLong(next() );\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next() );\n    }\n\n    String next() {\n        int c = read();\n        while (isSpaceChar(c) ) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c) );\n        return res.toString();\n    }\n\n    String nextLine() {\n        int c = read();\n        while (isEndline(c) ) c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndline(c) );\n        return res.toString();\n    }\n}\n"}
{"id": "Java/199", "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        int n = Integer.parseInt(br.readLine());\n\n        String str[] = br.readLine().split(\" \");\n\n        int s[] = new int[100010];\n\n        for (int i = 0; i < n; i++) {\n            s[Integer.parseInt(str[i])]++;\n        }\n\n        int dec = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] != 0) {\n                if (s[i] % 2 == 0) {\n                    s[i] = 2;\n                } else {\n                    s[i] = 1;\n                }\n            }\n        }\n\n        int one = 0;\n        int two = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == 2) {\n                two++;\n            } else if (s[i] == 1) {\n                one++;\n            }\n        }\n\n        if (two % 2 != 0) {\n            one--;\n        }\n\n        System.out.println(two + one);\n    }\n}\n", "test_IO": {"input": ["5\n1 2 1 3 7\n"], "output": ["3\n"]}, "modified_context": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class SampleSolution {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in) );\n\n        int n = Integer.parseInt(br.readLine() );\n\n        String str[] = br.readLine().split(\" \");\n\n        int s[] = new int[100010];\n\n        for (int i = 0; i < n; i++) {\n            s[Integer.parseInt(str[i])]++;\n        }\n\n        int dec = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] != 0) {\n                if (s[i] % 2 == 0) {\n                    s[i] = 2;\n                } else {\n                    s[i] = 1;\n                }\n            }\n        }\n\n        int one = 0;\n        int two = 0;\n\n        for (int i = 0; i < s.length; i++) {\n            if (s[i] == 2) {\n                two++;\n            } else if (s[i] == 1) {\n                one++;\n            }\n        }\n\n        if (two % 2 != 0) {\n            one--;\n        }\n\n        System.out.println(two + one);\n    }\n}\n"}
